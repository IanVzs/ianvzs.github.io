<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>k8s on Ian's Blog</title><link>http://example.org/tags/k8s/</link><description>Recent content in k8s on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Sep 2023 23:01:41 +0000</lastBuildDate><atom:link href="http://example.org/tags/k8s/index.xml" rel="self" type="application/rss+xml"/><item><title>elk在k8s上的部署使用示例</title><link>http://example.org/docs/programmer/cloudnative/k8s/elk%E5%9C%A8k8s%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</link><pubDate>Sun, 24 Sep 2023 23:01:41 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/elk%E5%9C%A8k8s%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</guid><description>示例Yaml # --- apiVersion: v1 kind: ConfigMap metadata: name: filebeat-config namespace: ops labels: k8s-app: filebeat data: filebeat.yml: |- filebeat.config: inputs: # Mounted `filebeat-inputs` configmap: path: ${path.config}/inputs.d/*.yml # Reload inputs configs as they change: reload.enabled: false modules: path: ${path.config}/modules.d/*.yml # Reload module configs as they change: reload.enabled: false output.elasticsearch: hosts: [&amp;#39;49.65.125.91:9200&amp;#39;] --- apiVersion: v1 kind: ConfigMap metadata: name: filebeat-inputs namespace: ops labels: k8s-app: filebeat data: kubernetes.yml: |- - type: docker containers.</description></item><item><title>k8s 配套说明</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E9%85%8D%E5%A5%97%E8%AF%B4%E6%98%8E/</link><pubDate>Thu, 07 Sep 2023 20:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E9%85%8D%E5%A5%97%E8%AF%B4%E6%98%8E/</guid><description>ctr # 如果定义了 -n 应该是namesplace 那么每个命令都得跟上
load镜像 # sudo ctr -n=k8s.io images import ${imageTarFile}
保存文件 # sudo ctr -n k8s.io images export &amp;ndash;platform=linux/amd64 hi.tar 101.32.1.4:30002/web-docker/worker:2121
切换tag # sudo ctr -n k8s.io images tag &amp;ndash;force repos.x.com/web-docker/worker:2121 101.32.1.4:30002/web-docker/worker:2121
推送镜像 # sudo ctr -n k8s.io images push -k -u admin:fat213asfdFS2W &amp;ndash;plain-http 101.32.1.4:30002/web-docker/worker:2121
拉取 # sudo ctr -n k8s.io images pull -k -u admin:fat1239ASD124W &amp;ndash;plain-http 101.32.1.4:30002/web-docker/worker:2121
Docker # [[Note of Docker]] 好像并没有整理docker命令&amp;hellip; 后续补吧</description></item><item><title>k8s技术分享</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</link><pubDate>Thu, 07 Sep 2023 20:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</guid><description>k8s技术分享 # 工作负载资源 # 一、pod # 1. 概要 # 可创建管理、最小的可部署计算单元，是可以在主机上运行的容器的集合 我们的服务都在其中运行。如我们的服务是nginx，则最内层是我们的服务 nginx，运行在 container 容器当中。container (容器) 的本质是进程，而 pod 是管理这一组进程的资源 所以pod可视为一个极为轻量化、没插网线的电脑，如果所需任务无需交互，那么用pod就很合适。例如给它挂载一个文件来训练模型、生成报表，可以根据场景使用 Job 或者 CronJob 或者其它 图示关系如下 # ![[k8s-pod-insert.png]]
2. pod网络 # 当然，pod 可以管理多个 container，又因为container (容器) 的本质是进程，如果有本地网络通信需求(使用 localhost 或者 Socket 文件进行本地通信)，在这些场景中使用 pod 管理多个 container 就非常的推荐。
如下图展示了Pod网络所依赖的3个网络设备
1. eth0是节点主机上的网卡，支持该节点流量出入的设备、也是支持集群节点间IP寻址和互通的设备；
2. docker0是一个虚拟网桥，可以简单理解为一个虚拟交换机，支持该节点上的Pod之间进行IP寻址和互通的设备；
3. veth0则是Pod1的虚拟网卡，支持该Pod内容器互通和对外访问的虚拟设备；
4. docker0网桥和veth0网卡，都是linux支持和创建的虚拟网络设备；
5. pause属于特殊容器，其运行的唯一目的是为Pod建立共享的veth0网络接口
![[k8s-nginx-pod.png]]
二、deployment、StatefulSet # 1. 概要 # Deployment 使得 Pod 和 ReplicaSet 能够进行声明式更新
StatefulSet 表示一组具有一致身份的 Pod：
1. 身份定义为：</description></item></channel></rss>