<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Ian's Blog</title><link>http://example.org/tags/python/</link><description>Recent content in python on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 24 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python包管理</title><link>http://example.org/docs/programmer/langs/python/python%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</link><pubDate>Mon, 24 Mar 2025 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/python%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/</guid><description>[[Rye 简单使用指南]] # Rye 是一个由 Flask 作者 Armin Ronacher 开发的 Python 版本和依赖管理工具，类似于 Pyenv + Poetry 的组合。
安装 Rye # curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh # 安装cargo cargo install --git https://github.com/mitsuhiko/rye rye # 安装rye cargo的 .bashrc 相关:
略略略略略略 . &amp;#34;$HOME/.cargo/env&amp;#34; 基本命令 # 初始化新项目 # rye init my_project cd my_project 指定 Python 版本 # rye pin 3.9.10 # 指定使用 Python 3.9.10 添加依赖 # rye add flask==2.3.2 rye add black --dev # 添加开发依赖 同步依赖 # rye sync 运行项目 # rye run python main.</description></item><item><title>Python编码规范</title><link>http://example.org/docs/programmer/langs/python/%E8%A7%84%E8%8C%83/</link><pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/%E8%A7%84%E8%8C%83/</guid><description> 函数返回值定义 # 多个返回值 - Tuple # async def function_name(package_name: str) -&amp;gt; Tuple[ParamsPushLvl2Pool, bool]: pass 支持传入多类型 - Union # ex: Union[ExpiryT, None] = None, 迭代 # def _yield_offer_info(_session, from_days_ago: int) -&amp;gt; Iterator[Offer]:</description></item><item><title>Python Redis 客户端</title><link>http://example.org/docs/programmer/cloudnative/redis/python-redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/redis/python-redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>异步调用时自动关闭 # 当事件循环正在运行时，会创建一个任务来关闭 redis 连接，而不会阻塞事件循环。如果事件循环没有运行，就可以像之前一样调用 run_until_complete。
async def close_redis(self): if self.redis: await self.redis.close() def __del__(self): loop = asyncio.get_event_loop() if loop.is_running(): asyncio.create_task(self.close_redis()) else: loop.run_until_complete(self.close_redis()) 数据迁移(hash数据) # 脚本 # import os import json import redis import argparse from loguru import logger home_path = os.environ.get(&amp;#39;HOME&amp;#39;) parser = argparse.ArgumentParser(description=&amp;#39;Copy Reten Config&amp;#39;) parser.add_argument(&amp;#39;--mode&amp;#39;, help=&amp;#39;Pull or Push data from Redis&amp;#39;) parser.add_argument(&amp;#39;-ds&amp;#39;, &amp;#39;--datasource&amp;#39;, help=&amp;#39;retens or events config data from Redis&amp;#39;) args = parser.parse_args() source_redis = redis.StrictRedis(host=&amp;#39;redis-product.com&amp;#39;, port=6379, db=0) def scan_keys_with_pattern(pattern): # 初始游标 cursor = &amp;#39;0&amp;#39; count_group = 0 while True: # 使用 SCAN 命令进行迭代 cursor, keys = source_redis.</description></item><item><title>Python 多线程多进程</title><link>http://example.org/docs/programmer/langs/python/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</guid><description>一个协程示例： import asyncio async def my_coroutine(): # 这里是协程的代码 await asyncio.sleep(1) print(&amp;#34;Coroutine is done&amp;#34;) async def main(): # 创建一个任务对象 task = asyncio.create_task(my_coroutine()) # 等待任务完成 await task # 运行主协程 asyncio.run(main()) 一个线程示例： import threading # 定义一个函数，用于在线程中执行 def thread_function(name): print(f&amp;#34;Thread {name}: starting&amp;#34;) # 在这里执行一些操作 print(f&amp;#34;Thread {name}: finishing&amp;#34;) # 创建线程的实例 thread = threading.Thread(target=thread_function, args=(1,)) # 启动线程 thread.start() # 等待线程结束 thread.join() print(&amp;#34;Main thread is done&amp;#34;) 一个loop tip： self.loop = asyncio.get_event_loop() self.queue.set_loop(loop=self.loop) await self.af.set_loop(loop=self.loop) await self.adjust.set_loop(loop=self.loop) 为什么这里使用同一个loop ?</description></item><item><title>Python 常用库</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>pydantic # 来自类 # from pydantic import BaseModel class User(BaseModel): name: str age: int class Config: from_attributes = True # 假设我们有一个普通的 Python 对象，它具有与模型字段相同的属性名 class OrdinaryObject: def __init__(self, name, age): self.name = name self.age = age # 创建一个 OrdinaryObject 实例 ordinary_object = OrdinaryObject(name=&amp;#39;Alice&amp;#39;, age=30) # 现在我们可以直接将 ordinary_object 传递给 User 模型的构造函数 user_model = User(ordinary_object) # 输出模型的字段值 print(user_model.dict()) # 输出: {&amp;#39;name&amp;#39;: &amp;#39;Alice&amp;#39;, &amp;#39;age&amp;#39;: 30} 自定义字段 # class User(BaseModel): id: int is_active: bool wx_infos: List[str] = [] class Config: arbitrary_types_allowed = True # 允许任意类型 Tuple定义问题 # from typing import List, Tuple class Task(BaseModel): launch_count_today: int launch_groups: List[Tuple[str, .</description></item><item><title>Python 笔记</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>pip cache 目录 # echo $PIP_CACHE_DIR 特殊函数调用 property # 使用字段的方式调用函数
from datetime import datetime from pydantic import BaseModel class InstallCountInfo(BaseModel): count: int total: int @property def done_rate(self): return round(self.count / self.total, 4) class InstallCount(BaseModel): pass_day: int install_day: datetime info: InstallCountInfo 彻底摆脱to_dict和from_dict # 使用 pydantic # BaseModel类型支持:
b = BattleAxiePositionInfo.parse_obj(DICT_DATA) b.json() b.dict() parse_file parse_raw from pydantic import BaseModel class PositionInfo(BaseModel): error: int = -1 # 收集错误 none: int = 0 # 还没开始 clicked: int = 1 # 在client 赋此值 done: int = 2 # 在server 赋此值 xy: List[int] = [0, 0] status: int = 0 # clicked or done or none or error class BattleAxiePositionInfo(BaseModel): our: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] enemy: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] pp = BattleAxiePositionInfo() print(f&amp;#34;pp json: {pp.</description></item><item><title>Py小工具和功能性方法</title><link>http://example.org/docs/programmer/langs/python/py%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/py%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7%E6%96%B9%E6%B3%95/</guid><description>author:Ian
邮件 # 中文附件 # 发送邮件时携带附件 中文名称附件
def send_email_week_report(htm, recipients, copys, file_name, file_path): port = 465 # str_today = datetime.now().strftime(&amp;#34;%Y-%m-%d %H:%M:%S&amp;#34;) str_today = datetime.now().strftime(&amp;#34;%Y-%m-%d&amp;#34;) mail_host = &amp;#34;mail.{demo}.com&amp;#34; mail_user = &amp;#34;{user name}&amp;#34; mail_pass = &amp;#34;{passwd}&amp;#34; sender = &amp;#39;{name}@{demo}.com&amp;#39; mail_from = &amp;#34;{name} &amp;lt;{name}@{demo}.com&amp;gt;&amp;#34; msg_Bcc = &amp;#39;{name}@{demo}.com&amp;#39; subject = f&amp;#34;{title}-{str_today}&amp;#34; # 标题 msg = MIMEMultipart() msg.attach(MIMEText(htm, &amp;#39;html&amp;#39;, &amp;#39;utf-8&amp;#39;)) # 这里可以传html内容 也可以传普通文字 # 创建附件 with open(file_path, &amp;#39;rb&amp;#39;) as attachment: part = MIMEBase(&amp;#39;application&amp;#39;, &amp;#39;octet-stream&amp;#39;) part.set_payload(attachment.read()) encoders.</description></item><item><title>图形化界面 （Python Gui）</title><link>http://example.org/docs/programmer/gui/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/gui/notespython/</guid><description>author:Ian
Python GUI 💽 # pynput # 在 pynput 模块中，Win键被称为“特殊键”（Special keys），需要使用特殊的名称来表示。
以下是可以使用的特殊键名称列表：
https://pynput.readthedocs.io/en/latest/keyboard.html?highlight=%3Ccmd%3E#controlling-the-keyboard 因此，如果你想要在热键设置中使用 Win键+空格 这个热键，可以将它们分别替换为 cmd 和 space，如下所示：
from pynput import keyboard def on_activate(): print(&amp;#39;Hotkey activated&amp;#39;) def on_exit(): print(&amp;#39;Hotkey exited&amp;#39;) return False with keyboard.GlobalHotKeys({&amp;#39;&amp;lt;cmd&amp;gt;+&amp;lt;space&amp;gt;&amp;#39;: on_activate}) as h: h.join(on_exit)``` 在这个例子中，我们使用 &amp;lt;cmd&amp;gt;+&amp;lt;space&amp;gt; 来表示 Win键+空格 热键，因为在Mac中，Command键（cmd）可以起到类似于Win键的作用。 ## PyQt ![qt](https://tse4-mm.cn.bing.net/th/id/OIP.J4_Nqrcc0x7slHHUFwKLSQHaI6?pid=ImgDet&amp;amp;rs=1 &amp;#34;tmp&amp;#34;) 官方说明文档：&amp;lt;http://pyqt.sourceforge.net/Docs/PyQt4/index.html&amp;gt; 照例，先贴网址： &amp;lt;http://www.qaulau.com/books/PyQt4_Tutorial/index.html&amp;gt; ## 画界面 #PyQt4使用designer.exe import os for root, dirs, files in os.walk(&amp;#39;.&amp;#39;): for file in files: if file.endswith(&amp;#39;.ui&amp;#39;): os.system(&amp;#39;pyuic4 -o ui_%s.</description></item><item><title>机器学习库</title><link>http://example.org/docs/programmer/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid><description>Python 机器学习库 👽 # Plotly # 与matplotlib 都是绘图工具，不过效果炫一些，我也没画过，所以只放链接，不放实例了 Plotly Python Library : https://plot.ly/python/
matplotlib # import matplotlib.pyplot as plt 参数等太多，链接最可靠 # pyplot参数
还是粘一些常用的： marker 属性（下面写在分号里呦） o . v ^ &amp;lt; &amp;gt; 1 2 3 4 8 s p * h H + x D d | _ 之类
画出一些“花儿”
绘图 # plt.plot(x, y) # 在y之后可添加参数，例如常用的label = ‘IamLabel’之类 # 线的样式、颜色 ：b: blue g: green r: red c: cyan m: magenta y: yellow k: black w: white '-' : solid , '--' : dashed, '-.</description></item><item><title>解决问题</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>PiP Not Found Issue # 使用pip安装某包时， 提示让更新， 按提示操作更新没效果没反应再用就提示ModuleNotFoundError: No module named 'pip' (ˉ▽ˉ；)&amp;hellip;
ModuleNotFoundError: No module named &amp;lsquo;pip&amp;rsquo; # 升级PiP时出现问题可由下方命令修复 # python -m ensurepip python -m pip install --upgrade pip SSL校验 # 安装EasyOCR时, reader = easyocr.Reader(['ch_sim','en']) 下载到接近90,结果报错了&amp;hellip;. 估计是SSL问题加入以下两条,不知如何.
import ssl ssl._create_default_https_context = ssl._create_unverified_context from http.client To revert to the previous, unverified, behavior ssl._create_unverified_context() can be passed to the context parameter.
使用国内镜像下载Python # pip install --index https://pypi.mirrors.ustc.edu.cn/simple/ dlib(numpy等包名) # 一键更新pip 包资源(利用管道grep传输查询到的需要更新包名，传输到install命令) pip3 freeze --local | grep -v &amp;#39;^\-e&amp;#39; | cut -d = -f 1 | xargs -n1 pip3 install -U # 权限不够的话就在`pip3 install` 之前加`sudo`反正我不习惯用`root` 安装错误？ # 居然有pip3 install XX的错误…这也是因为有旧版pip3存留。需要</description></item></channel></rss>