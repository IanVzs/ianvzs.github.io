<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Ian's Blog</title><link>http://example.org/tags/golang/</link><description>Recent content in golang on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 25 Sep 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>把Golang当脚本语言用</title><link>http://example.org/docs/programmer/langs/golang/%E6%8A%8Agolang%E5%BD%93%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%94%A8/</link><pubDate>Wed, 25 Sep 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/%E6%8A%8Agolang%E5%BD%93%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80%E7%94%A8/</guid><description>支持 # Go 软件包：
github.com/fatih/color[8] 是用于输出对应编码颜色的包。
github.com/schollz/progressbar[9] 是用于为执行时间过久的任务创建进度条的包。
github.com/jimlawless/whereami[10] 是用于捕获源代码的文件名、行号、函数等信息的包，这对于改正错误信息十分有用！
github.com/spf13/cobra[11] 是用于更轻松地创建带有输入选项和相关文档的复杂脚本的包。</description></item><item><title>常用命令</title><link>http://example.org/docs/programmer/langs/golang/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 19 Aug 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description> build # 编译个后端服务，解决有些包依赖问题
go build -ldflags &amp;#39;-w -s&amp;#39; -tags netgo -insta llsuffix netgo -o xxxxx 清理 # 清理GOPATH: go clean -modcache # 设置大磁盘的新路径 export GOPATH=/mnt/data/go/gopath</description></item><item><title>Golang进阶笔记</title><link>http://example.org/docs/programmer/langs/golang/advanced-knowledge-of-golang/</link><pubDate>Wed, 19 May 2021 19:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/advanced-knowledge-of-golang/</guid><description>Golang进阶笔记 # 性能分析 # import ( &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; ) go func() { log.Println(http.ListenAndServe(&amp;#34;localhost:6060&amp;#34;, nil)) }() 将以上代码插入程序中 启动之后执行
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30 具体使用方法可以help 如果使用top的话就可以查看方法占用了
(pprof) top Showing nodes accounting for 29.59s, 98.60% of 30.01s total Dropped 35 nodes (cum &amp;lt;= 0.15s) flat flat% sum% cum cum% 28.98s 96.57% 96.57% 28.98s 96.57% time.Now 0.24s 0.8% 97.37% 0.51s 1.70% runtime.selectgo 0.16s 0.53% 97.90% 0.16s 0.53% memeqbody 0.13s 0.43% 98.33% 0.29s 0.97% runtime.</description></item><item><title>Golang笔记</title><link>http://example.org/docs/programmer/langs/golang/note-of-golang/</link><pubDate>Tue, 15 May 2018 10:18:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/note-of-golang/</guid><description>Golang笔记 # 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html
垃圾回收 # 常见的回收算法 # 引用计数 优点：对象可以被很快回收 缺点：不太好处理循环引用 标记-清除 优点：解决了引用计数的缺点 缺点：需要 STW(Stop The World),暂时停止程序运行 分代收集(按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，段的放入新生代，不同代有不同的回收算法和回收频率) 优点：回收性能好 缺点：算法复杂 三色标记法(初始状态：白色、从根节点开始遍历，遍历到的变成灰色，遍历灰色，将灰色引用的标记灰色，遍历过的灰色对象变为黑色。循环遍历灰色对象。通过写屏障检测对象的变化，重复。收集所有白色对象(垃圾)) GPM调度和CSP模型 # CSP 模型？ # CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通 过共享内存来通信。用于描述两个独立的并发实体通过共享的通 讯 channel (管道)进行通信的并发模型。
GPM 分别是什么、分别有多少数量？ # • G（Goroutine）： 即Go协程，每个go关键字都会创建一个协 程。 • M（Machine）：工作线程，在Go中称为Machine，数量对应真 实的CPU数（真正干活的对象）。 • P（Processor）： 处理器（Go中定义的一个摡念，非CPU）， 包含运行Go代码的必要资源，用来调度 G 和 M 之间的关联关 系，其数量可通过 GOMAXPROCS() 来设置，默认为核心数。 M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队 列，P可以调度G交由M执行。
Goroutine调度策略 # • 队列轮转：P 会周期性的将G调度到M中执行，执行一段时间 后，保存上下文，将G放到队列尾部，然后从队列中再取出一个 G进行调度。除此之外，P还会周期性的查看全局队列是否有G等 待调度到M中执行。 • 系统调用：当G0即将进入系统调用时，M0将释放P，进而某个空 闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是 M的缓存池，也可能是新建的。 当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执 行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。 然后M0将进入缓存池睡眠。 !</description></item></channel></rss>