<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Ian's Blog</title><link>http://example.org/tags/linux/</link><description>Recent content in Linux on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 07 Sep 2023 20:58:56 +0000</lastBuildDate><atom:link href="http://example.org/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>k8s 配套说明</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E9%85%8D%E5%A5%97%E8%AF%B4%E6%98%8E/</link><pubDate>Thu, 07 Sep 2023 20:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E9%85%8D%E5%A5%97%E8%AF%B4%E6%98%8E/</guid><description>ctr # 如果定义了 -n 应该是namesplace 那么每个命令都得跟上
load镜像 # sudo ctr -n=k8s.io images import ${imageTarFile}
保存文件 # sudo ctr -n k8s.io images export &amp;ndash;platform=linux/amd64 hi.tar 101.32.1.4:30002/web-docker/worker:2121
切换tag # sudo ctr -n k8s.io images tag &amp;ndash;force repos.x.com/web-docker/worker:2121 101.32.1.4:30002/web-docker/worker:2121
推送镜像 # sudo ctr -n k8s.io images push -k -u admin:fat213asfdFS2W &amp;ndash;plain-http 101.32.1.4:30002/web-docker/worker:2121
拉取 # sudo ctr -n k8s.io images pull -k -u admin:fat1239ASD124W &amp;ndash;plain-http 101.32.1.4:30002/web-docker/worker:2121
Docker # [[noteOfdocker]] 好像并没有整理docker命令&amp;hellip; 后续补吧
加载镜像 # docker load -i .</description></item><item><title>k8s技术分享</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</link><pubDate>Thu, 07 Sep 2023 20:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</guid><description>k8s技术分享 # 工作负载资源 # 一、pod # 1. 概要 # 可创建管理、最小的可部署计算单元，是可以在主机上运行的容器的集合 我们的服务都在其中运行。如我们的服务是nginx，则最内层是我们的服务 nginx，运行在 container 容器当中。container (容器) 的本质是进程，而 pod 是管理这一组进程的资源 所以pod可视为一个极为轻量化、没插网线的电脑，如果所需任务无需交互，那么用pod就很合适。例如给它挂载一个文件来训练模型、生成报表，可以根据场景使用 Job 或者 CronJob 或者其它 图示关系如下 # ![[k8s-pod-insert.png]]
2. pod网络 # 当然，pod 可以管理多个 container，又因为container (容器) 的本质是进程，如果有本地网络通信需求(使用 localhost 或者 Socket 文件进行本地通信)，在这些场景中使用 pod 管理多个 container 就非常的推荐。
如下图展示了Pod网络所依赖的3个网络设备
1. eth0是节点主机上的网卡，支持该节点流量出入的设备、也是支持集群节点间IP寻址和互通的设备；
2. docker0是一个虚拟网桥，可以简单理解为一个虚拟交换机，支持该节点上的Pod之间进行IP寻址和互通的设备；
3. veth0则是Pod1的虚拟网卡，支持该Pod内容器互通和对外访问的虚拟设备；
4. docker0网桥和veth0网卡，都是linux支持和创建的虚拟网络设备；
5. pause属于特殊容器，其运行的唯一目的是为Pod建立共享的veth0网络接口
![[k8s-nginx-pod.png]]
二、deployment、StatefulSet # 1. 概要 # Deployment 使得 Pod 和 ReplicaSet 能够进行声明式更新
StatefulSet 表示一组具有一致身份的 Pod：
1. 身份定义为：</description></item><item><title>k8s学习-常用命令和配置文件</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 27 Mar 2023 10:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid><description>k8s学习 # 常用命令 # kubectl apply -f rcm_log_monut_k8s_pod.yaml kubectl get pod -A kubectl get pod -all-namespaces kubectl get node kubectl get deploy 持久卷 - PersistentVolume kubectl get persistentvolume kubectl describe persistentvolume example-pv kubectl **delete** persistentvolume example-pv 从kubectl cp -n &amp;lt;命名空间&amp;gt; -c :xxx.json xxx.json configmap / secret 存储文件内容 # sftpkey 为名称
新建 # kubectl create secret generic sftpkey --from-file=/etc/id_rsa # kubectl create -n {NAMESPACE} secret generic sftpkey --from-file=/etc/id_rsa 删除 # kubectl delete secret sftpkey</description></item><item><title>Linux</title><link>http://example.org/docs/programmer/os/noteoflinux/</link><pubDate>Fri, 08 Apr 2016 16:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/os/noteoflinux/</guid><description>Ubuntu22.04 依赖项整理 # vbox: libqt5opengl5 kate: konsole Qt5.12.12: mesa-common-dev, libgl1-mesa-dev OpenCV4.6.0: libgtk2.0-dev, pkg-config, libcanberra-gtk-module 如果没有安装这俩依赖不会影响编译，但是编译后会有功能损失，补充安装后不会修复； 如果想修复，只能安装后再编译一次； dpkg .deb # Install # sudo dpkg -i file.deb
c l r P L s # -c列出内容 -l提取包信息 -r移除一个已安装的包 -P完全清除一个已安装包 -L列出安装所有文件清单 -s显示已安装包信息 WSL # wsl问题 因为后面不太喜欢这种东西了,还是上了物理机. 所以就不粘贴过来了.
sudo apt upgrade # E: Sub-process /usr/bin/dpkg returned an error code (1)
解决 # sudu下
备份/var/lib/dpkg/info 新建/var/lib/dpkg/info 重新执行更新 合并/var/lib/dpkg/info 和 备份文件 完 说明 # 非原理性解决方案, 若解决不了, 另寻他法或者需要直击灵魂.</description></item></channel></rss>