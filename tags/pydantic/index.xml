<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>pydantic on Ian's Blog</title><link>http://example.org/tags/pydantic/</link><description>Recent content in pydantic on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="http://example.org/tags/pydantic/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 常用库</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>pydantic # 来自类 # from pydantic import BaseModel class User(BaseModel): name: str age: int class Config: from_attributes = True # 假设我们有一个普通的 Python 对象，它具有与模型字段相同的属性名 class OrdinaryObject: def __init__(self, name, age): self.name = name self.age = age # 创建一个 OrdinaryObject 实例 ordinary_object = OrdinaryObject(name=&amp;#39;Alice&amp;#39;, age=30) # 现在我们可以直接将 ordinary_object 传递给 User 模型的构造函数 user_model = User(ordinary_object) # 输出模型的字段值 print(user_model.dict()) # 输出: {&amp;#39;name&amp;#39;: &amp;#39;Alice&amp;#39;, &amp;#39;age&amp;#39;: 30} 自定义字段 # class User(BaseModel): id: int is_active: bool wx_infos: List[str] = [] class Config: arbitrary_types_allowed = True # 允许任意类型 Tuple定义问题 # from typing import List, Tuple class Task(BaseModel): launch_count_today: int launch_groups: List[Tuple[str, .</description></item></channel></rss>