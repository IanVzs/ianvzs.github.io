{"meta":{"title":"Ian's Blog","subtitle":"","description":"","author":"Ian Vzs","url":"https://ianvzs.github.io","root":"/"},"pages":[],"posts":[{"title":"Paddle","slug":"notes/paddle","date":"2022-06-08T10:58:56.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2022/06/08/notes/paddle/","link":"","permalink":"https://ianvzs.github.io/2022/06/08/notes/paddle/","excerpt":"","text":"Paddle的坑资源占用命令示例(yml中修改了train,test样本地址,使用--gpus这里只用了一个GPU,可方便修改为多卡0,1,2,3) 1python -m paddle.distributed.launch --gpus &#x27;1&#x27; tools/train.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=./pretrain_models/en_PP-OCRv3_rec_train/best_accuracy.pdparams en_PP-OCRv3_rec默认性能配置在, 单卡V100上:+——————————-+———————-+———————-+| 1 Tesla V100-SXM2… On | 00000000:00:09.0 Off | 0 || N/A 53C P0 223W / 300W | 23065MiB / 32510MiB | 100% Default || | | N/A |+——————————-+———————-+———————-+ Paddle 多卡训练You may need to install ‘nccl2’ from NVIDIA official website Traceback: 这种问题可以参看Github Issues 写在坑前头经测试，下面预训练模型下载地址和检测训练效果的脚本之所以报错是因为PaddleOCR项目主页的readme中链接的子readme是develop分支的。且这个分支是落后于当前release/2.5的，所以出现了以下不匹配的情况.切换了分支之后, 匹配度还可以接受. PaddleOCR 预训练模型 百度写文档的积极性是真的低，看来这东西用的人是真的少… 这是官方说明文档: 123456789101112131415161718cd PaddleOCR/# 下载MobileNetV3的预训练模型wget -P ./pretrain_models/ https://paddle-imagenet-models-name.bj.bcebos.com/MobileNetV3_large_x0_5_pretrained.tar# 或，下载ResNet18_vd的预训练模型wget -P ./pretrain_models/ https://paddle-imagenet-models-name.bj.bcebos.com/ResNet18_vd_pretrained.tar# 或，下载ResNet50_vd的预训练模型wget -P ./pretrain_models/ https://paddle-imagenet-models-name.bj.bcebos.com/ResNet50_vd_ssld_pretrained.tar# 解压预训练模型文件，以MobileNetV3为例tar -xf ./pretrain_models/MobileNetV3_large_x0_5_pretrained.tar ./pretrain_models/# 注：正确解压backbone预训练权重文件后，文件夹下包含众多以网络层命名的权重文件，格式如下：./pretrain_models/MobileNetV3_large_x0_5_pretrained/ └─ conv_last_bn_mean └─ conv_last_bn_offset └─ conv_last_bn_scale └─ conv_last_bn_variance └─ ...... 但是 Paddle 在1.8版本后已经不用这种格式的预训练模型了！ 2022-06-07 现在已经更新到2.3.0 所以下载下来压根不能使用1wget -P ./pretrain_models/ https://paddle-imagenet-models-name.bj.bcebos.com/dygraph/ResNet18_vd_pretrained.pdparams 增加dygraph 后缀修改为pdparams 使用训练结果检测单张图片应使用: 1python tools/infer_det.py --config=configs/det/det_res18_db_v2.0.yml -o Global.infer_img=&quot;./train_data/icdar2015/ch4_test_images/img_4.jpg&quot; Global.checkpoints=&quot;./output/ch_db_res18/latest.pdparams&quot; Global.use_gpu=false 而非官网所示的: 1python3 tools/infer_det.py -c configs/det/det_mv3_db_v1.1.yml -o Global.infer_img=&quot;./doc/imgs_en/img_10.jpg&quot; Global.checkpoints=&quot;./output/det_db/best_accuracy&quot; 否则会报错: 12345678Traceback (most recent call last): File &quot;... /PaddleOCR/tools/infer_det.py&quot;, line 133, in &lt;module&gt; config, device, logger, vdl_writer = program.preprocess() File &quot;... /PaddleOCR/tools/program.py&quot;, line 535, in preprocess FLAGS = ArgsParser().parse_args() File &quot;... /PaddleOCR/tools/program.py&quot;, line 57, in parse_args assert args.config is not None, \\AssertionError: Please specify --config=configure_file_path. 多卡和断点续传断点可能怕是不行了。。。 多卡使用: 1python -m paddle.distributed.launch --gpus &#x27;1,2&#x27; tools/train.py -c configs/det/det_res18_db_v2.0.yml -o Global.use_gpu=true Global.checkpoints=&quot;./output/ch_db_res18/latest.pdparams&quot; | tee train_det.log 会出现: 12345678910111213141516171819202122[2022/06/08 18:36:48] ppocr INFO: num_workers : 4[2022/06/08 18:36:48] ppocr INFO: shuffle : True[2022/06/08 18:36:48] ppocr INFO: profiler_options : None[2022/06/08 18:36:48] ppocr INFO: train with paddle 2.3.0 and device Place(gpu:1)server not ready, wait 3 sec to retry...not ready endpoints:[&#x27;127.0.0.1:36939&#x27;]W0608 18:36:51.403939 745832 dynamic_loader.cc:276] You may need to install &#x27;nccl2&#x27; from NVIDIA official website: https://developer.nvidia.com/nccl/nccl-downloadbefore install PaddlePaddle.Traceback (most recent call last): File &quot;tools/train.py&quot;, line 191, in &lt;module&gt; main(config, device, logger, vdl_writer) File &quot;tools/train.py&quot;, line 47, in main dist.init_parallel_env() File &quot;/data/anaconda3/lib/python3.8/site-packages/paddle/distributed/parallel.py&quot;, line 315, in init_parallel_env parallel_helper._init_parallel_ctx() File &quot;/data/anaconda3/lib/python3.8/site-packages/paddle/fluid/dygraph/parallel_helper.py&quot;, line 42, in _init_parallel_ctx __parallel_ctx__clz__.init()RuntimeError: (PreconditionNotMet) The third-party dynamic library (libnccl.so) that Paddle depends on is not configured correctly. (error code is libnccl.so: cannot open shared object file: No such file or directory) Suggestions: 1. Check if the third-party dynamic library (e.g. CUDA, CUDNN) is installed correctly and its version is matched with paddlepaddle you installed. 2. Configure third-party dynamic library environment variables as follows: - Linux: set LD_LIBRARY_PATH by `export LD_LIBRARY_PATH=...` - Windows: set PATH by `set PATH=XXX; (at /paddle/paddle/phi/backends/dynload/dynamic_loader.cc:303)","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"机器学习","slug":"note/机器学习","permalink":"https://ianvzs.github.io/categories/note/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Paddle","slug":"Paddle","permalink":"https://ianvzs.github.io/tags/Paddle/"}]},{"title":"PyPi","slug":"notes/pypi","date":"2022-03-31T07:15:14.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2022/03/31/notes/pypi/","link":"","permalink":"https://ianvzs.github.io/2022/03/31/notes/pypi/","excerpt":"","text":"示例项目py-muti-scrcpy 配置文件pyproject 工具介绍poetry 增加安装包直接修改pyproject.toml文件并不能生效, 因为还依赖于poetry.lock 可使用poetry add &#123;xxx&#125;进行添加 注意事项需要链接外网123HTTPSConnectionPool(host=&#x27;files.pythonhosted.org&#x27;, port=443): Max retries exceeded with url: /packages/17/61/32c3ab8951142e061587d957226b5683d1387fb22d95b4f69186d92616d1/typing_extensions-4.0.0-py3-none-any.whl (Caused by ProxyError(&#x27;Cannot connect to proxy.&#x27;, ConnectionResetError(54, &#x27;Connection reset by peer&#x27;)))HTTPSConnectionPool(host=&#x27;pypi.org&#x27;, port=443): Max retries exceeded with url: /pypi/colorama/0.4.4/json (Caused by ProxyError(&#x27;Cannot connect to proxy.&#x27;, ConnectionResetError(54, &#x27;Connection reset by peer&#x27;))) 需要安装ssl123SSLError HTTPSConnectionPool(host=&#x27;pypi.org&#x27;, port=443): Max retries exceeded with url: /pypi/importlib-metadata/4.2.0/json (Caused by SSLError(SSLEOFError(8, &#x27;EOF occurred in violation of protocol (_ssl.c:1129)&#x27;))) 该问题可通过安装openssl解决: 123pip install ndg-httpsclientpip install pyopensslpip install pyasn1 CI WorkFlowsworkflows pypi token 注册pypi账号 进入账号管理中心这里 找见API tokens创建新token或者使用旧的，随个人 在GitHub项目配置中找到Action secrets管理这里 Repository secrets 中加入PYPI_TOKEN 因为WorkFlows中使用的是PYPI_TOKEN 见POETRY_PYPI_TOKEN_PYPI: $","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"pip","slug":"note/pip","permalink":"https://ianvzs.github.io/categories/note/pip/"},{"name":"pypi","slug":"note/pip/pypi","permalink":"https://ianvzs.github.io/categories/note/pip/pypi/"}],"tags":[]},{"title":"Tensorflow","slug":"tips/tensorflow","date":"2022-03-30T09:23:23.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2022/03/30/tips/tensorflow/","link":"","permalink":"https://ianvzs.github.io/2022/03/30/tips/tensorflow/","excerpt":"","text":"v2兼容v1 API12import tensorflow.compat.v1 as tftf.disable_v2_behavior()","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"版本兼容","slug":"tip/版本兼容","permalink":"https://ianvzs.github.io/categories/tip/%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9/"}],"tags":[]},{"title":"python打包","slug":"notes/pyinstaller","date":"2022-03-18T10:15:14.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2022/03/18/notes/pyinstaller/","link":"","permalink":"https://ianvzs.github.io/2022/03/18/notes/pyinstaller/","excerpt":"","text":"打包pyinstaller 123pip install pyinstallerpyinstaller /path/to/yourscript.pypyinstaller -key yourpasswd -F /path/to/yourscript.py 解包解包工具pyinstxtractor.py hex编辑器010Editor下载地址 步骤将pyinstxtractor.py与exe放置在一个文件夹内，打开cmd，输入下列指令生成一个文件夹 1python pyinstxtractor.py xxx.exe 使用010Editor打开文件夹中的main和struct，将struct中E3前面的字节复制粘贴到010Editor的E3前修改main文件后缀为main.pyc使用在线工具https://tool.lu/pyc/ 将main.pyc反编译为py文件 应对增加key之后的解包暂无 安装程序 先将程序打包exe(以多文件模式, 但文件运行起来每次都需要解压再运行很慢，大文件的话多次运行还会挤压C盘空间) 将打包好的目录压缩打包zip 编写本质为mv lnk的脚本 把脚本打包成exe 执行脚本exe具体代码可以看这里","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"pyinstaller","slug":"note/pyinstaller","permalink":"https://ianvzs.github.io/categories/note/pyinstaller/"},{"name":"打包","slug":"note/pyinstaller/打包","permalink":"https://ianvzs.github.io/categories/note/pyinstaller/%E6%89%93%E5%8C%85/"}],"tags":[]},{"title":"Demo Test项目中的一些东西","slug":"notes/demo_test_some","date":"2022-02-10T09:45:00.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2022/02/10/notes/demo_test_some/","link":"","permalink":"https://ianvzs.github.io/2022/02/10/notes/demo_test_some/","excerpt":"","text":"yolov5使用自己的素材进行目标识别训练 之前使用个位数样本识别Vmon结果败的一塌糊涂 现在用来检测卡片倒是得心应手 9个训练卡片,准确率可以到50多,自我感觉还行 使用方法: 在此","categories":[{"name":"demo_test","slug":"demo-test","permalink":"https://ianvzs.github.io/categories/demo-test/"},{"name":"code","slug":"demo-test/code","permalink":"https://ianvzs.github.io/categories/demo-test/code/"}],"tags":[{"name":"demo_test","slug":"demo-test","permalink":"https://ianvzs.github.io/tags/demo-test/"}]},{"title":"Qt/PySide","slug":"tips/qt","date":"2022-01-18T06:15:23.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2022/01/18/tips/qt/","link":"","permalink":"https://ianvzs.github.io/2022/01/18/tips/qt/","excerpt":"","text":"绘制界面和使用安装Qt本体后可以使用Design绘制图形化界面.而后保存为xxx.ui文件. 转换为py 注意版本1pyside6-uic xxx.ui -o ui_xxx.py 不过信号槽就不要在Design中去标了, 放在py中手动创建和管理目前看来更为直观方便.","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"qt","slug":"tip/qt","permalink":"https://ianvzs.github.io/categories/tip/qt/"},{"name":"pyside","slug":"tip/qt/pyside","permalink":"https://ianvzs.github.io/categories/tip/qt/pyside/"}],"tags":[]},{"title":"安装问题","slug":"tips/install_some","date":"2022-01-15T08:24:41.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2022/01/15/tips/install_some/","link":"","permalink":"https://ianvzs.github.io/2022/01/15/tips/install_some/","excerpt":"","text":"记录一些安装问题Debian 使用 apt-add-repository(ppa)12sudo apt updatesudo apt install software-properties-common FreeBSD桌面 换源 pkg install xorg xfce echo ‘dbus_enable=”YES”‘ &gt;&gt; /etc/rc.conf echo “/usr/local/etc/xdg/xfce4/xinitrc” &gt; ~/.xinitrc startx登录界面 pkg install slim slim-themes echo ‘slim_enable=”YES”‘ &gt;&gt; /etc/rc.confvbox(没测试) pkg install virtualbox-ose-additions 向/etc/rc.conf写入12vboxguest_enable=&quot;YES&quot;vboxservice_enable=&quot;YES&quot; 仅供参考看这里 因为vbox显卡太弱安装了vmware后就一直没用回过vbox,我还没测试过vmware pkg install open-vm-tools xf86-video-vmware xf86-input-vmmouse 继续向/etc/rc.conf中写入1234567hald_enable=&quot;YES&quot;moused_enable=&quot;YES&quot;# vmware_guest_vmblock_enable=&quot;YES&quot;# vmware_guest_vmhgfs_enable=&quot;YES&quot;# vmware_guest_vmmemctl_enable=&quot;YES&quot;# vmware_guest_vmxnet_enable=&quot;YES&quot;# vmware_guest_enable=&quot;YES&quot; 下面注释掉的是因为在测试中如果打开的话会有各种问题….尤其鼠标其他可见这里参考仅供参考, 这里面的东西很多都是有问题的.Clash(樹莓派4 cli版) 下載對應版本地址 注意不要選擇1.9.0版本,我用的1.8.0,9多人反映(以及我)有問題 我是樹莓派4 用的armv8 樹莓派3 據說用armv7 解壓給運行權限 從無論某處拿到配置文件 大多給訂閱地址, 但這裏使用需要我們手動下載好 配置systemd或其他(手動啓動的話注意需要root,或者給相應用戶配置端口權限)123456789[Unit]Description=clash daemon[Service]Type=simpleUser=rootExecStart=/home/pi/apps/clash-linux-armv8-v1.8.0/clash-linux-armv8-v1.8.0 -f /home/pi/.config/clash/config.yamlRestart=on-failure[Install]WantedBy=multi-user.target 啓用123sudo systemctl enable clashsudo systemctl start clashsudo systemctl status clash Windows下wsl2 安装 npm &amp;&amp; nodejs摘抄自微软说明文档 安装nvm (Node 版本管理器)国内网可能有问题, 下载下保存直接bash install.sh就可安装.1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash command -v nvm验证是否安装成功,它会自行添加.bashrc需重启bash nvm ls查看Node版本 nvm install --lts即可安装lts版, nvm install node安装最新版 会安装这么多东西1234567891011121314-&gt; v16.13.2default -&gt; lts/* (-&gt; v16.13.2)iojs -&gt; N/A (default)unstable -&gt; N/A (default)node -&gt; stable (-&gt; v16.13.2) (default)stable -&gt; 16.13 (-&gt; v16.13.2) (default)lts/* -&gt; lts/gallium (-&gt; v16.13.2)lts/argon -&gt; v4.9.1 (-&gt; N/A)lts/boron -&gt; v6.17.1 (-&gt; N/A)lts/carbon -&gt; v8.17.0 (-&gt; N/A)lts/dubnium -&gt; v10.24.1 (-&gt; N/A)lts/erbium -&gt; v12.22.9 (-&gt; N/A)lts/fermium -&gt; v14.18.3 (-&gt; N/A)lts/gallium -&gt; v16.13.2 可以了 或者官网下载不过在wsl2里node好使唤,npm无效(只有0K)… Dgraph问题见: 这里","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"install","slug":"tip/install","permalink":"https://ianvzs.github.io/categories/tip/install/"}],"tags":[{"name":"install","slug":"install","permalink":"https://ianvzs.github.io/tags/install/"},{"name":"npm","slug":"npm","permalink":"https://ianvzs.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://ianvzs.github.io/tags/nodejs/"}]},{"title":"Dgraph使用小记","slug":"notes/dgraph","date":"2022-01-10T09:00:00.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2022/01/10/notes/dgraph/","link":"","permalink":"https://ianvzs.github.io/2022/01/10/notes/dgraph/","excerpt":"","text":"概念 以下参考自: 这里Console Mutate: 突变, 结构/数据变化的时候用 Query: 查询, Emmmm查询的时候用 所以看来没有getset了????Schema管理字段(Predicate, Type, list,lang,index等) 突变set内容较多, 下面单独罗列 delete根据UID 删除指定predicate_name 12345&#123; delete &#123; &lt;UID&gt; &lt;predicate_name&gt; * . &#125;&#125; set创建直接json给出结构和数据,即可完成创建.只不过如果有用到@lang时就需要去Schema里更新一下字段 - 类型 ???? (Schema-Type)的支持项 12345678910111213141516171819&#123; &quot;set&quot;: [ &#123; &quot;food_name&quot;: &quot;Sushi&quot;, &quot;review&quot;: [ &#123; &quot;comment&quot;: &quot;Tastes very good&quot;, &quot;comment@jp&quot;: &quot;とても美味しい&quot;, &quot;comment@ru&quot;: &quot;очень вкусно&quot; &#125; ], &quot;origin&quot;: [ &#123; &quot;country&quot;: &quot;Japan&quot; &#125; ] &#125; ]&#125; 更新使用和创建差不多,不过目前我已知的更新只能用UID否则都会直接创建一个相同内容的新数据出来 12345678&#123; &quot;set&quot;:[ &#123; &quot;uid&quot;: &quot;&#123;UID&#125;&quot;, &quot;age&quot;: 41 &#125; ]&#125; 查询has直接json 返回值也会按照这个格式给出,层级深浅可随意自定 123456&#123; good_name(func: has(food_name)) &#123; food_name review &#125;&#125; 12345678&#123; good_name(func: has(food_name)) &#123; food_name review&#123; comment &#125; &#125;&#125; uid除了上述的has还有很多查询内置方法,不过深度的话除了手动罗列也可通过recurse - depth来确定,写多了也不会多返回 1234567&#123; find_follower(func: uid(&#123;UID&#125;)) @recurse(depth: 4) &#123; name age follows &#125;&#125; eq&amp;索引需要设置hash索引, 如下为查询Sushi的review*为统配 可指定lang, 什么都不加默认无指定lang的数据 12345678&#123; food_review(func: eq(food_name,&quot;Sushi&quot;)) &#123; food_name review &#123; comment@* &#125; &#125;&#125; &lt;&gt;= func 说明 eq 等于 lt 小于 le 小于等于 gt 大于 ge 大于等于 123456789101112&#123; authors_and_ratings(func: ge(rating, 4.0)) &#123; uid author_name rating published &#123; title content dislikes &#125; &#125;&#125; 索引 hash 可等查询(eq), 但不支持字符串比较大小 exact 唯一允许字符串比较(ge,gt,le,lt)查询的索引(很牛逼的样子) term 带有任意一个(anyofterms), 同时拥有(allofterms), 相等(eq)12345678910// 多个关键字(术语)使用空格隔开即可.// 查询大小写不敏感// dgraph 优化机制是将全文转换为token 查询使用查询token 所以多个查询关键词会进行重排列 获取唯一token后去全文中对比. 由此查询词的顺序无关紧要// 也就是说anyofterms&amp;allofterms的 `1 2 3 == 3 2 1 == 2 1 3` (结果相同是理所当然的, 消耗和内部逻辑也是相同)&#123; find_tweets(func: anyofterms(tweet, &quot;Go GraphQL&quot;)) &#123; tweet &#125;&#125;","categories":[{"name":"Dgraph","slug":"Dgraph","permalink":"https://ianvzs.github.io/categories/Dgraph/"},{"name":"图数据库","slug":"Dgraph/图数据库","permalink":"https://ianvzs.github.io/categories/Dgraph/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"notes Of docker","slug":"notes/noteOfdocker","date":"2021-12-16T08:00:00.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2021/12/16/notes/noteOfdocker/","link":"","permalink":"https://ianvzs.github.io/2021/12/16/notes/noteOfdocker/","excerpt":"","text":"Docker 教程手册好用的使用教程 Install略过~ 😁 常见问题和模板Docker Mysql编码123456789101112131415161718192021222324version: &quot;2.2&quot;services: redis: image: &quot;redis&quot; # ports: # - 6379:6379 command: redis-server --appendonly yes #一个容器启动时要运行的命令 restart: always # 自动重启 myserver: image: mainName/myserver restart: always # 自动重启 mainServer: image: mainName/mainServer # container_name: mainServerv1.0.0 depends_on: - redis ports: - 9001:9001 restart: always volumes: - &quot;./logs:/src/build/logs&quot; links: - redis - myserver mysql 编码问题|单条: docker run --name predix_mysql -e MYSQL_ROOT_PASSWORD=predix123predix -p 33061:3306 -e LANG=C.UTF-8 -d mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci 时间修改123456789101112131415161718FROM alpine:3.14RUN apk add -U tzdata &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezoneENV TZ=Asia/Shanghai \\ GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 \\ PROGRAM_ENV=proWORKDIR /src/build# 复制构建应用程序所需的代码COPY ./build .EXPOSE 8088CMD [&quot;./main&quot;] bash进入某App内1docker exec -it webserver bash webserver 为APP名称 SwarmDocker ComposeDocker Machine: Mac、Windows区别预先安装。 Linux直接安装 Win10 Hyper-V发布镜像镜像充当已部署容器，填写必要信息：username、repo、tagdockers-compose.yml 副本 其实以上在官方教程有很好说明在这里，但毕竟高级应用，暂且记下。 创建虚拟机来试验一下12$ docker-machine create --driver virtualbox myvm1$ docker-machine create --driver virtualbox myvm2 第一个管理节点：docker swarm init，第二个工作节点`docker swarm join`` should like this show:12345678$ docker-machine ssh myvm1 &quot;docker swarm init&quot;Swarm initialized: current node &lt;node ID&gt; is now a manager.To add a worker to this swarm, run the following command: docker swarm join \\ --token &lt;token&gt; \\ &lt;ip&gt;:&lt;port&gt; 通过运行 docker-machine ls 来复制 myvm1 的 IP 地址，然后使用 该 IP 地址并通过 –advertise-addr 指定端口 2377（用于 swarm join 的端口）， 以便再次运行 docker swarm init 命令。例如： 1docker-machine ssh myvm1 &quot;docker swarm init --advertise-addr 192.168.99.100:2377&quot; 复制此命令，然后通过 docker-machine ssh 将其发送给 myvm2，从而让 myvm2 加入12345$ docker-machine ssh myvm2 &quot;docker swarm join \\--token &lt;token&gt; \\&lt;ip&gt;:&lt;port&gt;&quot;This node joined a swarm as a worker. 至此， 创建swarm完成。连接使用ssh连接docker-machine ssh myvm1,运行docker node ls查看此中节点。 Mybe like this.1234docker@myvm1:~$ docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUSbrtu9urxwfd5j0zrmkubhpkbd myvm2 Ready Active rihwohkh3ph38fhillhhb84sk * myvm1 Ready Active Leader mybe not you are ture. 😂 之后，其余东西z有用到再去官网查看吧。 记录与否，取决于俺。","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"docker","slug":"note/docker","permalink":"https://ianvzs.github.io/categories/note/docker/"},{"name":"learning","slug":"note/docker/learning","permalink":"https://ianvzs.github.io/categories/note/docker/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"docker","slug":"docker","permalink":"https://ianvzs.github.io/tags/docker/"}]},{"title":"Dgraph","slug":"tips/dgraph","date":"2021-12-08T10:30:23.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2021/12/08/tips/dgraph/","link":"","permalink":"https://ianvzs.github.io/2021/12/08/tips/dgraph/","excerpt":"","text":"问题在新手村的时候使用dgraph/standalone 但此时(2021-12-8 18:30:23)文档使用的版本为dgraph/standalone:v21.03.2但是这个版本的Ratel UI不工作…. 导致hello 不了 world很是难受 结果换了dgraph/standalone:v20.11.3好了诶. 12sudo docker run --rm -it -p &quot;8080:8080&quot; -p &quot;9080:9080&quot; -p &quot;8000:8000&quot; -v ~/dgraph:/dgraph &quot;dgraph/standalone:v20.11.3&quot;http://127.0.0.1:8000","categories":[{"name":"Dgraph","slug":"Dgraph","permalink":"https://ianvzs.github.io/categories/Dgraph/"},{"name":"图数据库","slug":"Dgraph/图数据库","permalink":"https://ianvzs.github.io/categories/Dgraph/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"gRpc使用小记","slug":"tips/tipsOfgRpc","date":"2021-05-24T02:30:41.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2021/05/24/tips/tipsOfgRpc/","link":"","permalink":"https://ianvzs.github.io/2021/05/24/tips/tipsOfgRpc/","excerpt":"","text":"gRpc HelloWorldhelloWorldquickstart 123protoc --go_out=. --go_opt=paths=source_relative \\ --go-grpc_out=. --go-grpc_opt=paths=source_relative \\ helloworld/helloworld.proto MacOS下问题 原本protobuf中没有mac的gen-go和gen-go-grpc,所以需要额外运行安装. 除了使用brew用go get应该也是可以的,就是有路径问题,所以还是使用brew吧123brew install protobufbrew install protoc-gen-gobrew install protoc-gen-go-grpc","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"problem","slug":"tip/problem","permalink":"https://ianvzs.github.io/categories/tip/problem/"},{"name":"gRpc","slug":"tip/problem/gRpc","permalink":"https://ianvzs.github.io/categories/tip/problem/gRpc/"}],"tags":[{"name":"win","slug":"win","permalink":"https://ianvzs.github.io/tags/win/"},{"name":"rpc","slug":"rpc","permalink":"https://ianvzs.github.io/tags/rpc/"}]},{"title":"解决问题","slug":"tips/tipsOfProblems","date":"2021-05-23T02:30:41.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2021/05/23/tips/tipsOfProblems/","link":"","permalink":"https://ianvzs.github.io/2021/05/23/tips/tipsOfProblems/","excerpt":"","text":"各种一键问题解决方案Windows下Git问题 Linux没啥问题,但在Win下报checkout失败,路径问题1git config core.protectNTFS false","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"problem","slug":"tip/problem","permalink":"https://ianvzs.github.io/categories/tip/problem/"}],"tags":[{"name":"win","slug":"win","permalink":"https://ianvzs.github.io/tags/win/"},{"name":"git","slug":"git","permalink":"https://ianvzs.github.io/tags/git/"}]},{"title":"Golang笔记","slug":"notes/noteOfgoExp","date":"2021-05-19T11:00:00.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2021/05/19/notes/noteOfgoExp/","link":"","permalink":"https://ianvzs.github.io/2021/05/19/notes/noteOfgoExp/","excerpt":"","text":"Go golang笔记 路径问题test_test.go123456789package mainimport &quot;testing&quot;func TestHelloWorld(t *testing.T) &#123; // t.Fatal(&quot;not implemented&quot;) path := getCurrentPath() t.Log(&quot;getCurrentPath: &quot;, path)&#125; test.go12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;os&quot; &quot;path&quot; &quot;path/filepath&quot; &quot;runtime&quot; &quot;strings&quot;)func main() &#123; fmt.Println(&quot;getTmpDir（当前系统临时目录） = &quot;, getTmpDir()) fmt.Println(&quot;getCurrentAbPathByExecutable（仅支持go build） = &quot;, getCurrentAbPathByExecutable()) fmt.Println(&quot;getCurrentAbPathByCaller（仅支持go run） = &quot;, getCurrentAbPathByCaller()) fmt.Println(&quot;getCurrentAbPath（最终方案-全兼容） = &quot;, getCurrentAbPath()) fmt.Println(&quot;getCurrentPath（runtime.Caller1） = &quot;, getCurrentPath())&#125;// 最终方案-全兼容func getCurrentAbPath() string &#123; dir := getCurrentAbPathByExecutable() if strings.Contains(dir, getTmpDir()) &#123; return getCurrentAbPathByCaller() &#125; return dir&#125;func getCurrentPath() string &#123; _, filename, _, _ := runtime.Caller(1) return path.Dir(filename)&#125;// 获取系统临时目录，兼容go runfunc getTmpDir() string &#123; dir := os.Getenv(&quot;TEMP&quot;) if dir == &quot;&quot; &#123; dir = os.Getenv(&quot;TMP&quot;) &#125; res, _ := filepath.EvalSymlinks(dir) return res&#125;// 获取当前执行文件绝对路径func getCurrentAbPathByExecutable() string &#123; exePath, err := os.Executable() if err != nil &#123; log.Fatal(err) &#125; res, _ := filepath.EvalSymlinks(filepath.Dir(exePath)) return res&#125;// 获取当前执行文件绝对路径（go run）func getCurrentAbPathByCaller() string &#123; var abPath string _, filename, _, ok := runtime.Caller(0) if ok &#123; abPath = path.Dir(filename) &#125; return abPath&#125; 输出1234567891011121314151617181920ian@ianDebian:~$ ./testgetTmpDir（当前系统临时目录） = .getCurrentAbPathByExecutable（仅支持go build） = /home/iangetCurrentAbPathByCaller（仅支持go run） = /home/iangetCurrentAbPath（最终方案-全兼容） = /home/iangetCurrentPath（runtime.Caller1） = /home/ianian@ianDebian:~$ian@ianDebian:~$ go run test.gogetTmpDir（当前系统临时目录） = .getCurrentAbPathByExecutable（仅支持go build） = /tmp/go-build3048077768/b001/exegetCurrentAbPathByCaller（仅支持go run） = /home/iangetCurrentAbPath（最终方案-全兼容） = /tmp/go-build3048077768/b001/exegetCurrentPath（runtime.Caller1） = /home/ianian@ianDebian:~$ian@ianDebian:~$ go test test_test.go test.go -v=== RUN TestHelloWorld test_test.go:8: getCurrentPath: /home/ian--- PASS: TestHelloWorld (0.00s)PASSok command-line-arguments 0.002s Docker问题Docker Mysql编码123456789101112131415161718192021222324version: &quot;2.2&quot;services: redis: image: &quot;redis&quot; # ports: # - 6379:6379 command: redis-server --appendonly yes #一个容器启动时要运行的命令 restart: always # 自动重启 myserver: image: mainName/myserver restart: always # 自动重启 mainServer: image: mainName/mainServer # container_name: mainServerv1.0.0 depends_on: - redis ports: - 9001:9001 restart: always volumes: - &quot;./logs:/src/build/logs&quot; links: - redis - myserver mysql 编码问题|单条: docker run --name predix_mysql -e MYSQL_ROOT_PASSWORD=predix123predix -p 33061:3306 -e LANG=C.UTF-8 -d mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_general_ci 时间修改123456789101112131415161718FROM alpine:3.14RUN apk add -U tzdata &amp;&amp; cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezoneENV TZ=Asia/Shanghai \\ GO111MODULE=on \\ CGO_ENABLED=0 \\ GOOS=linux \\ GOARCH=amd64 \\ PROGRAM_ENV=proWORKDIR /src/build# 复制构建应用程序所需的代码COPY ./build .EXPOSE 8088CMD [&quot;./main&quot;] Golang 私有仓库xxx替换为具体地址 1export GOPRIVATE=github.com/xxx/xxx 修改~/.gitconfig让go get始终通过ssh而非http 1234[url &quot;git@github.com:&quot;] insteadOf = https://github.com/[url &quot;git@gitlab.com:&quot;] insteadOf = https://gitlab.com/ -和_不同的分隔符引发的包导入错误适用于Github仓库名为xxxxx-xxxxx但包名为xxxxx_xxxxx, 因为go mod 不支持-分隔. 123456module example.comgo 1.16replace github.com/xxx-xx/xxxxx_xxxxx =&gt; github.com/xxx-xx/xxxxx-xxxxx v0.0.1 // indirectrequire github.com/xxx-xx/xxxxx_xxxxx v0.0.1 非硬性结束服务http.Server.Shutdownhttp.Server结构体有一个终止服务的方法Shutdown 首先关闭所有开启的监听器 关闭所有闲置连接 等待活跃的连接均闲置了才终止服务长链接对诸如WebSocket等的长连接，Shutdown不会尝试关闭也不会等待这些连接。若需要，需调用者分开额外处理（诸如通知诸长连接或等待它们关闭，使用RegisterOnShutdown注册终止通知函数） signal.Notify可指定信号类型/all incoming signals will be relayed to c 综上Demo112345678910111213141516171819202122232425262728293031 srv := http.Server&#123; Addr: *addr, Handler: handler, &#125; // make sure idle connections returned processed := make(chan struct&#123;&#125;) go func() &#123; c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) &lt;-c ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second) defer cancel() if err := srv.Shutdown(ctx); nil != err &#123; log.Fatalf(&quot;server shutdown failed, err: %v\\n&quot;, err) &#125; log.Println(&quot;server gracefully shutdown&quot;) close(processed) &#125;() // serve err := srv.ListenAndServe() if http.ErrServerClosed != err &#123; log.Fatalf(&quot;server not gracefully shutdown, err :%v\\n&quot;, err) &#125; // waiting for goroutine above processed &lt;-processed&#125; Demo21234567891011121314151617181920212223242526272829303132333435func main() &#123; c := make(chan os.Signal) // 监听信号 signal.Notify(c, syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGUSR1, syscall.SIGUSR2) go func() &#123; for s := range c &#123; switch s &#123; case syscall.SIGHUP, syscall.SIGINT, syscall.SIGTERM: fmt.Println(&quot;退出:&quot;, s) ExitFunc() case syscall.SIGUSR1: fmt.Println(&quot;usr1&quot;, s) case syscall.SIGUSR2: fmt.Println(&quot;usr2&quot;, s) default: fmt.Println(&quot;其他信号:&quot;, s) &#125; &#125; &#125;() fmt.Println(&quot;启动了程序&quot;) sum := 0 for &#123; sum++ fmt.Println(&quot;休眠了:&quot;, sum, &quot;秒&quot;) time.Sleep(1 * time.Second) &#125;&#125;func ExitFunc() &#123; fmt.Println(&quot;开始退出...&quot;) fmt.Println(&quot;执行清理...&quot;) fmt.Println(&quot;结束退出...&quot;) os.Exit(0)&#125; Demo312345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;log&quot; &quot;io&quot; &quot;time&quot; &quot;net/http&quot;)func startHttpServer() *http.Server &#123; srv := &amp;http.Server&#123;Addr: &quot;:8080&quot;&#125; http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, &quot;hello world\\n&quot;) &#125;) go func() &#123; if err := srv.ListenAndServe(); err != nil &#123; // cannot panic, because this probably is an intentional close log.Printf(&quot;Httpserver: ListenAndServe() error: %s&quot;, err) &#125; &#125;() // returning reference so caller can call Shutdown() return srv&#125;func main() &#123; log.Printf(&quot;main: starting HTTP server&quot;) srv := startHttpServer() log.Printf(&quot;main: serving for 10 seconds&quot;) time.Sleep(10 * time.Second) log.Printf(&quot;main: stopping HTTP server&quot;) // now close the server gracefully (&quot;shutdown&quot;) // timeout could be given instead of nil as a https://golang.org/pkg/context/ if err := srv.Shutdown(nil); err != nil &#123; panic(err) // failure/timeout shutting down the server gracefully &#125; log.Printf(&quot;main: done. exiting&quot;)&#125;","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"golang","slug":"note/golang","permalink":"https://ianvzs.github.io/categories/note/golang/"},{"name":"expansion","slug":"note/golang/expansion","permalink":"https://ianvzs.github.io/categories/note/golang/expansion/"}],"tags":[{"name":"golang","slug":"golang","permalink":"https://ianvzs.github.io/tags/golang/"},{"name":"expansion","slug":"expansion","permalink":"https://ianvzs.github.io/tags/expansion/"}]},{"title":"数据格式笔记","slug":"notes/noteOfFmtData","date":"2021-05-10T09:05:00.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2021/05/10/notes/noteOfFmtData/","link":"","permalink":"https://ianvzs.github.io/2021/05/10/notes/noteOfFmtData/","excerpt":"","text":"单向链表实现和反转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071# 单向链表实现和反转&quot;&quot;&quot;# 当前值, 下一个值# 循环# 将当前值赋值为下一个的值, 下一个节点值为当前节点值# 当前节点next赋&quot;&quot;&quot;class A: def __init__(self, v): self.v = v self.next = None class LA: def __init__(self): self.head = None def add(self, v): node = A(v) node.next = self.head self.head = node def print(self): cur = self.head while cur and cur.v != None: print(f&quot;linkdata node v: &#123;cur.v&#125;&quot;) cur = cur.next def revert(self, node: A=None, head=None): if not head: cache = self.head.next else: cache = node.next if cache: pass # print(f&quot;cache: &#123;cache.v&#125;&quot;) else: self.head = node self.head.next = head return if head == None: node = self.head node.next = None self.revert(cache, node) else: node.next = head self.revert(cache, node)if __name__ == &quot;__main__&quot;: # 1234 # 234 ldata = LA() for i in (1, 2, 3, 4): ldata.add(i) ldata.print() print(&quot;---&quot;*10) ldata.revert() ldata.print() &quot;&quot;&quot;&gt;&gt;&gt;运行输出:linkdata node v: 4linkdata node v: 3linkdata node v: 2linkdata node v: 1------------------------------linkdata node v: 1linkdata node v: 2linkdata node v: 3linkdata node v: 4&quot;&quot;&quot; 其他","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"数据格式","slug":"note/数据格式","permalink":"https://ianvzs.github.io/categories/note/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"},{"name":"test","slug":"note/数据格式/test","permalink":"https://ianvzs.github.io/categories/note/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/test/"}],"tags":[{"name":"数据格式","slug":"数据格式","permalink":"https://ianvzs.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"}]},{"title":"UE4 笔记","slug":"notes/noteOfUE4","date":"2021-05-10T04:13:26.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2021/05/10/notes/noteOfUE4/","link":"","permalink":"https://ianvzs.github.io/2021/05/10/notes/noteOfUE4/","excerpt":"","text":"UE4 笔记 手机 路径必须不能用汉字, 一律全英文(神奇…以前习惯就是全英,以为这问题是上世纪的了,测试时不知怎么就把顺手的英文换成中文了,结果就莫名中枪了) java8 (ue4.26.2, 之前4.25也是, 反正就找个稳定版java一直使吧, 这语言太amazing了.) 虽然对java版本有一定要求, 不过按照我这次的测试和使用, 觉得折腾那么久完全是汉字项目名不支持…所以java版本要求应该不是很严重 动画事件图表&amp;动画图表 事件图表: 收集动画-&gt;存储在变量中 动画图表: 驱动所有动作 事件图表isValid蓝图不知道被哪个实例持有(通用) 朝向主角本地坐标X轴正方向表正前方 GetVelocity RotationFromXVector GetControlRotaion 2,3求Delta. 输出 速度 方向 总步骤 向量长度获取Speed 向量方向-控制器方向获取Direction 以上2保存为变量, 交由动画图表 动画图表Params-Blend-Result: 获取速度,方向(看情况可多可少) 将1输入动画混合空间 输出姿势 State Machine在以上一组动作中加入状态细分 State Machine - State1-(rule)-State2…StateN State - (Params-Blend-Result) 生效 角色 网格体(骨骼网格体) 动画-动画类-动画蓝图","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"ue4","slug":"note/ue4","permalink":"https://ianvzs.github.io/categories/note/ue4/"},{"name":"learning","slug":"note/ue4/learning","permalink":"https://ianvzs.github.io/categories/note/ue4/learning/"}],"tags":[{"name":"ue4","slug":"ue4","permalink":"https://ianvzs.github.io/tags/ue4/"},{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"}]},{"title":"Nginx高可用","slug":"tips/tipsOfweb","date":"2021-05-09T01:56:41.000Z","updated":"2022-06-15T07:32:39.336Z","comments":true,"path":"2021/05/09/tips/tipsOfweb/","link":"","permalink":"https://ianvzs.github.io/2021/05/09/tips/tipsOfweb/","excerpt":"","text":"Keepalived+Nginx实现高可用 Nginx 关键字 IO多路复用epoll(IO复用) 轻量,插件: Nginx仅保留了HTTP CPU亲和: 每个worker进程固定在一个CPU Nginx配置代理 动静分离动态页面和静态页面交给不同的服务器来解析 负载均衡12345678910111213upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125;server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; 机制 默认: 轮询, 单机卡顿, 影响分配在这台服务器下的用户 默认: 权重轮询, 宕机Nginx会自动剔除出队列, ip_hash-来源IP分配分配给同个服务器 fair: 根据相应时间均衡分配, 默认不支持. 需安装upstream_fair, url_hash类ip_hash同样需要安装Nginx的hash软件包. Keepalived 配置粘贴自: 这里 概览 VIP IP 主机名 Nginx端口 默认主从 192.168.50.130 192.168.50.133 liuyazhuang133 88 MASTER 192.168.50.130 192.168.50.134 liuyazhuang134 88 BACKUP 主机器配置1vi /etc/keepalived/keepalived.conf 12345678910111213141516171819202122232425262728293031323334# 主要global_defs &#123; ## keepalived 自带的邮件提醒需要开启 sendmail 服务。 建议用独立的监控或第三方 SMTP router_id liuyazhuang133 ## 标识本节点的字条串，通常为 hostname&#125; ## keepalived 会定时执行脚本并对脚本执行的结果进行分析，动态调整 vrrp_instance 的优先级。如果脚本执行结果为 0，并且 weight 配置的值大于 0，则优先级相应的增加。如果脚本执行结果非 0，并且 weight配置的值小于 0，则优先级相应的减少。其他情况，维持原本配置的优先级，即配置文件中 priority 对应的值。vrrp_script chk_nginx &#123; script &quot;/etc/keepalived/nginx_check.sh&quot; ## 检测 nginx 状态的脚本路径 interval 2 ## 检测时间间隔 weight -20 ## 如果条件成立，权重-20&#125;## 定义虚拟路由， VI_1 为虚拟路由的标示符，自己定义名称vrrp_instance VI_1 &#123; state MASTER ## 主节点为 MASTER， 对应的备份节点为 BACKUP interface eth0 ## 绑定虚拟 IP 的网络接口，与本机 IP 地址所在的网络接口相同， 我的是 eth0 virtual_router_id 33 ## 虚拟路由的 ID 号， 两个节点设置必须一样， 可选 IP 最后一段使用, 相同的 VRID 为一个组，他将决定多播的 MAC 地址 mcast_src_ip 192.168.50.133 ## 本机 IP 地址 priority 100 ## 节点优先级， 值范围 0-254， MASTER 要比 BACKUP 高 nopreempt ## 优先级高的设置 nopreempt 解决异常恢复后再次抢占的问题 advert_int 1 ## 组播信息发送间隔，两个节点设置必须一样， 默认 1s ## 设置验证信息，两个节点必须一致 authentication &#123; auth_type PASS auth_pass 1111 ## 真实生产，按需求对应该过来 &#125; ## 将 track_script 块加入 instance 配置块 track_script &#123; chk_nginx ## 执行 Nginx 监控的服务 &#125; # # 虚拟 IP 池, 两个节点设置必须一样 virtual_ipaddress &#123; 192.168.50.130 ## 虚拟 ip，可以定义多个 &#125;&#125; 备份机配置1vi /etc/keepalived/keepalived.conf 12345678910111213141516171819202122232425262728# 备份! Configuration File for keepalivedglobal_defs &#123; router_id liuyazhuang134&#125;vrrp_script chk_nginx &#123; script &quot;/etc/keepalived/nginx_check.sh&quot; interval 2 weight -20&#125;vrrp_instance VI_1 &#123; state BACKUP interface eth1 virtual_router_id 33 mcast_src_ip 192.168.50.134 priority 90 advert_int 1 authentication &#123; auth_type PASS auth_pass 1111 &#125; track_script &#123; chk_nginx &#125; virtual_ipaddress &#123; 192.168.50.130 &#125;&#125; Nginx 运维命令123456789101112131415161718192021222324252627# 快速关闭Nginx，可能不保存相关信息，并迅速终止web服务nginx -s stop# 平稳关闭Nginx，保存相关信息，有安排的结束web服务nginx -s quit# 因改变了Nginx相关配置，需要重新加载配置而重载nginx -s reload# 重新打开日志文件nginx -s reopen# 为 Nginx 指定一个配置文件，来代替缺省的nginx -c filename# 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件nginx -t# 显示 nginx 的版本nginx -v# 显示 nginx 的版本，编译器版本和配置参数nginx -V# 格式换显示 nginx 配置参数2&gt;&amp;1 nginx -V | xargs -n12&gt;&amp;1 nginx -V | xargs -n1 | grep lua","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"web","slug":"tip/web","permalink":"https://ianvzs.github.io/categories/tip/web/"},{"name":"learning","slug":"tip/web/learning","permalink":"https://ianvzs.github.io/categories/tip/web/learning/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://ianvzs.github.io/tags/nginx/"},{"name":"keepalived","slug":"keepalived","permalink":"https://ianvzs.github.io/tags/keepalived/"}]},{"title":"OpenCV","slug":"tips/opencv","date":"2021-04-22T09:23:23.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2021/04/22/tips/opencv/","link":"","permalink":"https://ianvzs.github.io/2021/04/22/tips/opencv/","excerpt":"","text":"问题(libSM.so.6 缺失)运行opencv的代码时，报以下错误：123456Traceback (most recent call last): File &quot;data_generator.py&quot;, line 24, in &lt;module&gt; import cv2 File &quot;/usr/local/lib/python3.5/dist-packages/cv2/__init__.py&quot;, line 3, in &lt;module&gt; from .cv2 import *ImportError: libSM.so.6: cannot open shared object file: No such file or directory 解决原因是缺少共享文件库，解决办法如下： 安装apt-file$ apt-get update$ apt-get install apt-file$ apt-file update 寻找依赖库$ apt-file search libSM.so.6 libsm6: /usr/lib/x86_64-linux-gnu/libSM.so.6libsm6: /usr/lib/x86_64-linux-gnu/libSM.so.6.0.1 根据提示，安装合适的依赖库$ apt-get install libsm6 其余文件缺失类似, 即可解决问题。","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"换源","slug":"tip/换源","permalink":"https://ianvzs.github.io/categories/tip/%E6%8D%A2%E6%BA%90/"}],"tags":[]},{"title":"各个软件换源","slug":"tips/for_china","date":"2021-04-22T09:04:15.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2021/04/22/tips/for_china/","link":"","permalink":"https://ianvzs.github.io/2021/04/22/tips/for_china/","excerpt":"","text":"在国内用原源都会很慢, 所以总结一下各个软件(?吧)换源方法. apt可解决版本升级时的问题,即使用了国内源,最后一个文件不知道为什么还是从国外拉取… 12# sudo touch /etc/apt/apt.confsudo vim /etc/apt/apt.conf -&gt; Acquire::http::Proxy “http://127.0.0.1:8001&quot;; FreeBSD mkdir -p /usr/local/etc/pkg/reposvim /usr/local/etc/pkg/repos/bjtu.conf 12345678bjtu: &#123; url: &quot;pkg+http://mirror.bjtu.edu.cn/reverse/freebsd-pkg/$&#123;ABI&#125;/quarterly&quot;, mirror_type: &quot;srv&quot;, signature_type: &quot;none&quot;, fingerprints: &quot;/usr/share/keys/pkg&quot;, enabled: yes&#125;FreeBSD: &#123; enabled: no &#125; pkg update Qt源 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/ 清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/ 北京理工大学：http://mirror.bit.edu.cn/qtproject/ 中国互联网络信息中心：https://mirrors.cnnic.cn/qt/ Python Pip1pip install --index https://pypi.mirrors.ustc.edu.cn/simple/ dlib(numpy等包名) 源 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ Nodejs Npm不过好像换了会有问题.Npm各个包依赖混乱不堪,不忍直视. 1npm install --registry=https://registry.npm.taobao.org Ubuntu地址: /etc/apt/sources.list 注意备份, sudo 权限 文件内容如下, 原源部分没有粘贴完全20.04 Focal Fossa123456789101112131415161718192021222324252627282930313233343536373839# 国内源# Alideb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse# QH# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# See http://help.ubuntu.com/community/UpgradeNotes for how to upgrade to# newer versions of the distribution.deb http://archive.ubuntu.com/ubuntu/ focal main restricted# deb-src http://archive.ubuntu.com/ubuntu/ focal main restricted## Major bug fix updates produced after the final release of the## distribution.deb http://archive.ubuntu.com/ubuntu/ focal-updates main restricted# deb-src http://archive.ubuntu.com/ubuntu/ focal-updates main restricted# 原源(以下可保存也可不保存吧, 以上可选其一也可全部都放着, 目前没啥问题)## N.B. software from this repository is ENTIRELY UNSUPPORTED by the Ubuntu## team. Also, please note that software in universe WILL NOT receive any## review or updates from the Ubuntu security team. Pi同debian","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"换源","slug":"tip/换源","permalink":"https://ianvzs.github.io/categories/tip/%E6%8D%A2%E6%BA%90/"}],"tags":[]},{"title":"网络(Computer Network)","slug":"notes/net","date":"2021-04-22T07:15:14.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2021/04/22/notes/net/","link":"","permalink":"https://ianvzs.github.io/2021/04/22/notes/net/","excerpt":"","text":"C++ &amp; Epoll代码可见这里 也没啥高级就是: create_socket epoll_create1 epoll_ctl(1. &amp; 2.) struct epoll_event events[MAX_EPOLL_EVENTS] = {0}; while1: epoll_wait(2, &amp; 4.) eventfd == sockfd accept else =&gt; connfd read 所以就是: epoll_event -&gt; 内核空间 epitem -&gt; 红黑 设备事件就绪 - callback (epitem -&gt; rdlist链表) emmmm…有需要再继续整理吧 和select-poll区别为: 一个遍历, 一个触发式的.","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"网络(Net)","slug":"note/网络-Net","permalink":"https://ianvzs.github.io/categories/note/%E7%BD%91%E7%BB%9C-Net/"}],"tags":[]},{"title":"tips Of Debuggers","slug":"tips/tipsOfdebugers","date":"2019-01-10T04:21:12.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2019/01/10/tips/tipsOfdebugers/","link":"","permalink":"https://ianvzs.github.io/2019/01/10/tips/tipsOfdebugers/","excerpt":"","text":"Clang &amp;&amp; lldb听说clang+lldb &gt;= gcc + gdb, 所以一试: lldb基本命令与GDB相同 break (b) - 设置断点，也就是程序暂停的地方 run (r) - 启动目标程序，如果遇到断点则暂停 step (s) - 进入下一条指令中的函数内部 backtrace (bt) - 显示当前的有效函数 frame (f) - 默认显示当前栈的内容，可以通过 frame arg 进入特定的 frame（用作输出本地变量） next (n) - 运行当前箭头指向行 continue (c) - 继续运行程序直到遇到断点。 12clang hello.c -g -o hellolldb hello 12345# lldbb mainrunnp str 还有颜色 😂 可视效果确实提高了不少而且这四个工具可以混用,也蛮好. GDB First and foremost, you will need to compile your program with the flag “-g” (for debug) to run it via GDB. From there the syntax to start debugging is: 1$ gdb -tui [executable&#x27;s name] placing breakpoints 1234break [line number] or b [line number]or [file name]:[line number]or [function name] And even better, can set conditional breakpoints: 1break [line number] if [condition] For example, can set (if have a loop) 1break 11 if i &gt; 97 Place a “watchpoint” which will pause the program if a variable is modified: 1watch [variable] Once our breakpoints are set, we can run the program with the “run” command, or simply: 1r [command line arguments if your program takes some] How we got to that point: 1bt Display all the local variables and their current values. 1info locals Of course: 1234567891011p [variable] ptype [variable]step nextdelete [line number]continuequit Playing with fire. As well do it all the way: 1set var [variable] = [new value]","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"debug","slug":"tip/debug","permalink":"https://ianvzs.github.io/categories/tip/debug/"},{"name":"learning","slug":"tip/debug/learning","permalink":"https://ianvzs.github.io/categories/tip/debug/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"debuger","slug":"debuger","permalink":"https://ianvzs.github.io/tags/debuger/"},{"name":"pdb","slug":"pdb","permalink":"https://ianvzs.github.io/tags/pdb/"},{"name":"gdb","slug":"gdb","permalink":"https://ianvzs.github.io/tags/gdb/"}]},{"title":"Django的建站的(｡･･)ﾉﾞ","slug":"notes/noteOfwebStation","date":"2018-06-07T08:30:18.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2018/06/07/notes/noteOfwebStation/","link":"","permalink":"https://ianvzs.github.io/2018/06/07/notes/noteOfwebStation/","excerpt":"","text":"author: Ian Django 的一些东西 利用nginxfd反向代理解决跨域问题纠结了很久的跨域问题。。。。。。一直配置Django。。。。。问题重重，从配置方面这条路还没找到解决方案，如以后确认无误后就再放在这儿。告慰前面付出的种种艰辛 😓😀 来自(这儿)[https://www.jb51.net/article/105786.htm] 方法是： 打开nginx默认配置文件/etc/nginx/sites-available/default更改如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344## demo listen 5017 proxy 5000 and 5001 ##server &#123; listen 5017; server_name a.xxx.com; access_log /var/log/nginx/a.access.log; error_log /var/log/nginx/a.error.log; root html; index index.html index.htm index.php; ## send request back to flask ## location / &#123; proxy_pass http://127.0.0.1:5000/ ; #Proxy Settings proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; proxy_max_temp_file_size 0; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; &#125; location /proxy &#123; rewrite ^.+proxy/?(.*)$ /$1 break; proxy_pass http://127.0.0.1:5001/ ; #Proxy Settings proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504; proxy_max_temp_file_size 0; proxy_connect_timeout 90; proxy_send_timeout 90; proxy_read_timeout 90; proxy_buffer_size 4k; proxy_buffers 4 32k; proxy_busy_buffers_size 64k; &#125;&#125;## End a.xxx.com ## 很显然，这种解决方法仅仅适用于同服务器，架设两个网站。进行跨域访问。所以这种东西……就很欠缺。 或者nginx也支持多服务器“并联”？ 但这种解决方案依然不能解决两个“严格无关”的网站通信。 摒弃java后的’欢乐’?时光?Django 的前端相关[^_^]虽然我前端不用这个吧，但就一记录。届时估计还是回来翻Django官方文档的。摘一个看一个牛逼哄哄的东西：Removing hardcoded URLs in templatesRemember, when we wrote the link to a question in the polls/index.html template, the link was partially hardcoded like this 1&lt;li&gt;&lt;a href=&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; The problem with this hardcoded, tightly-coupled approach is that it becomes challenging to change URLs on projects with a lot of templates. However, since you defined the name argument in the path() functions in the polls.urls module, you can remove a reliance on specific URL paths defined in your url configurations by using the \\&#123;\\% url \\%\\&#125; template tag:The problem with this hardcoded, tightly-coupled approach is that it becomes challenging to change URLs on projects with a lot of templates. However, since you defined the name argument in the path() functions in the polls.urls module, you can remove a reliance on specific URL paths defined in your url configurations by using the \\&#123;\\% url \\%\\&#125; template tag: 1&lt;li&gt;&lt;a href=&quot;&#123;% url &#x27;detail&#x27; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; The way this works is by looking up the URL definition as specified in the polls.urls module. You can see exactly where the URL name of ‘detail’ is defined below: 12# the &#x27;name&#x27; value as called by the &#123;% url %&#125; template tagpath(&#x27;&lt;int:question_id&gt;/&#x27;, views.detail, name=&#x27;detail&#x27;), If you want to change the URL of the polls detail view to something else, perhaps to something like polls/specifics/12/ instead of doing it in the template (or templates) you would change it in polls/urls.py: 12# added the word &#x27;specifics&#x27;path(&#x27;specifics/&lt;int:question_id&gt;/&#x27;, views.detail, name=&#x27;detail&#x27;), Namespacing URL namesThe answer is to add namespaces to your URLconf. In the polls/urls.py file, go ahead and add an app_name to set the application namespace: 1234567891011from django.urls import pathfrom . import viewsapp_name = &#x27;polls&#x27;urlpatterns = [ path(&#x27;&#x27;, views.index, name=&#x27;index&#x27;), path(&#x27;&lt;int:question_id&gt;/&#x27;, views.detail, name=&#x27;detail&#x27;), path(&#x27;&lt;int:question_id&gt;/results/&#x27;, views.results, name=&#x27;results&#x27;), path(&#x27;&lt;int:question_id&gt;/vote/&#x27;, views.vote, name=&#x27;vote&#x27;),] Change your polls/index.html template from:polls/templates/polls/index.html¶ 1&lt;li&gt;&lt;a href=&quot;&#123;% url &#x27;detail&#x27; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; to point at the namespaced detail view:polls/templates/polls/index.html¶ 1&lt;li&gt;&lt;a href=&quot;&#123;% url &#x27;polls:detail&#x27; question.id %&#125;&quot;&gt;&#123;&#123; question.question_text &#125;&#125;&lt;/a&gt;&lt;/li&gt; 版本其中，很令人头疼的便是版本。 如果遇到什么莫名其妙的错，请查看是否是版本的原因。这里的版本原因并不☞一些人说的库依赖严重，好像开发者版本更迭不考虑兼容——或者说居然勤奋的接口重换那般严重。此处仅仅☞在运行新版本时否个方法时，或许会莫名其妙引发一个早已摒弃的函数错误。这时候就可能是在折腾版本是导致有的不同版本有文件残留。在运行时莫名其妙的被import了然后它有调取其他东西，但是找不到的… 这时候轻则pip uninstall 重则环境重建。所以可见虚拟环境还是挺有用的嘛—— MVC全名： Model 、View、Controller。模型，视图，控制器这种功能分离的软件设计规范。所以它是通用的…不要和爪哇捆绑，搞得和某个神奇技术一般… (⊙﹏⊙) 简介在安装之后，使用django-admin startproject +名字来初始化一个工程。 对比到python中就是创建好了文档目录，还在文件中写入相关框架代码，以此支持运行。 试一下?python manage.py runserver便可开启服务器，这时候访问相应端口，就一个欢迎界面，提示嗯~ o(￣▽￣)o，你能开跑了。 再试一下？在11版本中有\\admin地址可以访问，访问之后便是一个登陆界面.但,并不知道用户名和密码啊~ emm… 不过好处是能看到这个页面至少保证了django在render一个.html页面时是正常的。而之前说的老版本残留就会导致render时出错。 结构根目录下，’项目名文件’是项目容器😰manage.py 命令行工具，emm 类似于python click库的命令行程序，使用参数干不同的事情。进入到项目容器中，其中settings.py顾名思义urls.py同上，管理各个url通往哪里wsgl.py某个兼容啥，现在不用管… 得知结构之后然后就能 在urls.py里愉快的添加各个功能url。这里面就一个urlpatterns列表，使用djangol.conf.urls.url方法来配置。不过其对应的执行函数都需要一个request来接受请求数据。 return回一个页面~ 现在用到的有django,shortcuts.render 及 render_to_response出来的，以及django.http.HttpResponse出来的东西。 嗯…… ulr 链接的执行方法详情就放在新创建的view.py中管理。 而在view中需要渲染的html文件则放置在根目录新创建的templates文件夹中。通过在setting.py中的’TEMPLATES’列表中的不知名字典(因为它确实没取名啊😔)deDIRS元素来指路。 这下可以很厉害了进而进行数据库配置—— 还在setting.py中的’DATABASES’来指路。但Django规定要使用模型，就要创建一个爱怕怕app： 1django-admin startapp TestModel 🦑 再将此爱怕怕领到setting.py中NSTALLED_APPS中签一下到。随后在TestModel下的models中创建继承于django.db.models.Model的数据类，然后使用隶属于models下的方法来制定数据类型eg: 1name = models.CharField(max_length=20) 毕竟不能直接通过Python的自由类嘛… 然后也肯定不能通过python的制定类型… 毕竟python数据类型和MySQL天差地别。 最后再回到命令行中使用 1234python manage.py migrate //创建表结构python manage.py makemigrations //通知更改python manage.py testModel // 创建表结构 😲❓正式拉入编制之后就能用了。 2019年1月23日 123- Change your models(in *models.py*)- Run *python manage.py makemigrations* to create migration for those changes- Run *python manage.py migrate* to apply those changes to the database Of courses, If Null Run python manage.py migrate can make a models.py whitch has nothings. 那么这个数据库怎么操作呢？自然是到urls.py中添加🔗链接到方法的路再到容器里面添加testdb.py来说明方法详细。 增删改查12345678910111213141516171819实例化类直接.save()即保存未实例化类，all标识查找全部.objects.filter(填写删选条件).objects.get(获取).order_by(排序条件)更改则是将查出来的东西直接修改.update(修改东西)再.save保存删除便是.delete()``.差不多了 之后的详细再随情况更新。### 那么数据库表多了怎么一键生成对应类呢？```shellpython manage.py inspectdb //自动生成models模型文件python manage.py inspectdb &gt; app/models.py //假设有了名为&#x27;app&#x27;的爱怕怕// 老一套python manage.py makemigrationspython manage.py migrate 但是会将之前models.py中的东西删掉… 还会把数据库中的表名重命名… 按它的规矩来生成，嗯…其实也🆗的。 我爱Java 2018年6月24日16点40分的我由衷的写到在MySQL中读取blob存储的字段时，使用BinaryField不可使用其逆向生成的模型读取方式。当然，对照表如下 123456789101112131415161718192021222324252627&#x27;AutoField&#x27;: &#x27;integer AUTO_INCREMENT&#x27;,&#x27;BigAutoField&#x27;: &#x27;bigint AUTO_INCREMENT&#x27;,&#x27;BinaryField&#x27;: &#x27;longblob&#x27;,&#x27;BooleanField&#x27;: &#x27;bool&#x27;,&#x27;CharField&#x27;: &#x27;varchar(%(max_length)s)&#x27;,&#x27;CommaSeparatedIntegerField&#x27;: &#x27;varchar(%(max_length)s)&#x27;,&#x27;DateField&#x27;: &#x27;date&#x27;,&#x27;DateTimeField&#x27;: &#x27;datetime&#x27;,&#x27;DecimalField&#x27;: &#x27;numeric(%(max_digits)s, %(decimal_places)s)&#x27;,&#x27;DurationField&#x27;: &#x27;bigint&#x27;,&#x27;FileField&#x27;: &#x27;varchar(%(max_length)s)&#x27;,&#x27;FilePathField&#x27;: &#x27;varchar(%(max_length)s)&#x27;,&#x27;FloatField&#x27;: &#x27;double precision&#x27;,&#x27;IntegerField&#x27;: &#x27;integer&#x27;,&#x27;BigIntegerField&#x27;: &#x27;bigint&#x27;,&#x27;IPAddressField&#x27;: &#x27;char(15)&#x27;,&#x27;GenericIPAddressField&#x27;: &#x27;char(39)&#x27;,&#x27;NullBooleanField&#x27;: &#x27;bool&#x27;,&#x27;OneToOneField&#x27;: &#x27;integer&#x27;,&#x27;PositiveIntegerField&#x27;: &#x27;integer UNSIGNED&#x27;,&#x27;PositiveSmallIntegerField&#x27;: &#x27;smallint UNSIGNED&#x27;,&#x27;SlugField&#x27;: &#x27;varchar(%(max_length)s)&#x27;,&#x27;SmallIntegerField&#x27;: &#x27;smallint&#x27;,&#x27;TextField&#x27;: &#x27;longtext&#x27;,&#x27;TimeField&#x27;: &#x27;time&#x27;,&#x27;UUIDField&#x27;: &#x27;char(32)&#x27;, 以上是一部分，具体点这里 模型字段名称在逆向生成时，我遇到过一次将数据库名修改的先例，不过后来似乎没有修改过。 然后就是驼峰命名法的字段可能emm也是因为此我才开始写这些信息，就是，驼峰命名法的字段可能在模型字段中为全小写。 还有就是Django莫名其妙的的编码错误，真的是一分钟编程，一小时修改编码…而且调试起来真的…我目前的调试方式极为原始，所以感觉真的不想编程嗯… Django 返回文件下载123456789101112131415def readFile(fn, buf_size=262144): # 大文件下载，设定缓存大小 f = open(fn, &quot;rb&quot;) while True: # 循环读取 c = f.read(buf_size) if c: yield c else: break f.close()response = HttpResponse(readFile(filePath), content_type=&#x27;APPLICATION/OCTET-STREAM&#x27;) # 设定文件头，这种设定可以让任意文件都能正确下载，而且已知文本文件不是本地打开fileName = &#x27;haya&#x27;fileType = &#x27;.docx&#x27;response[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=&#x27; + fileName.encode(&#x27;utf-8&#x27;) + fileType.encode(&#x27;utf-8&#x27;) # 设定传输给客户端的文件名称response[&#x27;Content-Length&#x27;] = os.path.getsize(filePath) # 传输给客户端的文件大小return response Python Docx编辑替换1在`.docx`文件中将需要替换的位置 使用变量站位，写法&#123;&#123; placheholdParaName &#125;&#125; 使用文件时，只能写做&#123;&#123;placheholdParaName&#125;&#125;不能有空格…另外docx使用docx中的Document读入即可 1234tpl = DocxTemplate(self.prjRootPath + &#x27;/word_template/&#x27; + &quot;word_template.docx&quot;)sub1 = tpl.new_subdoc()sub1.subdocx = Document(temPath + &#x27;sub1_bond.docx&#x27;)subContext[&#x27;sub1&#x27;] = sub1 12上述中，只能写作……难道是因为使用&#123;&#123;someThing&#125;&#125;这种写法而隐藏了？！！那么，今后写彩带注释岂不是不需要使用^_^而直接使用双花括号的写法就能直接隐藏了么(⊙o⊙ ) 凄い Py中： 123456789from docxtpl import DocxTemplate, InlineImagefrom docx.shared import Mm, Inches, Ptdoc = DocxTemplate(&quot;my_word_template.docx&quot;)myimage = InlineImage(doc,&#x27;C:/Users/GuPengxiang/Pictures/ha.jpg&#x27;,width=Mm(20))context = &#123; &#x27;fundName&#x27; : u&#x27;这里是基金名称&#x27;, &#x27;stars&#x27;:u&#x27;五星级琉璃六&#x27;, &#x27;bench&#x27;: u&#x27;对比基金&#x27;, &#x27;income&#x27;: u&#x27;12&#x27;, &#x27;bb&#x27;: u&#x27;0.1%&#x27;, &#x27;image0&#x27; : myimage&#125;doc.render(context)doc.save(&quot;generated_doc.docx&quot;) 生成echarts图表图片环境123456789101112131415# 更新软件列表 &amp; 更新软件sudo apt-get update sudo apt-get upgrade# 下载包pip install pyecharts-snapshotwget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.5.0-beta-linux-ubuntu-xenial-x86_64.tar.gz# 解压tar -xzvf phantomjs-2.5.0-beta-linux-ubuntu-xenial-x86_64.tar.gz# 进入路径cd phantomjs-2.5.0-beta-ubuntu-xenial/bin# 赋予权限chmod +x phantomjs# 查看版本号phantomjs -v # 若显示版本号，如 2.1.1 则生效 生成图片1234567891011121314from pyecharts import Line, Pie, Gridfrom pyecharts_snapshot.main import make_a_snapshotattr = [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;]v1 = [5, 20, 36, 10, 10, 100]v2 = [55, 60, 16, 20, 15, 80]line = Line(&quot;折线图示例&quot;)line.add(&quot;商家A&quot;, attr, v1, mark_point=[&quot;average&quot;])line.add(&quot;商家B&quot;, attr, v2, is_smooth=True, mark_line=[&quot;max&quot;, &quot;average&quot;])line.render(&#x27;test.html&#x27;)make_a_snapshot(&#x27;test.html&#x27;, &#x27;test.pdf&#x27;)# 或者直接生成line.render(&#x27;test.png&#x27;) 在生成图片时，插件包文件源码中有Log，但却是print出来的，而在部署环境中不允许出现print，所以…… 得在包源码中将之屏蔽 连续生成图片用以上方法来生成图片是…很慢的🐢⬅这个速度。但可以通过使用为渲染创建一个默认配置环境来避免多次生成环境配置。所以—— 具体来看pyecharts中的高级说明🕶 12345678910111213141516from pyecharts import Bar, Linefrom pyecharts.engine import create_default_environmentbar = Bar(&quot;我的第一个图表&quot;, &quot;这里是副标题&quot;)bar.add(&quot;服装&quot;, [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;], [5, 20, 36, 10, 75, 90])line = Line(&quot;我的第一个图表&quot;, &quot;这里是副标题&quot;)line.add(&quot;服装&quot;, [&quot;衬衫&quot;, &quot;羊毛衫&quot;, &quot;雪纺衫&quot;, &quot;裤子&quot;, &quot;高跟鞋&quot;, &quot;袜子&quot;], [5, 20, 36, 10, 75, 90])env = create_default_environment(&quot;html&quot;)# 为渲染创建一个默认配置环境# create_default_environment(filet_ype)# file_type: &#x27;html&#x27;, &#x27;svg&#x27;, &#x27;png&#x27;, &#x27;jpeg&#x27;, &#x27;gif&#x27; or &#x27;pdf&#x27;env.render_chart_to_file(bar, path=&#x27;bar.html&#x27;)env.render_chart_to_file(line, path=&#x27;line.html&#x27;) (￣▽￣)o 如上 注意在生成报表时， 由于采用的是浏览器截图的方式，在使用`phantomjs`时会自动判断图片是否加载完成（echarts在显示图表之前是有一段动画的……）然后再`pyecharts`中并没有关闭动画的接口，而echarts是有的。 但毕竟`echarts`是在做翻译，所以只要在&quot;Chart&quot;基类中，将`animation=False`就可以了。 我改的时候在`chart.py`文件的29行，def __init__中。 SSl加密，https配置虽然就配置过之后显得操作很简单，而且也很明显，但就配置之初着实还是费了一些功夫的。或许是因为大而全的东西懒得看，而网上搜索到的粘贴复制之词又太过片面，或许大家写的时候也就当作日记来写的，本就没准备让别人去参考。所以再加上搜索的时候俺表述词不达意，所以总是很曲折（呵，用谷歌搜外文网就不存在这问题，前面就谦虚一下🙃） 之前写的文档1 ssl加密部署步骤说明文档一．申请ssl证书1.生成csr文件，可使用openssl工具生成(1)例:openssl genrsa -des3 -out server.key 1024 生成服务器key文件;(2)例:openssl req -new -key server.key -out server.csr 生成服务器证书请求CSR文件;或使用CSR文件生成工具生成(例https://www.chinassl.net/ssltools/generator-csr.html，填写信息后点击生成CSR文件即可)（CSR文件中包括组织部门、国家地区、算法、以及邮箱和域名等信息）2.申请/购买HTTPS证书， 填写与上述相同的信息，验证类型选择DNS，CSR生成选择提供CSR(即提供第一步生成的CSR文件)（例：在阿里云或腾讯等地，本文档撰写时是通过https://freessl.org/ 免费申请而来（一年有效期，单域名，））二、验证域名所属关系1.到域名管理控制台中选择云解析DNS, 选择域名，添加“记录”，记录类型选择‘TXT’，主机记录及记录值填写证书申请方提供内容。2.等待1分钟或10分钟后，等待生效3.点击验证三、证书下载验证通过后，下载网站提供证书，含（CA证书、服务器证书、服务器私钥）四、Apache2部署开启SSL加密更改httpd.conf 文件设置：1.Listen {内网IP}:802.开启models(1)LoadModule ssl_module modules/mod_ssl.so(2)LoadModule socache_shmcb_module modules/mod_socache_shmcb.so(3)LoadModule rewrite_module modules/mod_rewrite.so(4)ServerName {与域名相同}（未测试是否必须相同）3.http跳转到https:(1)RewriteEngine on(2)RewriteCond %{SERVER_PORT} !^443$(3)RewriteRule ^/?(.*)$ https://%{SERVER_NAME}/$1 [L,R]更改extra/httpd-ssl.conf 文件设置1.Listen 4432.ServerName www.lejinrong.cn3.ServerAdmin admin@lejinrong4.SSLCertificateFile “c:/Apache24/conf/ssl/server.crt”5.SSLCertificateKeyFile “c:/Apache24/conf/ssl/server.key”第四步中crt文件指向服务器证书文件， 第五步中.key文件指向私钥文件(其余部署方案或许有所不同，会使用CA证书) 1.1 注意： 确保服务器中防火墙入站规则中添加了80端口和443端口。 2 附：2.1.1 本地测试方案： 环境：wamp Apache 2.4.9前言：wamp安装好后，默认的只有http服务，以下配置启用https服务条件：在Apache安装目录下需要有一下文件 [Apache安装目录]/modules/ mod_ssl.so [Apache安装目录]/bin/ openssl.exe, libeay32.dll, ssleay32.dll [Apache安装目录]/conf/ openssl.cnf步骤：一、修改配置文件httpd.conf，去掉下面行首的#（载入ssl模块和其他配置文件）LoadModule socache_shmcb_module modules/mod_socache_shmcb.soLoadModule ssl_module modules/mod_ssl.soInclude conf/extra/httpd-ssl.conf二、认证文件生成（生成证书签发请求）进入Apache安装目录的bin目录下，输入cmd，进入DOS窗口，输入以下命令openssl req -new -out server.csr -config ../conf/openssl.cnf回车后提示输入密码和确认密码，本机输入：keypasswd后面会提示输入一系列的参数……Country Name (2 letter code) [AU]: （要求输入国家缩写，只能输入2个字母，这里输入cn）State or Province Name (full name) [Some-State]: （要求输入州名或省名，这里输入hubei）Locality Name (eg, city) []: （要求输入城市名，这里输入wuhan）Organization Name (eg, company) [Internet Widgits Pty Ltd]: （要求输入组织名或公司名，这里输入gg）Organizational Unit Name (eg, section) []: （要求输入部门名，这里输入gg）Common Name (eg, YOUR name) []: （要求输入服务器域名或IP地址）Email Address []: （要求输入邮件地址）A challenge password[]:（要求输入密码）An optional company name[]（要求输入公司别名，这里输入ggs）…..生成私钥，在DOS窗口下的Apache的bin目录下输入命令openssl rsa -in privkey.pem -out server.key然后要求输入之前 privkey.pem 的密码（keypasswd)创建证书，输入命令openssl x509 -in server.csr -out server.crt -req -signkey server.key -days 8000回车后，显示创建成功，有效期为 8000 天将Apache的bin目录下的server.csr、server.crt、server.key拷贝到Apache安装目录下的conf\\ssl，若没有ssl文件则创建打开Apache安装目录conf/extra/httpd-ssl.conf文件，设置SSLCertificateFile和SSLCertificateKeyFileSSLCertificateFile “C:/apache2.4.9/conf/ssl/server.crt”SSLCertificateKeyFile “C:/apache2.4.9/conf/ssl/server.key”最后重启Apache服务，HTTPS服务的默认监听端口为443 随后在本机中安装server.crt至收信人的根证书颁发机构即可不再提示证书无效注意：在重启Apache时，若Apache服务启动不起来，则在Apache安装目录的bin目录下，输入httpd –t，可以根据提示来修改你的配置文件 附现在是2018年8月25日16点01分 所以上面其实是一个月前写给别人看的文档。在我搜的时候由于先在本地配置，尔后再网上找CA发证书，自我感觉这个步骤没有什么问题。就今天在 Apache配置双网站/https的时候，也是这样，先在本地通过不同端口测试，确定方案之后再在服务器上通过ServerName进行区分。也就是启用httpd-vhosts.conf之后，再 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# Virtual Hosts## Required modules: mod_log_config# If you want to maintain multiple domains/hostnames on your# machine you can setup VirtualHost containers for them. Most configurations# use only name-based virtual hosts so the server doesn&#x27;t need to worry about# IP addresses. This is indicated by the asterisks in the directives below.## Please see the documentation at # &lt;URL:http://httpd.apache.org/docs/2.4/vhosts/&gt;# for further details before you try to setup virtual hosts.## You may use the command line option &#x27;-S&#x27; to verify your virtual host# configuration.## VirtualHost example:# Almost any Apache directive may go into a VirtualHost container.# The first VirtualHost section is used for all requests that do not# match a ServerName or ServerAlias in any &lt;VirtualHost&gt; block.#&lt;VirtualHost 192.168.1.81:80&gt; ServerName www.lejinrong.cn ServerAlias www.lejinrong.cn ServerAdmin www.lejinrong.cn #指定myweb项目的wsgi.py配置文件路径 WSGIScriptAlias / D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2/Fund_Evaluation_System/wsgi.py #配置静态变量路径 Alias /static/ D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2/static/ &lt;Directory D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2/static&gt; Allow from all &lt;/Directory&gt; DocumentRoot &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2&quot; &lt;Directory &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2&quot;&gt; Options Indexes FollowSymLinks AllowOverride None &lt;/Directory&gt; RewriteEngine on RewriteCond %&#123;SERVER_PORT&#125; !^400$ RewriteRule ^/?(.*)$ https://%&#123;SERVER_NAME&#125;/$1 [L,R] ErrorLog &quot;logs/dummy-host.example.com-error.log&quot; CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.1.81:8880&gt; ServerName lejinrong.cn ServerAlias vip.lejinrong.cn ServerAdmin vip.lejinrong.cn #指定myweb项目的wsgi.py配置文件路径 WSGIScriptAlias / D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3/Fund_Evaluation_System/wsgi.py #配置静态变量路径 Alias /static/ D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3/static/ &lt;Directory D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3/static&gt; Allow from all &lt;/Directory&gt; DocumentRoot &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3&quot; &lt;Directory &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3&quot;&gt; Options Indexes FollowSymLinks AllowOverride None &lt;/Directory&gt; ErrorLog &quot;logs/dummy-host.example.com-error.log&quot; CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common RewriteEngine on RewriteCond %&#123;SERVER_PORT&#125; !^443$ RewriteRule ^/?(.*)$ https://%&#123;SERVER_NAME&#125;/$1 [L,R]&lt;/VirtualHost&gt; 同理，在httpd-ssl.conf中也是通过配置不同VirtualHost进行区分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335## This is the Apache server configuration file providing SSL support.# It contains the configuration directives to instruct the server how to# serve pages over an https connection. For detailed information about these # directives see &lt;URL:http://httpd.apache.org/docs/2.4/mod/mod_ssl.html&gt;# # Do NOT simply read the instructions in here without understanding# what they do. They&#x27;re here only as hints or reminders. If you are unsure# consult the online docs. You have been warned. ## Required modules: mod_log_config, mod_setenvif, mod_ssl,# socache_shmcb_module (for default value of SSLSessionCache)## Pseudo Random Number Generator (PRNG):# Configure one or more sources to seed the PRNG of the SSL library.# The seed data should be of good random quality.# WARNING! On some platforms /dev/random blocks if not enough entropy# is available. This means you then cannot use the /dev/random device# because it would lead to very long connection times (as long as# it requires to make more entropy available). But usually those# platforms additionally provide a /dev/urandom device which doesn&#x27;t# block. So, if available, use this one instead. Read the mod_ssl User# Manual for more details.##SSLRandomSeed startup file:/dev/random 512#SSLRandomSeed startup file:/dev/urandom 512#SSLRandomSeed connect file:/dev/random 512#SSLRandomSeed connect file:/dev/urandom 512## When we also provide SSL we have to listen to the # standard HTTP port (see above) and to the HTTPS port#Listen 443Listen 400#ServerName www.lejinrong.cn#### SSL Global Context#### All SSL configuration in this context applies both to## the main server and all SSL-enabled virtual hosts.### SSL Cipher Suite:# List the ciphers that the client is permitted to negotiate,# and that httpd will negotiate as the client of a proxied server.# See the OpenSSL documentation for a complete list of ciphers, and# ensure these follow appropriate best practices for this deployment.# httpd 2.2.30, 2.4.13 and later force-disable aNULL, eNULL and EXP ciphers,# while OpenSSL disabled these by default in 0.9.8zf/1.0.0r/1.0.1m/1.0.2a.SSLCipherSuite HIGH:MEDIUM:!MD5:!RC4:!3DESSSLProxyCipherSuite HIGH:MEDIUM:!MD5:!RC4:!3DES# By the end of 2016, only TLSv1.2 ciphers should remain in use.# Older ciphers should be disallowed as soon as possible, while the# kRSA ciphers do not offer forward secrecy. These changes inhibit# older clients (such as IE6 SP2 or IE8 on Windows XP, or other legacy# non-browser tooling) from successfully connecting. ## To restrict mod_ssl to use only TLSv1.2 ciphers, and disable# those protocols which do not support forward secrecy, replace# the SSLCipherSuite and SSLProxyCipherSuite directives above with# the following two directives, as soon as practical.# SSLCipherSuite HIGH:MEDIUM:!SSLv3:!kRSA# SSLProxyCipherSuite HIGH:MEDIUM:!SSLv3:!kRSA# User agents such as web browsers are not configured for the user&#x27;s# own preference of either security or performance, therefore this# must be the prerogative of the web server administrator who manages# cpu load versus confidentiality, so enforce the server&#x27;s cipher order.SSLHonorCipherOrder on # SSL Protocol support:# List the protocol versions which clients are allowed to connect with.# Disable SSLv3 by default (cf. RFC 7525 3.1.1). TLSv1 (1.0) should be# disabled as quickly as practical. By the end of 2016, only the TLSv1.2# protocol or later should remain in use.SSLProtocol all -SSLv3SSLProxyProtocol all -SSLv3# Pass Phrase Dialog:# Configure the pass phrase gathering process.# The filtering dialog program (`builtin&#x27; is an internal# terminal dialog) has to provide the pass phrase on stdout.SSLPassPhraseDialog builtin# Inter-Process Session Cache:# Configure the SSL Session Cache: First the mechanism # to use and second the expiring timeout (in seconds).#SSLSessionCache &quot;dbm:c:/Apache24/logs/ssl_scache&quot;SSLSessionCache &quot;shmcb:c:/Apache24/logs/ssl_scache(512000)&quot;SSLSessionCacheTimeout 300# OCSP Stapling (requires OpenSSL 0.9.8h or later)## This feature is disabled by default and requires at least# the two directives SSLUseStapling and SSLStaplingCache.# Refer to the documentation on OCSP Stapling in the SSL/TLS# How-To for more information.## Enable stapling for all SSL-enabled servers:#SSLUseStapling On# Define a relatively small cache for OCSP Stapling using# the same mechanism that is used for the SSL session cache# above. If stapling is used with more than a few certificates,# the size may need to be increased. (AH01929 will be logged.)#SSLStaplingCache &quot;shmcb:c:/Apache24/logs/ssl_stapling(32768)&quot;# Seconds before valid OCSP responses are expired from the cache#SSLStaplingStandardCacheTimeout 3600# Seconds before invalid OCSP responses are expired from the cache#SSLStaplingErrorCacheTimeout 600#### SSL Virtual Host Context##&lt;VirtualHost 192.168.1.81:400&gt;# General setup for the virtual hostDocumentRoot &quot;c:/Apache24/htdocs&quot;ServerName www.lejinrong.cnServerAdmin admin@lejinrong.cnErrorLog &quot;c:/Apache24/logs/error.log&quot;TransferLog &quot;c:/Apache24/logs/access.log&quot;# SSL Engine Switch:# Enable/Disable SSL for this virtual host.SSLEngine on# Server Certificate:# Point SSLCertificateFile at a PEM encoded certificate. If# the certificate is encrypted, then you will be prompted for a# pass phrase. Note that a kill -HUP will prompt again. Keep# in mind that if you have both an RSA and a DSA certificate you# can configure both in parallel (to also allow the use of DSA# ciphers, etc.)# Some ECC cipher suites (http://www.ietf.org/rfc/rfc4492.txt)# require an ECC certificate which can also be configured in# parallel.SSLCertificateFile &quot;c:/Apache24/conf/ssl/server.crt&quot;#SSLCertificateFile &quot;c:/Apache24/conf/server-dsa.crt&quot;#SSLCertificateFile &quot;c:/Apache24/conf/server-ecc.crt&quot;# Server Private Key:# If the key is not combined with the certificate, use this# directive to point at the key file. Keep in mind that if# you&#x27;ve both a RSA and a DSA private key you can configure# both in parallel (to also allow the use of DSA ciphers, etc.)# ECC keys, when in use, can also be configured in parallelSSLCertificateKeyFile &quot;c:/Apache24/conf/ssl/server.key&quot;#SSLCertificateKeyFile &quot;c:/Apache24/conf/server-dsa.key&quot;#SSLCertificateKeyFile &quot;c:/Apache24/conf/server-ecc.key&quot;# Server Certificate Chain:# Point SSLCertificateChainFile at a file containing the# concatenation of PEM encoded CA certificates which form the# certificate chain for the server certificate. Alternatively# the referenced file can be the same as SSLCertificateFile# when the CA certificates are directly appended to the server# certificate for convenience.#SSLCertificateChainFile &quot;c:/Apache24/conf/server-ca.crt&quot;# Certificate Authority (CA):# Set the CA certificate verification path where to find CA# certificates for client authentication or alternatively one# huge file containing all of them (file must be PEM encoded)# Note: Inside SSLCACertificatePath you need hash symlinks# to point to the certificate files. Use the provided# Makefile to update the hash symlinks after changes.#SSLCACertificatePath &quot;c:/Apache24/conf/ssl.crt&quot;#SSLCACertificateFile &quot;c:/Apache24/conf/ssl.crt/ca-bundle.crt&quot;# Certificate Revocation Lists (CRL):# Set the CA revocation path where to find CA CRLs for client# authentication or alternatively one huge file containing all# of them (file must be PEM encoded).# The CRL checking mode needs to be configured explicitly# through SSLCARevocationCheck (defaults to &quot;none&quot; otherwise).# Note: Inside SSLCARevocationPath you need hash symlinks# to point to the certificate files. Use the provided# Makefile to update the hash symlinks after changes.#SSLCARevocationPath &quot;c:/Apache24/conf/ssl.crl&quot;#SSLCARevocationFile &quot;c:/Apache24/conf/ssl.crl/ca-bundle.crl&quot;#SSLCARevocationCheck chain# Client Authentication (Type):# Client certificate verification type and depth. Types are# none, optional, require and optional_no_ca. Depth is a# number which specifies how deeply to verify the certificate# issuer chain before deciding the certificate is not valid.#SSLVerifyClient require#SSLVerifyDepth 10# TLS-SRP mutual authentication:# Enable TLS-SRP and set the path to the OpenSSL SRP verifier# file (containing login information for SRP user accounts). # Requires OpenSSL 1.0.1 or newer. See the mod_ssl FAQ for# detailed instructions on creating this file. Example:# &quot;openssl srp -srpvfile c:/Apache24/conf/passwd.srpv -add username&quot;#SSLSRPVerifierFile &quot;c:/Apache24/conf/passwd.srpv&quot;# Access Control:# With SSLRequire you can do per-directory access control based# on arbitrary complex boolean expressions containing server# variable checks and other lookup directives. The syntax is a# mixture between C and Perl. See the mod_ssl documentation# for more details.#&lt;Location /&gt;#SSLRequire ( %&#123;SSL_CIPHER&#125; !~ m/^(EXP|NULL)/ \\# and %&#123;SSL_CLIENT_S_DN_O&#125; eq &quot;Snake Oil, Ltd.&quot; \\# and %&#123;SSL_CLIENT_S_DN_OU&#125; in &#123;&quot;Staff&quot;, &quot;CA&quot;, &quot;Dev&quot;&#125; \\# and %&#123;TIME_WDAY&#125; &gt;= 1 and %&#123;TIME_WDAY&#125; &lt;= 5 \\# and %&#123;TIME_HOUR&#125; &gt;= 8 and %&#123;TIME_HOUR&#125; &lt;= 20 ) \\# or %&#123;REMOTE_ADDR&#125; =~ m/^192\\.76\\.162\\.[0-9]+$/#&lt;/Location&gt;# SSL Engine Options:# Set various options for the SSL engine.# o FakeBasicAuth:# Translate the client X.509 into a Basic Authorisation. This means that# the standard Auth/DBMAuth methods can be used for access control. The# user name is the `one line&#x27; version of the client&#x27;s X.509 certificate.# Note that no password is obtained from the user. Every entry in the user# file needs this password: `xxj31ZMTZzkVA&#x27;.# o ExportCertData:# This exports two additional environment variables: SSL_CLIENT_CERT and# SSL_SERVER_CERT. These contain the PEM-encoded certificates of the# server (always existing) and the client (only existing when client# authentication is used). This can be used to import the certificates# into CGI scripts.# o StdEnvVars:# This exports the standard SSL/TLS related `SSL_*&#x27; environment variables.# Per default this exportation is switched off for performance reasons,# because the extraction step is an expensive operation and is usually# useless for serving static content. So one usually enables the# exportation for CGI and SSI requests only.# o StrictRequire:# This denies access when &quot;SSLRequireSSL&quot; or &quot;SSLRequire&quot; applied even# under a &quot;Satisfy any&quot; situation, i.e. when it applies access is denied# and no other module can change it.# o OptRenegotiate:# This enables optimized SSL connection renegotiation handling when SSL# directives are used in per-directory context. #SSLOptions +FakeBasicAuth +ExportCertData +StrictRequire&lt;FilesMatch &quot;\\.(cgi|shtml|phtml|php)$&quot;&gt; SSLOptions +StdEnvVars&lt;/FilesMatch&gt;&lt;Directory &quot;c:/Apache24/cgi-bin&quot;&gt; SSLOptions +StdEnvVars&lt;/Directory&gt;# SSL Protocol Adjustments:# The safe and default but still SSL/TLS standard compliant shutdown# approach is that mod_ssl sends the close notify alert but doesn&#x27;t wait for# the close notify alert from client. When you need a different shutdown# approach you can use one of the following variables:# o ssl-unclean-shutdown:# This forces an unclean shutdown when the connection is closed, i.e. no# SSL close notify alert is sent or allowed to be received. This violates# the SSL/TLS standard but is needed for some brain-dead browsers. Use# this when you receive I/O errors because of the standard approach where# mod_ssl sends the close notify alert.# o ssl-accurate-shutdown:# This forces an accurate shutdown when the connection is closed, i.e. a# SSL close notify alert is send and mod_ssl waits for the close notify# alert of the client. This is 100% SSL/TLS standard compliant, but in# practice often causes hanging connections with brain-dead browsers. Use# this only for browsers where you know that their SSL implementation# works correctly. # Notice: Most problems of broken clients are also related to the HTTP# keep-alive facility, so you usually additionally want to disable# keep-alive for those clients, too. Use variable &quot;nokeepalive&quot; for this.# Similarly, one has to force some clients to use HTTP/1.0 to workaround# their broken HTTP/1.1 implementation. Use variables &quot;downgrade-1.0&quot; and# &quot;force-response-1.0&quot; for this.BrowserMatch &quot;MSIE [2-5]&quot; \\ nokeepalive ssl-unclean-shutdown \\ downgrade-1.0 force-response-1.0# Per-Server Logging:# The home of a custom SSL log file. Use this when you want a# compact non-error SSL logfile on a virtual host basis.CustomLog &quot;c:/Apache24/logs/ssl_request.log&quot; \\ &quot;%t %h %&#123;SSL_PROTOCOL&#125;x %&#123;SSL_CIPHER&#125;x \\&quot;%r\\&quot; %b&quot;#指定myweb项目的wsgi.py配置文件路径 WSGIScriptAlias / D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2/Fund_Evaluation_System/wsgi.py#配置静态变量路径Alias /static/ D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2/static/&lt;Directory D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2/static&gt; Allow from all&lt;/Directory&gt;DocumentRoot &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2&quot;&lt;Directory &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2&quot;&gt; Options Indexes FollowSymLinks AllowOverride None&lt;/Directory&gt;&lt;/VirtualHost&gt;&lt;VirtualHost 192.168.1.81:443&gt;DocumentRoot &quot;c:/Apache24/htdocs&quot;ServerName www.lejinrong.cnServerAdmin admin@lejinrong.cnErrorLog &quot;c:/Apache24/logs/error.log&quot;TransferLog &quot;c:/Apache24/logs/access.log&quot;SSLEngine onSSLCertificateFile &quot;c:/Apache24/conf/ssl/server.crt&quot;SSLCertificateKeyFile &quot;c:/Apache24/conf/ssl/server.key&quot;&lt;FilesMatch &quot;\\.(cgi|shtml|phtml|php)$&quot;&gt; SSLOptions +StdEnvVars&lt;/FilesMatch&gt;&lt;Directory &quot;c:/Apache24/cgi-bin&quot;&gt; SSLOptions +StdEnvVars&lt;/Directory&gt;BrowserMatch &quot;MSIE [2-5]&quot; \\ nokeepalive ssl-unclean-shutdown \\ downgrade-1.0 force-response-1.0CustomLog &quot;c:/Apache24/logs/ssl_request.log&quot; \\ &quot;%t %h %&#123;SSL_PROTOCOL&#125;x %&#123;SSL_CIPHER&#125;x \\&quot;%r\\&quot; %b&quot;WSGIScriptAlias / D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3/Fund_Evaluation_System/wsgi.pyAlias /static/ D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3/static/&lt;Directory D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3/static&gt; Allow from all&lt;/Directory&gt;DocumentRoot &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3&quot;&lt;Directory &quot;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V3&quot;&gt; Options Indexes FollowSymLinks AllowOverride None&lt;/Directory&gt;&lt;/VirtualHost&gt; 但其实 都写了跳转，所以在httpd-vhosts.conf文件中的项目以及静态资源路径指定就不用指定了，只不过我懒得删…还有一个坑点就是 原本有一个指定项目路径以及python环境的语句： 123#WSGIPythonPath &quot;C:/Python27/Lib;C:/Python27/Lib/site-packages;C:/Python27/DLLs&quot;#WSGIPythonPath D:/FundEvaluationSystem_svn1#WSGIPythonHome &quot;C:/Python27&quot; 我不知道按照上下这两种为什么会出问题，但网上那些人不会。但中间那个是用来指向项目路径的一个取巧的办法。哦因为wsgi或许我已经在别处制订过了。所以只要在wsgi.py中声明sys.path.append(&#39;D:/FundEvaluationSystem_svn1/Fund_Evaluation_System_V2&#39;)就可以将项目包括进来，而不需要通过 第二句那个制定python路径的东西。而用那个，会导致资源只有声明的项目1会被加载，而项目2的资源就不会声明，而将那三句话注释，只要分别在’wsgi.py’中声明项目资源，而在.conf文件中指向’wsgi.py’文件就可以如数加载了。 (⊙﹏⊙)语序 逻辑混乱之后不加班了再整理吧~~😭 前端 Vuevue的使用方式可以通过html页面直接引用，也能直接用vue-cil创建项目。 网上人称vue脚手架？晓不大得而我这里自然说的就是 vue-cil即 通过vue init webpack &lt;prjName&gt;来生成的项目喽 系统的创建以及介绍之后使用再熟一些再写，现在先记一些零散的东西。 [^_^]2018年9月18日 21点36分 路由配置登陆访问1234567891011在`router/index.js`中：&#123; path: &#x27;/&#x27;, // 首页 name: &#x27;Main&#x27;, component: Main, meta: &#123; requireAuth: true, // 添加该字段，表示进入这个路由是需要登录的 &#125;&#125;,","categories":[{"name":"web","slug":"web","permalink":"https://ianvzs.github.io/categories/web/"},{"name":"全栈笔记","slug":"web/全栈笔记","permalink":"https://ianvzs.github.io/categories/web/%E5%85%A8%E6%A0%88%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"django","slug":"django","permalink":"https://ianvzs.github.io/tags/django/"},{"name":"missjava","slug":"missjava","permalink":"https://ianvzs.github.io/tags/missjava/"},{"name":"vue","slug":"vue","permalink":"https://ianvzs.github.io/tags/vue/"},{"name":"apache","slug":"apache","permalink":"https://ianvzs.github.io/tags/apache/"},{"name":"ajax","slug":"ajax","permalink":"https://ianvzs.github.io/tags/ajax/"}]},{"title":"愉快的Java(happy to learn the fuck java)","slug":"notes/noteOfjava","date":"2018-05-24T01:52:00.000Z","updated":"2022-06-15T07:32:39.334Z","comments":true,"path":"2018/05/24/notes/noteOfjava/","link":"","permalink":"https://ianvzs.github.io/2018/05/24/notes/noteOfjava/","excerpt":"","text":"author: Ian happy to the fuck java 😅&lt;微人事&gt; 笔记 -&gt; ψ(._. )&gt;先贴官方文档 哦 还有官方项目地址 爪哇方法定义:1234567891011121314151617修饰符 返回值类型 方法名(参数类型 参数名)&#123; 方法体; return 返回值;&#125;# 示个例public boolean NiHou(int num)&#123; int a = num; return turn;&#125;// `boolean` 处 可为public Collection&lt;? extends GrantedAuthority&gt; getAuthorities()&#123; List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;&gt;(); return authorities;&#125;// 表泛型中可以是的`GrantedAuthority`所有子类 爪哇抽象方法(即Python父类中直接pass的函数…)abstract 包含抽象方法必须得是抽象类 任何子类必须重写父类抽象方法，或者声明自身为抽象类12345678910public abstract class Employee&#123; private String name; private int number; public abstract double computePay(); //其余&#125; 爪哇接口interface, implements 12345678910111213[可见度] interface 接口名称 [extends 其他的类名] &#123; // 声明变量 // 抽象方法&#125;# 示个例/* 文件名 : NameOfInterface.java */public interface NameOfInterface&#123; //任何类型 final, static 字段 //抽象方法&#125;Interface关键字用来声明一个接口。 爪哇抽象类abstract classextends 不能直接实例化 只能被继承后实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public abstract class Employee&#123; private String name; private String address; private int number; public Employee(String name, String address, int number) &#123; System.out.println(&quot;Constructing an Employee&quot;); this.name = name; this.address = address; this.number = number; &#125; //…… 等方法 public int getNumber() &#123; return number; &#125;&#125;/* 文件名 : Salary.java */ // 用于继承上述东西public class Salary extends Employee&#123; private double salary; //Annual salary public Salary(String name, String address, int number, double salary) &#123; super(name, address, number); setSalary(salary); &#125; public void mailCheck() &#123; System.out.println(&quot;Within mailCheck of Salary class &quot;); System.out.println(&quot;Mailing check to &quot; + getName() + &quot; with salary &quot; + salary); &#125; public double getSalary() &#123; return salary; &#125; public void setSalary(double newSalary) &#123; if(newSalary &gt;= 0.0) &#123; salary = newSalary; &#125; &#125; public double computePay() &#123; System.out.println(&quot;Computing salary pay for &quot; + getName()); return salary/52; &#125;&#125;/* 文件名 : AbstractDemo.java */// 用于实现继承类 public class AbstractDemo&#123; public static void main(String [] args) &#123; Salary s = new Salary(&quot;Mohd Mohtashim&quot;, &quot;Ambehta, UP&quot;, 3, 3600.00); Employee e = new Salary(&quot;John Adams&quot;, &quot;Boston, MA&quot;, 2, 2400.00); System.out.println(&quot;Call mailCheck using Salary reference --&quot;); s.mailCheck(); System.out.println(&quot;\\n Call mailCheck using Employee reference--&quot;); e.mailCheck(); &#125;&#125; 爪哇类class, extends1 Maven 项目标准目录结构str| main | bin 脚本库 | java Java源代码文件 | resources 资源库，会自动复制到classes目录中 | filters 资源过滤文件 | assembly 组建的描述配置（如何打包） | config 配置文件 | webapp web应用的目录。WEB-INF、css、js等| test | java 单元测试Java源代码文件 | resorces 测试需要用到的资源库 | filters 测试资源过滤库 | site Site（一些文档）| target LICENSE.txt Project’s license README.txt Project’s readme 工程根目录下就只有src和target两个目录target是有存放项目构建后的文件和目录，jar包、war包、编译的class文件等。target里的所有内容都是maven构建的时候生成的 顶级目录工程的描述文件pom.xml 摘自: https://blog.csdn.net/lengyue_wy/article/details/6718637 srcjavaBean: 扮演应用程序素材的角色（其中放置了各种自定义类 如：Hr、Role、Employee、menu等数据类型）（作为service的模型库）common: 常用方法 （如字符串转换、邮件、几个查询）config: 看不懂的设置controller: 动作执行，即受到什么请求执行什么动作。 但是我打了断点鲜有进来的。所以具体实现过程还是不清楚。 另外其url地址与网页真正输入地址有全拼简写的区别，哪里有指定也没找到还。（并且寥寥草草一个就处理完了，所以肯定是简写了💩）exception: 异常处理mapper: 虽不觉然明厉的东西集合_20180525_其中定义了诸多做实事的接口，在.java文件中画饼，在.xml中实现，另外昨天在查资料时，还了解到有人要将.java与.xml分开来存放，解决方法是将.xml放在resources文件夹中，仿照在java文件夹中的路径，依瓢葫芦画😄的建立相同路径，如此一来在coding阶段看起来是分开的，但在building阶段编译器就是看作在同一目录下了——由此引发了虽然拆开了他们的人，却没有拆散他们的心的哲学论题😰(作为service的方法库)service: 动作逻辑服务，和controller中类似，不过详细不少（作为） resourcesftl: emm……static: 静态资源js: emm…application.properties: 各项配置mybatis-config.xml: MySQL数据库配置 Mybatis头123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;/configuration&gt; configuration中的配置信息详解： https://blog.csdn.net/yqynsmile/article/details/52807815 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 别名，假名，代称&lt;typeAliases&gt; &lt;typeAlias alias=&quot;Student&quot; type=&quot;com.mybatis3.domain.Student&quot; /&gt; &lt;/typeAliases&gt; // 声明环境变量&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; /* 声明数据源，数据源的类型有NOPOOLED ，POOLED ，还有JIDN. 在数据量少的话用ONPOOLED，测试和开发过程一般用POOLED，实际运行使用JIDN */&lt;dataSource type=&quot;POOLED&quot;&gt; // &lt;mappers&gt;：声明我们定义的一个个Mapper类，或者说是关联&lt;mapper resource=&quot;com/mybatis3/mappers/StudentMapper.xml&quot; /&gt; // &lt;property&gt;：jdbc连接的一些属性&lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;admin&quot; /&gt; /* 这些东西貌似也可以写在其他地方：application中 &lt;property name=&quot;url&quot;&gt; &lt;value&gt;jdbc:mysql://localhost:3306/springmybaitis?useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/value&gt; &lt;!--springmybaitis是我的数据库 --&gt; &lt;/property&gt; 或 spring.datasource.url=jdbc:mysql://127.0.0.1:3306/vhr?useUnicode=true&amp;characterEncoding=UTF-8 两种写法而已 */// &lt;mapper&gt;：声明Mapper的路径// 默认setting配置&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;//是否使用缓存 &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;//是否是懒记载 &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot; /&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot; /&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot; /&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot; /&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot; /&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25000&quot; /&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot; /&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot; /&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot; /&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot; /&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode ,toString&quot; /&gt; 还有 &lt;Settings&gt;:声明一些全局变量、&lt;typeHandlers&gt;: 自定义我们的传入参数类型处理器、&lt;properties&gt;: 声明属性文件的key和value，但使用.properties文件将会被覆盖。 注: 在要使用指定日志工具时，需要在&lt;Settings&gt;里指定&lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; equals 与 ==equals 对比两者是否类型一致，内容一致== 则会由于 不同对象而False 1234567String str1=new String(&quot;hello&quot;);String str2=new String(&quot;hello&quot;);str1==str2 输出：false,因为不同对象int1.equals(int2) 输出：TRUE// 无论 整形 or 字符串等 爪洼调用Python爪哇语有个通用调用方式，就是通过Runtime，也就是通过命令行执行，然后通过BufferedReader捕获命令行（内存）中的信息。但数据传输只能通过字符串，另外，python回传数据也只能通过print来回传，所以……基本没啥用.","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"java","slug":"note/java","permalink":"https://ianvzs.github.io/categories/note/java/"},{"name":"learning","slug":"note/java/learning","permalink":"https://ianvzs.github.io/categories/note/java/learning/"}],"tags":[{"name":"java, springboot, mybatis, maven, learning","slug":"java-springboot-mybatis-maven-learning","permalink":"https://ianvzs.github.io/tags/java-springboot-mybatis-maven-learning/"}]},{"title":"Golang不确定笔记","slug":"notes/noteOfgolang","date":"2018-05-15T02:18:26.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2018/05/15/notes/noteOfgolang/","link":"","permalink":"https://ianvzs.github.io/2018/05/15/notes/noteOfgolang/","excerpt":"","text":"Go golang不确定笔记 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html 并发 Channel使用关键字go开启goroutine轻量级线程 123go fun_name(paras_list)# eg: go f(x, y, z) 代码 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;time&quot;)func say(s string) &#123; for i := 0; i &lt; 5; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(s) &#125;&#125;func main() &#123; go say(&quot;world&quot;) say(&quot;hello&quot;)&#125; Channel用于传递数据的数据结构可用于两个goroutine之间传递指定类型值，同步和通讯&lt;- 指定通道方向(发送or接受)，未指定则双向通道 声明通道使用chan关键字, 在使用之前，需先创建. 1ch := make(chan int) 示例 123456789101112131415161718192021package mainimport &quot;fmt&quot;func sum(s []int, c chan int) &#123; sum := 0 for _, v := range s &#123; sum += v &#125; c &lt;- sum // 把 sum 发送到通道 c&#125;func main() &#123; s := []int&#123;7, 2, 8, -9, 4, 0&#125; c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &lt;-c, &lt;-c // 从通道 c 中接收 fmt.Println(x, y, x+y)&#125; Cache在创建通道时可创建缓冲区，做压入存储 1ch := make(chan int, 100) // cache size 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; // 这里我们定义了一个可以存储整数类型的带缓冲通道 // 缓冲区大小为2 ch := make(chan int, 2) // 因为 ch 是带缓冲的通道，我们可以同时发送两个数据 // 而不用立刻需要去同步读取数据 ch &lt;- 1 ch &lt;- 2 // 获取这两个数据 fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125; Vim 高亮emmmm，偶尔会有不支持Go高亮的情况所以，步骤如下： 12345678cd ~mkdir .vimcd .vimmkdir autoload pluggedcd pluggedgit clone https://github.com/fatih/vim-go vim-gocd autoloadwget https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim 配置 .vimrc 1cat ~/.vimrc set shiftwidth=4 softtabstop=4 expandtabcall plug#begin()Plug ‘fatih/vim-go’, { ‘do’: ‘:GoInstallBinaries’ }call plug#end()let g:go_version_warning = 0over~! 函数定义123func function_name([参数列表])[返回类型]&#123; balabala&#125; 如： 123456789101112func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123; if varDivider == 0 &#123; dData := DivideError&#123; dividee: varDividee, divider: varDivider, &#125; errorMsg = dData.Error() return &#125; else &#123; return varDividee / varDivider, &quot;&quot; &#125;&#125; 接口12345678910111213141516171819202122232425package mainimport ( &quot;fmt&quot;)# 或者 直接 import &quot;fmt&quot;type Phone interface &#123; call() &#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123; fmt.Println(&quot;I am Nokia, I can call you!&quot;)&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123; fmt.Println(&quot;I am iPhone, I can call you!&quot;)&#125;func main() &#123; var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call()&#125; 错误123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;fmt&quot;)// 定义一个 DivideError 结构type DivideError struct &#123; dividee int divider int&#125;// 实现 `error` 接口func (de *DivideError) Error() string &#123;// 以上函数中，取结构体地址是（等同于面向对象实例化对象吧，然后下方可以// de.使用.的方式去调取结构体中定义的某变量）//错误Error()是调用接口中的函数，制定返回类型为string strFormat := ` Cannot proceed, the divider is zero. dividee: %d divider: 0` return fmt.Sprintf(strFormat, de.dividee)&#125;// 定义 `int` 类型除法运算的函数func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123; if varDivider == 0 &#123; dData := DivideError&#123; dividee: varDividee, divider: varDivider, &#125; errorMsg = dData.Error() return &#125; else &#123; return varDividee / varDivider, &quot;&quot; &#125;&#125;func main() &#123; // 正常情况 if result, errorMsg := Divide(100, 10); errorMsg == &quot;&quot; &#123; fmt.Println(&quot;100/10 = &quot;, result) &#125; // 当被除数为零的时候会返回错误信息 if _, errorMsg := Divide(100, 0); errorMsg != &quot;&quot; &#123; fmt.Println(&quot;errorMsg is: &quot;, errorMsg) &#125;&#125; 以上总结函数定义真是… 也或许刚开始接触太多。也不知道这么设计的目的其中 功能重写见d.Data.Error。先是将d.Data定义为结构体，然后再去调用结构体下的Error，分明结构体里并没有定义，所以下面的那个函数定然是将Error,与DicideError连接的函数。 所以Go并没有类与对象一说吧… 生动点来说那个函数（func (de *DivideError) Error() string &#123;...&#125;）的定义就好像是在强行给这个地址的结构体中塞进去一个执行函数。 一个言简意骇的对象实现方法 go的循环 golang 只有for while==for golang 中没有小括号包裹, 只需要用{}分隔作用域就可以 for 可以有 for A;B;C {} for ;B; {} for {} go的switch 每个case自动break fallthrough 显式声明可以继续执行下一个case case 无需常量 switch &#123;case&#125; 可做 if-else 用 go的指针go的指针 没有指针运算.","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"golang","slug":"note/golang","permalink":"https://ianvzs.github.io/categories/note/golang/"},{"name":"learning","slug":"note/golang/learning","permalink":"https://ianvzs.github.io/categories/note/golang/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"golang","slug":"golang","permalink":"https://ianvzs.github.io/tags/golang/"}]},{"title":"Vn.Py学习笔记（Python交易平台框架）","slug":"notes/noteOfvn_py","date":"2018-05-15T02:13:48.000Z","updated":"2022-06-15T07:32:39.335Z","comments":true,"path":"2018/05/15/notes/noteOfvn_py/","link":"","permalink":"https://ianvzs.github.io/2018/05/15/notes/noteOfvn_py/","excerpt":"","text":"author: Ian Vn.Py笔记 ✏📔一个开源Python交易软件，主使用CTP协议。当然，还有其他协议了其源项目在http://www.vnpy.org/ 初期笔记报单交易过程中， CTP使用BrokerID 从业务层面完全隔离不同经纪公司的交易、风控及结算用户的接入。 BrokerID具体取值咨询开户的经纪公司。 CTP中 UserID为操作员代码，InversterID为投资者代码； 投资者自己下单两者同为投资者代码 CTP-API中，OrderRef和OrderAction 前者为CTP后台提供给客户端标识一笔报 单的字段，从客户端可通过（FrontID、SessionID、OrderRef）唯一确定一笔报 单；；；后者与OrderRef功能相似，提供给客户端来标识一笔撤单。 前者的数据类型为字符数组，必须为阿拉伯数字字符。 OrderRef（OrderActionRef）取值必须保证在同一会话内发送的报单 OrderRef（OrderActionRef）值大于之前的最大值，开发多线程客户端尤为需要 注意。 CTP-API库： error.dtd\\error.xml 错误定义文件 ---- ThostFrfcMdApi.h 交易接口类定义文件 ——— ThostFtfcUserApiDataType.h 类型定义文件 ------ thostmduserapi.lib,thostmduserpi.dll 行情接口库文件 ----- thosttraderapi.lib,thosttraderapi.dll交易接口库文件 ----- 交易和行情接口类定义文件都包含API 和 SPI类定义，客户端使用API向CTP后台 发送请求，CTP后台则使用SPI向客户端回传响应及回报 行情Demo开发： 1.将API文件复制到工程目录；并将所有的头文件和静态、动态库连链接库 并将文件导入到项目工程中。 先继承行情接口类CThostFtdcMdspi，并实现需要实现的虚函数。 OnFrontConnectde、OnFrontDisconnected、OnPspUserLogin、 OnRspSubMarketDAta /API工作流程***/ API压缩包——API含常量对应字符、类型定义、操作系统编译定义、回调函数（MdSpi）（柜台向用户端发送信息后被系统自动调用的函数）、主动函数（MdApi）（向柜台发送各种请求和指令） API工作流程： 创建MdSpi对象（回掉函数），调用MdApi类，以Create开头的静态方法，创建MdApi对象（主动函数），注册MdSpi对象指针，行情柜台前置机地址，调用MdApi对象Init方法初始化连接前置机，连接成功会通过OnFrontConnected回调通知用户，用户获得连接成功通知后，调MdApi的ReqUserLogin登陆，登陆后MdSpi的OnRsqUserLogin通知用户———————-到此登陆完成——————— MdApi：（行情相关） 使用MdApi对象的SubscribeMarketData方法，传入参数为想要订阅的“合约 代码”，订阅成功当合约有新行情通过MdApi的OnRtnDepthMarketData回调通知 用户 ———————-至此订阅完成——————— 当用户的某次请求发生错误时，会通过OnRspError通知用户 MdApi也含有退订合约、登出功能。 而一般退出程序则直接杀进程（不太安全便是） TraderApi：（交易相关） 不同于以上的有 注册TraderSpi对象的指针后需要调用TraderApi对象的 SubscribePrivateTopic和SubscribePublicTopic方法去选择公开和私有数据流的重 传方法 对于期货柜台，每一日第一次登陆需要先查询前一日的结算单，等待查询 结果返回，确认，才可进行后续操作（CTP、恒生UFT），证券（LTS）无此要求 上一步完成后，用户可以调用ReqQryInstrument的方法查询柜台上所有可 以交易的合约信息（包括代码、中文名、涨跌停、最小价位变动、合约乘数等大 量细节），一般是在这里获得合约信息列表后，再去MdApi中订阅合约；经常有 人问为什么在MdApi中找不到查询可供订阅的合约代码的函数，这里尤其要注 意，必须通过TraderApi来获取 当用户报单、成交状态发生变化时，TraderApi会自动通过OnRtnOrder、 OnRtnTrade通知，无需额外订阅 /封装API****/ 封装后API的动作： 主动函数： 调用封装API主动函数，传入Python变量作为参数—&gt;封装API将Python变量转换成C++变量—&gt;API调用原生API主动函数传入C++变量作为参数 回掉函数： 交易柜台通过原生API传入参数为C++变量-&gt;封装API将C++变量转换为Python变量-&gt;封装API调用封装后的回调函数想Python程序中推送数 封装处理： 将回调函数Spi类和主动函数Api类封装为一个类，使用中更加方便 在API中包含一个缓冲队列，当回调函数收到新的数据信息时只是简单存入 并立即返回，而数据信息的处理和向Python中的推送则由另一个工作线程执行 鉴于Python中dict字典内的键和值的类型可以不同，所以利用此来代替 C++的结构体 处理示例： getChar()： d(Python字典对象) key(d中想要提取的数据键名) if(d.has_key(key)) 判断是否存在这个键； object o = d[key]; 提取对应值 extract&lt;string&gt; x(o); 生成提取 std::string类的提取器 if (x.check()) 检测能否提取出数据 string s = x(); 执行解包器，提取 string对象 const char *buffer = s.c_str(); 从s中获取字符串指针bufffer strcpy_s(value, strlen(buffer) + 1, buffer); 将字符串指针指向的字符串数组复制到结构体成员的指针上 对字符串指针赋值 必须使用strcpy_s, vs2013使用strcpy 编译通不过+1应该是因为C++字符串的结尾符号？不是特别确定，不加这个 1会出错 /事件驱动***/ 时间驱动： 定时调用事件驱动： 新事件被推送时（如新行情、成交）则调用 初始化： 事件队列、引擎开关（标志）、事件线程、定时器、一个事件和处理函数对应字典（__handlers） 引擎运行： 循环检查引擎开关 若开则一直尝试获取事件（阻塞开，时间1s），处理事件； 若出错则pass 处理事件： 检测是否有对当前事件监听的处理函数，若有则循环调用相应处理函数对事件进行处理 计时器事件： 创建计时器事件，推入计时器事件 引擎启动： 打开引擎开关、启动事件处理线程、启动定时器（事件默认间隔1s） 停止引擎： 关闭。。。。、停止计时器、等待事件处理线程退出 注册事件处理： 尝试获取对应处理此类型函数列表（对应字典），若无则创建。 注销函数监听： 。。。。。。。。。。。。。。。。。。。。。，若无则pass，若函数存在于列表则将之移除，若函数列表为空，则引擎中移除该事件类型 put： 向事件队列中存入事件 底层接口对接： 交易程序架构分：底层接口、中层引擎、顶层GUI， 为将某API对接到程序中需：1.将API的回调函数收到的数据—&gt;中层引擎 等待处理 2.将API的主动函数进行一定的简化封装，便于中层引擎调用 中层引擎设计： 进一步封装底层接口所暴露出的API函数，使得其更容易被上层的GUI和策略组件调用。 构造函数： 以主引擎成员变量形式创建事件驱动引擎ee，行情接口md和交易接口td的对象。 随后立即启动，当用户调用接口连接、登陆等功能、收到事件推送，ee可以立即推送到监听这些事件的组件进行处理。 LTS和CTP接口的持仓情况和账户情况不通过推送，需手动查询。Demo选择循环查询模式，不断更新。可选择不进行查询，降低占用网络带宽。 登陆成功后，查询柜台所有可交易信息，保存到dictInstrument字典中，方便后续查询 优化了一些函数方法的调用方式，将经纪商一起提供的接口登陆封装在一个函数中，减少了重复书写的次数。 引擎之间执行过程发单为例：设置发单按钮 -&gt; 将点按动作关联sendOrder发单实现函数（从输入框获取合约代码-&gt;获取合约信息对象（见下） -&gt; 如果成功获取 -&gt; 再获取方向价格等信息 -&gt; 调用主引擎下发单实现 -&gt; 主引擎转到TdApi下发单函数执行（请求编号（API管理） -&gt; 将传入信息数据存入字典（合约代码、方向价格等） -&gt; 报单编号（API管理） -&gt; 用户id、单子属性（投机、立即发单、今日有效）等信息存入字典） -&gt; self.reqOrderInsert(req（信息字典）, self.__reqid（请求编号）) -&gt; 返回订单号（报单编号）） 主引擎：（负责对API的调度）init()初始化中的动作： 创建事件驱动引擎、创建API接口、启动事件驱动引擎、循环查询持仓和账户相关（之后学习）、创建合约存储空字典，注册插入合约对象执行函数事件类型和其处理函数。其中包含几乎所有的功能函数，包含了每个功能函数的实现方法 事件驱动引擎：init()初始化中的动作： 创建事件队列、创建设置事件引擎开关（关）、创建事件处理线程(目标为引擎运行)、创建计时器（将超时动作连接到__onTimer函数）、创建__handlers空字典（存储对应事件调用关系）统筹管理事件的执行，在其中建立起事件执行队列管理向队列中插入事件，分配事件对象类型（据此注册其执行函数）和具体事件数据（时间及日志），拥有注册事件处理监听及注销监听。最终使得整个程序有序的进行。 调用关系主引擎在初始化时即启动事件驱动引擎（调用启动函数start()（将引擎开关设为启动、启动事件处理线程、启动计时器）） -&gt; 事件处理线程运行目标__run()（若开关开则将从事件队列中get()到事件，放到处理函数__process()中执行） -&gt; __process()处理事件函数（检查事件类型，在__handlers字典中是否有对此监听处理函数，若存在则调用字典中处理函数） 事件启动引擎start()中启动定时器 -&gt; 创建计时器事件 -&gt; 向队列存入计时器事件 获取合约信息对象：从合约字典中读取合约信息对象有则继续执行原本程序操作（获取名称、发单撤单），无则None 以初始化查询为例：主引擎初始化中注册self.ee.register(EVENT_TDLOGIN, self.initGet),EVENT_TDLOGIN为交易服务器登陆成功事件。即此事件为登录成功后开始初始化查询。步骤：打开设定文件setting.vn，尝试读取设定字典。载入后，设定事件类型、将事件推入事件队列、查询投资者、循环查询账户和持仓。（若不存在or合约数据非今天，则发出获取合约请求。）-&gt; 获取合约 -&gt; 定义事件类型 -&gt; 推入事件队列 -&gt; API查询合约 ctpGateway 接入方法考虑到现阶段大部分CTP中的ExchangeID字段返回的都是空值vtSymbol直接使用symbol 创建CTP价格方向交易所持仓产品等类型映射，方便调用 然后 class CtpGateway(VtGateway):CTP接口中初始化动作（继承VtGateway实例化事件引擎、设定网关名称为’CTP‘、实例化ctpMdApi，ctpTdApi、初始化行情交易连接状态，循环查询允许） 连接过程初始化账号密码等、连接服务器、注册服务器地址、登陆订阅合约里有个设计为：尚未登陆就调用了订阅则保存订阅信号，则在成功登陆之后的登陆回报函数中重新订阅 数据记录器drBase.py中（定义数据类型）：（数据记录器和CTA两模块共同使用）K线数据 构造函数（定义数据类型）：vt系统代码、合约代码、交易所代码、开高低 关、bar开始时间、时间、成交量持仓量 Tick数据 构造函数（定义数据类型）：vt系统代码、合约代码、交易所代码、成交数 据、tick时间、五档行情 DrEngine数据记录引擎获取当前文件绝对路径 settingFileName = &#39;DR_setting.json&#39; path = os.path.abspath(os.path.dirname(__file__)) settingFileName = os.path.join(path, settingFileName) 初始化中动作：实例化设置主引擎、事件引擎、获取当前日期、创建主力合约代码映射字典、Tick对象字典、K线对象字典、初始化数据库插入单独线程、载入设置，订阅行情 载入设置、订阅行情打开DR_setting.json文件，以json载入，其中’working‘决定是否启动行情记录功能。随后从json文件中循环获取合约代码订阅tick和bar 启动数据插入线程（run函数（向MongoDB中插入数据））、注册事件监听（procecssTickEvent处理行情推送（下详）） 处理行情推送从事件字典中取出保存的具体事件数据、vtSymbol为tick识别信号（合约代码）、转化Tick格式、更新TIck数据（并发出日志）、更新分钟线数据 风控模块从配置json文件中读取设定信息 操作运作：1.检测风控设定值变化 2.每笔交易发单时使用风控模块决定该次发单是否允许 （其中流控计数在每次调用风控检测时计数、成交合约量在更新成交数据中加交易数值） CTA策略直接来到改版之后： CTP交易托管API介绍基于C++的类库，通过使用提供接口实现相关交易功能，含：报单与报价录入、的撤销、的挂起、的激活、的修改、的查询、成交单查询、投资者查询、 投资者持仓查询、合约查询、交易日获取等 含文件：交易接口、API所需数据类型、业务相关数据结构i、的头文件、动态链接库、导入库 体系结构建立在TCP协议之上FTD协议与交易托管系统进行通讯FTD通讯模式： 对话通讯模式 - 会员端请求、接收处理、响应 私有通讯模式 - 交易所主动向特定会员发出 广播通讯模式 - 交易所主动、全员发送 接口模式CThostFtdeTraderApi和CThostFtdeTraderSpi，前者发送请求，后者回调响应。旗下函数方法前者以Req开头后者以OnRsp开头。请求接口第一个参数为请求的内容，不能为空。第二个参数为请求号。 如果接收到的响应数据不止一个，则回调函数会被多次调用。第一个参数为响应的具体数据，第二个参数为处理结果，第三个参数为请求号，第四个参数为响应结束标志，表明是否是本次响应的最后一次回调。 运行模式至少两个线程，一个为应用程序主线程，一个为交易员API工作线程，其间通讯由API工作线程驱动。 撤单 发单发单为例：在用户点击发单之后，程序从“交易”栏的text()获取合约代码，随后从详细合约保存字典中读取其他信息，将之保存到一个字典中之后，调用主引擎对特定接口发单。 发单完成之后，马上会收到报单响应 OnRspOrderInsert，说明交易系统已经收到报单。报单进入交易系统后，如果报单的交易状态发生变化，就会收到报单回报 OnRtnOrder。如果报单被撮(部分)成交，就会收到成交回报 OnRtnTrade。通过更新 撤单时：程序从单元格中获取exchange、frontID、orderID、sessionID、symbol、gatewayName等信息，调用主引擎对特定接口撤单。撤单时调用Api函数为reqOrderAction其内容包括撤销、挂起、激活、修改，故还需一个Flag参数 ps：如果报单还停留在 Thost，Thost 可以用 Front 、SessionID、OrderRef 来定位如果报单停留在交易所，Thost 可以用 ExchangID、OrderSysID 来定位，然后向交易所转发撤单指令。 TraderApi所有方法功能OnFrontConnected/Disconnected # 客户端与交易托管系统建立起通信连接时 OnHeartBeatWarning # 当长时间未收到报文时 OnRspUserLogin/Logout # 登陆注销响应 OnRspUserPasswordUpdate # 改密响应 OnRspTradingAccountPasswordUpdate # 当客户端发出资金账户口令更新指令后，交易托管系统返回响应时 OnRspError # 请求出错时 OnRspOrderInsert # 报单录入 OnRspOrderAction # 报单操作包括报单的撤销、报单的挂起、报单的激活、报单的修改。当客户端 发出过报单操作指令后，交易托管系统返回响应时 OnRspQueryMaxOrderVolume # 查询最大报单 OnRspSettlementInfoConfirm # 当客户端发出投资者结算结果确认指令后，交易托管系统返回响应时 等…… lol 统计无力 ？ CTA 策略引擎_init_()的工作： 加载主引擎、事件引擎；获取当前日期 设定是否在回测 保存策略实例的字典strategyDict(key为策略名称，value为策略实例)、 保存vtSymbol和策略实例映射的字典(用于推送tick数据，可能多个策略交易同一个vtSymbol因此key为vtSymbol.value为包含所有相关策略对象的list)、 保存vtOrderID和strategy对象映射的字典(用于推送order和trade数据key为vtOrderID，value为strategy对象）、 本地停止单编号计数、本地停止单字典(key为stopOrderID，value为stopOrder对象)、 持仓缓存字典(key为vtSymbol，value为PositionBuffer对象)、 成交号集合、 设置引擎类型为实盘、 注册事件监听 初始化策略从数据库中读取3天的历史TICK数据、行情更新。。。。。有的话待续 启动策略从策略实例字典中取出策略实例，调用策略函数（已经初始化，没有在进行策略交易），开启进行交易标志位。 停止策略从策略实例字典中取出策略实例，调用策略函数（ 在进行策略交易），关闭策略交易标志位 -&gt; 对该策略发出的所有限价单进行撤单 -&gt; 发出的所有本地停止单撤单 -&gt; 保存、读取策略配置触发策略状态变化事件（通常用于通知GUI更新）获取策略的参数字典获取策略当前的变量字典 记录报单更新、成交更新都是先检测是否有对此监听的策略限价单成交处理：成交回报、报单回报、记录成交到列表、删除该限价单 基础功能的策略调用策略中发单时，需要在设置参数时考虑设置。 另获取持仓缓存数据，做平昨平今的选择。策略中发单时，检查报单是否有效，赋参，撤单。发停止单，编号，赋参，保存至字典撤停止单，从工作停止单字典中移除 Ta-Lib趋势策略分为以下部分： 趋势信号（通常是基于某几个参数计算出来的指标值超过某个阈值）、 信号过滤（和趋势信号类似）、 出场方案（固定点数/百分比的止盈和止损，移动止损）。所以，Ta-lib是策略实现工具罢了。 此库中提供了多种技术分析的函数，有多种指标：ADX、MACD、RSI、布林轨道等；K线形态识别，如“黄昏之星”、“锤形线”等。 依靠此库对数据的分析，来下达发单撤单的动作即为策略。 策略示例：基于Talib模块的双指数均线策略`class TalibDoubleSmaDemo(CtaTemplate):` 就是两个指标的数据来判断当前局势罢了 设定策略参数 策略变量 参数列表（保存参数名称） 变量列表（保存变量名称） 步骤初始化策略（加载Bar数据）、启动策略、停止策略、收到行情Tick推送（计算K线）、收到Bar推送（缓存最新收盘价到列表 -&gt; 数量足够后转化为Numpy数组后传入talib函数SMA中计算 -&gt; 读取当前K线和上一根K线数值，用于判断均线交叉 -&gt; 检测持仓状态，做出相应交易动作） CTA回测_init_()的工作 本地停止单编号计数 self.stopOrderCount 本地停止单字典 self.stopOrderDict And self.workingStopOrderDict 设引擎类型为回测 回测相关变量定义 当前最新数据，用于模拟成交使用 运行回测 载入历史数据 根据回测模式确定要使用数据类 初始化策略 启动策略 回放数据（从数据库中取得推到newBar或者newTick） 策略获得新数据，执行相应操作 基于最新数据撮合限价单先确定会撮合成交的价格 -&gt; 遍历限价单字典中所有限价单 -&gt; 判断是否会成交 -&gt; 发生成交推送成交数据（买入 -&gt; 增加持仓 推送委托数据、从字典中删除该限价单） 计算原理 改版之后程序架构 APIs *** Trader CTP KSGold *** Common Condig Core Gateway Setting Strategy UI main CtpMdApi、CtpTdApi ………… ………… Md、Td ……………… ……………… CTA、HTA、引擎、事件管理 ……………… 配置文件 ……………… ……………… ……………… 事件引擎两版都一样，作为一个程序运行最外层的生成的实例，来进行各个实例之间的数据传输。因为每个实例都将数据在事件引擎中保存，调用事件引擎中的事件队列来对进行事件运行安排。 Like This： class A(object): &quot;&quot;&quot;docstring for A&quot;&quot;&quot; def __init__(self, name): super(A, self).__init__() self.name = name self.a = 0 def da(self): print self.name print self.a a = A(&#39;I am A&#39;) a.da() class B(object): &quot;&quot;&quot;docstring for B&quot;&quot;&quot; def __init__(self, aclass): super(B, self).__init__() self.aclass = aclass self.aclass.a += 1 def dada(self): self.aclass.da() b = B(a) b.dada() class C(object): &quot;&quot;&quot;docstring for B&quot;&quot;&quot; def __init__(self, aclass): super(C, self).__init__() self.aclass = aclass self.aclass.a += 1 def dada(self): self.aclass.da() c = C(a) c.dada() I am A 0 I am A 1 I am A 2 B与C分别在去改变读取在A中定义的数值。 嗯，没错，这么看的画确实时Python基础……所以没有这个基础的我看起来前期还挺费劲。当然，理解很好理解，就是在实现方法上不知原理的话就很难过。最主要的是，知道了原理在自己编写的时候可以的心用手，信手拈来。嗯~ o(￣▽￣)o就是这么写意和惬意。Indigo色在纯黑背景下不好辨识哈哈，还是换少女粉吧 Vn.Py 界面Icon 图标下载网: http://www.easyicon.net/ 界面设计文档功能要求连接、登陆，订阅，发撤单，持仓、账户信息、成交（下单时间、成交时间、备注（下单动作者））、保留交易模块、跟随鼠标点击更新交易模块中单子内容 文档编写步骤由需求确定功能，划分模块，模块关系，下分框架，框架实现 模块工具栏、行情显示、策略池、账户持仓、消息栏 工具栏连接（含各个端口） 风控、帮助、登陆状态显示 工具功能 工具名称 说明 备注 连接 弹出端口列表 通过复选框选中对应端口 风控 弹出设定列表 通过文本框输入设定数值 帮助 弹出帮助窗口 策略池 操作位置 热点操作 策略名称单元格 鼠标指针悬停 展开操作界面 动作按钮 鼠标单击 执行选中 动作按钮 鼠标右击 展开操作界面 消息栏分“成交”、“错误”、“日志”三个模块，选择相应模块显示对应内容 日志 错误 成交 时间、内容、接口 时间、错误代码、错误信息、接口 成交编号、委托编号、合约代码、名称、方向、开平、价格、成交量、成交时间、接口 显示操作日志 显示当前操作错误信息 显示成交单信息 账户持仓信息账户显示账户信息，并具备切换账户功能当前选中账户 显示在旁label中。 界面切换记录笔记照例，先贴网址： http://www.qaulau.com/books/PyQt4_Tutorial/index.html 窗口设置resize(8, 8) setWindowTitle(u&#39;标题&#39;) 获取图标def getIcon(filename): &quot;&quot;&quot; 获取图标 &quot;&quot;&quot; fileInfo = Qt.QFileInfo(filename) fileIcon = Qt.QFileIconProvider() icon = QtGui.QIcon(fileIcon.icon(fileInfo)) return icon 使用时： self.setWindowIcon(getIcon(&#39;../hi/app.ico&#39;)) DockwidgetTestM, dockTestM = self.createDock(AllMarketMonitor, vtText.“dock 标题”, QtCore.Qt.RightDockWidgetArea) # 方向有： RightDockWidgetArea,BottomDockWidgetArea,LeftDockWidgetArea # 创建dock窗口 # 可利用 self.tabifyDockWidget(dockMarketM, dockAllDataM) 来合并同一个方向上的dock # 此下还没看… dockTradeM.raise_() dockPositionM.raise_() # 连接组件之间的信号 widgetPositionM.itemDoubleClicked.connect(widgetTradingW.closePosition) # 保存默认设置 self.saveWindowSettings(&#39;default&#39;) 其实现函数为：“””创建停靠组件””” def createDock(self, widgetClass, widgetName, widgetArea): widget = widgetClass(self.mainEngine, self.eventEngine) dock = QtGui.QDockWidget(widgetName) dock.setWidget(widget) dock.setObjectName(widgetName) dock.setFeatures(dock.DockWidgetFloatable|dock.DockWidgetMovable) self.addDockWidget(widgetArea, dock) return widget, dock 再本质一点的东西为： widget1 = Ha(self) dock = QtGui.QDockWidget(&#39;haha&#39;) dock.setObjectName(&#39;ha1&#39;) dock.setWidget(widget1) dock.setFeatures(dock.DockWidgetFloatable | dock.DockWidgetMovable) self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock) 动作exit = QtGui.QAction(QtGui.QIcon(&#39;hello.ico&#39;), &#39;exit&#39;, self) exit.setShortcut(&#39;Ctrl+Q&#39;) exit.setStatusTip(&#39;Exit application&#39;) # 图标、文字、快捷键、提示信息 menubar = self.menuBar() file = menubar.addMenu(&#39;&amp;File&#39;) file.addAction(exit) # 创建目录和工具栏，将动作添加进去。工具栏同理 定位布局绝对定位label1 = QtGui.QLabel(u&#39;绝对定位&#39;, self) label1.move(15, 60) # 创建、移动到显示位置 框布局 及 布局元素平均分布okButton = QtGui.QPushButton(&quot;OK&quot;) cancelButton = QtGui.QPushButton(&quot;Cancel&quot;) # 创建按钮 hbox = QtGui.QHBoxLayout() hbox.addStretch(1) hbox.addWidget(okButton) # 增加组件 hbox.addWidget(cancelButton) # 创建水平栏 hbox.addStretch() # 平均分布 vbox = QtGui.QVBoxLayout() vbox.addStretch(1) # 创建竖列 vbox.addLayout(hbox) # 将水平栏插入竖列 self.setLayout(vbox) # 显示最终竖列 注意一下add时选择对类型就好了。 组件之间连接信号# classA(QtGui.QTableWidget): # pass classA.itemDoubleClicked.connect(classB.actionFunction) # 这样单纯调用还是可以的，但是数据传输… 就得继续研究一下了。 调用Windows程序import win32api path = &#39;D:/vnpy- \\ master/docker/dockerTrader/gateway/ctpGateway/CTP_connect.json&#39; win32api.ShellExecute(0, &#39;open&#39;, &#39;notepad.exe&#39;, path, &#39;&#39;, 1) # 使用记事本打开此文件 Jsonwith open(&#39;D:/vnpy- \\ master/docker/dockerTrader/gateway/ctpGateway/CTP_connect.json&#39;, &#39;r&#39;) as f: setting = json.load(f) self.userID = str(setting[&#39;userID&#39;]) self.password = str(setting[&#39;password&#39;]) 关闭事件退出提示def closeEvent(self, event): reply = QtGui.QMessageBox.question(self, &#39;Message&#39;,&quot;Are you sure to quit?&quot;, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No) if reply == QtGui.QMessageBox.Yes: event.accept() else: event.ignore() 函数放置位置就是主窗口类下就好。 VS2015 快捷键Ctrl + k Ctrl + c # 多行注释 Ctrl + k Ctrl + u # 多行取消注释 鼠标事件pressmovereleasedoubleClickclicked()enterEvent 鼠标移入leaveEvent 鼠标移出回去看看具体函数 信号槽（传输额外参数）一般来说，比如一个按钮吧。 在链接点击信号与槽时buttonInit[i].clicked.connect(partial(self.init, i))就完事了。然而，当循环创建按钮，对应同样的槽函数，只是需要执行的变量有区别时，就需要传输额外的参数。这时，方法有二： 环境： python2.7.8 pyqt 4.11.1 一： 使用lambda表达式from PyQt4.QtCore import * from PyQt4.QtGui import * class MyForm(QMainWindow): def __init__(self, parent=None): super(MyForm, self).__init__(parent) button1 = QPushButton('Button 1') button2 = QPushButton('Button 1') button1.clicked.connect(lambda: self.on_button(1)) button2.clicked.connect(lambda: self.on_button(2)) layout = QHBoxLayout() layout.addWidget(button1) layout.addWidget(button2) main_frame = QWidget() main_frame.setLayout(layout) self.setCentralWidget(main_frame) def on_button(self, n): print('Button &#123;0&#125; clicked'.format(n)) if __name__ == \"__main__\": import sys app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() 解释一下，on_button是怎样处理从两个按钮传来的信号。我们使用lambda传递按钮数字给槽，也可以传递任何其他东西—甚至是按钮组件本身（假如，槽打算把传递信号的按钮修改为不可用） 二： 使用functools里的partial函数button1.clicked.connect(partial(self.on_button, 1)) button2.clicked.connect(partial(self.on_button, 2)) 《Rapid GUI Program with Python and QT》 P143例子。 from PyQt4.QtCore import * from PyQt4.QtGui import * from functools import partial import sys class Bu1(QWidget): def __init__(self, parent=None): super(Bu1, self).__init__(parent) #水平盒式布局 layout = QHBoxLayout() #显示 self.lbl = QLabel('no button is pressed') #循环5个按钮 for i in range(5): but = QPushButton(str(i)) layout.addWidget(but) #信号和槽连接 but.clicked.connect(self.cliked) #使用封装，lambda but = QPushButton('5') layout.addWidget(but) but.clicked.connect(lambda: self.on_click('5')) #使用个who变量，结果不正常，显示 False is pressed #but.clicked.connect(lambda who=\"5\": self.on_click(who)) #使用封装，partial函数 but = QPushButton('6') layout.addWidget(but) but.clicked.connect(partial(self.on_click, '6')) layout.addWidget(self.lbl) #设置布局 self.setLayout(layout) #传递额外参数 def cliked(self): bu = self.sender() if isinstance(bu, QPushButton): self.lbl.setText('%s is pressed' % bu.text()) else: self.lbl.setText('no effect') def on_click(self, n): self.lbl.setText('%s is pressed' % n) if __name__ == '__main__': app = QApplication(sys.argv) bu =Bu1() bu.show() app.exec_() 三：感谢来源 策略管理策略类，引擎，报单管理&amp;&amp;仓位管理 引擎引擎中将策略事件有序添加到事件引擎和主引擎中。 读取setting.json 文件对策略参数以及是否启用进行配置。设定日期。使用策略实例字典保存策略名与实例关系——并将此字典在推送字典中与tick数据ID对应（ID对多实例。）再有orderID与策略对应字典，用以推送order和trade数据计数本地停止单 、 持仓缓存字典 报单管理成交推送处理成交回调 - &gt; 订单ID和策略对应字典 -&gt; 计算策略持仓（根据策略方向，持仓增加交易笔数）-&gt; 更新持仓缓存数据 报单者类单一合约订单缓存类——初始化buffer 存储字典_log策略日志存储","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"python","slug":"note/python","permalink":"https://ianvzs.github.io/categories/note/python/"},{"name":"learning","slug":"note/python/learning","permalink":"https://ianvzs.github.io/categories/note/python/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"Vn.Py","slug":"Vn-Py","permalink":"https://ianvzs.github.io/tags/Vn-Py/"},{"name":"gui","slug":"gui","permalink":"https://ianvzs.github.io/tags/gui/"},{"name":"socket","slug":"socket","permalink":"https://ianvzs.github.io/tags/socket/"}]},{"title":"tips Of markdown","slug":"tips/tipsOfmarkdown","date":"2018-05-15T02:00:47.000Z","updated":"2022-06-15T07:32:39.336Z","comments":true,"path":"2018/05/15/tips/tipsOfmarkdown/","link":"","permalink":"https://ianvzs.github.io/2018/05/15/tips/tipsOfmarkdown/","excerpt":"","text":"Markdown Notes 📪 ##Test 二级标题 Now I will test the Markdown’s hobiy 二级Maybe is a nice way to impove my blog. 三级原来标题 要# 与正文隔开一个空格… ···print “hello Markdown”··· 欸？ 怎么回事？上面的文字莫非是用Tab能将其放到一个容器里？ 新的区块你好，这是我新创建的容器。 ———好吧，只有直接在标题之下的Tab才能创建 no~，在空行下面也是可以的。 &#97;&#x64;&#100;&#114;&#x65;&#x73;&#x73;&#x40;&#101;&#x78;&#x61;&#x6d;&#112;&#108;&#101;&#x2e;&#99;&#111;&#x6d; Markdown 字体颜色、流程图斜体*文字*：前后星号斜体 就像这样？ 流程图st=&gt;start: Starte=&gt;end: Endopl=&gt;operation: My Operationsub1=&gt;subroutine: My subroutinecond=&gt;condition: Yes or No?io=&gt;inputoutput: catch something 呃 流程图我不清楚，不过 字体颜色可以内嵌html：你好，我是红色吗?， 你好，我是自定义色吗?即 &lt;font color=red&gt;你好，我是红色吗?&lt;/font&gt; &lt;font color=#75362109&gt;你好，我是自定义色吗?&lt;/font&gt; 刚开始我还在好奇怎么三色RGB怎么变成四个了，原来起作用的还是三个，只不过markdown选择性忽略了多余的字节。😰 这段话的配置如下： &lt;font color=#ff36ff&gt;骚气的颜色~&lt;/font&gt; 超链接Super Link is me? Yes , you are successful link to Google.hk [Super Link is me?](https://www.google.com.hk) 表格 1 111 a 2 222 b 3 333 c 4 444 d 6 555 e 7 666 f 序列 这是第一行 这是第二行 第三 Like This 另种表现 实现方式 阿门@的用法@后跟随的关键字可以生成Github的搜索超链接 例如： @markdown 注释[^_^]: 这里是注释：这个是在制作ppt的时候来写注释的…… 毕竟在笔记里面写注释怕是失了智… 毕竟不会被显示出来… 不过因为上面也说了是支持html语法的。所以…… 1&lt;!-- 这里是注释 隐藏区域--&gt; 插入图片：只能插入网图… 关于``` 痛苦的进行中1(⊙﹏⊙)， ```这东西是用来标注代码开始的，然而在有的编辑器中，若不是以单独一行会识别为`，也就是对平常语句中的字符的修饰。但是hexo显然不这么认为，所以只好将之前使用```的地方都改成`了 【2018年5月18日 纪念我勤奋的修改史】","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"markdown","slug":"tip/markdown","permalink":"https://ianvzs.github.io/categories/tip/markdown/"},{"name":"learning","slug":"tip/markdown/learning","permalink":"https://ianvzs.github.io/categories/tip/markdown/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"markdown","slug":"markdown","permalink":"https://ianvzs.github.io/tags/markdown/"}]},{"title":"tip Of vim","slug":"tips/tipsOfvim","date":"2018-05-15T01:56:41.000Z","updated":"2022-06-15T07:32:39.336Z","comments":true,"path":"2018/05/15/tips/tipsOfvim/","link":"","permalink":"https://ianvzs.github.io/2018/05/15/tips/tipsOfvim/","excerpt":"","text":"Vim 使用除去“简便生活”里的几条配置，在纠结是否添加到别的地方，果然还是单独给vim一个使用手册比较好…… 注释12345# 注释1， 12s/^/#/g ---# 取消注释1， 12s/^#//g 其实 是vim中的 :s替换命令… 下方解释 或者，使用列编辑的模式: v、选择区域、ctrl q置行首、I插入#、Esc应用到全列 ctrl v、I、#、Esc 因为有的ctrl q或者ctrl v 不能用…… 取消，即使用上述方法选中行首，删除第一个字节即可了 替换1:s/oldWords/newWords/g g : 代表当前光标所在行。 由此可知: ^表行首标识符。 /^/表示行首的空字符。 而取消注释中的/^#/即表示行首的#，被//空字符所替换。 查找高亮12set hlsearchset nohlsearch 分屏实现 在外部使用-o or -O参数 内部split or vsplit 操作 移动光标 Ctrl + w hjkl 移动分区Ctrl + w HJKL 统一高度Ctrl + w = 改变高度Ctrl + w +- more and less阅读器~~~ 因为经常读大文件发现了这两个的无敌好处——快。 使用命令1234567891011121314151617catcat -b # 查看且标注行号-n # 同上，但也会显示空行行号more# - space 向下翻页# - Ctrl+F 同上# - b back 返回一页显示# - Ctrl+B 同上# - Enter 向下n行,默认1# - = 输出当前行号# - v 调用vi/vim# - !命令 调用shell 执行命令# - q 退出less Vi &amp;&amp; Vim三个模式: 命令模式 插入模式 Ex模式 para : 说明 o : 在当前行下面插入新空白行 dd : 删除当前一行。 u : 撤销一步操作 yy : 当前行-&gt;缓冲区 p : 缓冲区-&gt;光标之后插入 n+ y 当前及接下来n行-&gt;缓冲区 r : 替换当前字符 / : 查找关键字——支持汉字呐！难得 n : 上命令下切换 next Ex下: set number: 显示行号。（不过我已经改了配置文件，默认显示） ！+命令 代理执行系统命令。如ls cd sh 挂下编辑 显示系统命令行。 ctrl+d返回（PS:命令行下，这是关闭虚拟终端快捷键） tip:tail head 等查看命令可以和 &gt;&gt; 命令合用，将文件的首行或者结尾字添加到另一个文档～","categories":[{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"vim","slug":"tip/vim","permalink":"https://ianvzs.github.io/categories/tip/vim/"},{"name":"learning","slug":"tip/vim/learning","permalink":"https://ianvzs.github.io/categories/tip/vim/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"vim","slug":"vim","permalink":"https://ianvzs.github.io/tags/vim/"},{"name":"more","slug":"more","permalink":"https://ianvzs.github.io/tags/more/"},{"name":"less","slug":"less","permalink":"https://ianvzs.github.io/tags/less/"}]},{"title":"db数据库","slug":"notes/noteOfdbData","date":"2018-05-15T01:51:09.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2018/05/15/notes/noteOfdbData/","link":"","permalink":"https://ianvzs.github.io/2018/05/15/notes/noteOfdbData/","excerpt":"","text":"DB数据库 🖥 📊🖥 MongoDB笔记学习网站：http://www.runoob.com/mongodb/mongodb-tutorial.html (其学习教程还挺可观，很多，不过还不清楚好不好) 注意事项Mongo 数据库锁mongo只提供库级粒度锁，所以一个写操作锁定时，其他读写操作都等待… 所以这个导致了Mongo多线程写操作反而没有一个线程写来的快？ 前台建立索引时，Mongo需占用一个写锁（且不同上述、不会临时放弃） 为避免此问题需采用background方式 123db.posts.ensureIndex(&#123;user_id: 1&#125;) #此方式将引起全面战争db.posts.ensureIndex(&#123;user_id: 1&#125;， &#123;background: 1&#125;) # 这个就比较和平 操作命令简单记录创建、插入use DATABASE_NAME #如果数据库不存在，则创建数据库，否则切换到指定数据库。 show dbs #查看所有数据库“name size” 刚创建的数据库，如没有内容则不现实在其中 db.runoob.insert(&#123;&quot;name&quot;:&quot;教程&quot;&#125;) #插入数据 删除db.dropDatabase() #删除当前数据库，如未选择则删除test db.collection.drop() #删除集合 db.site.drop() #：如删除site集合 删除重复数据12delete from alarm_calendar where id not in (SELECT maxid from (SELECT MAX(id) as maxid, CONCAT(user_id,time,generic_name) as nameAndCode from alarm_calendar GROUP BY nameAndCode) t); 根据user_id, time, generic_name来打包重复，将重复数据删掉, 留下max，在自增里面即：最新数据 插入文档db.COLLECTION_NAME.insert(document) db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, description: &#39;MongoDB 是一个 Nosql 数据库&#39;, by: &#39;菜鸟教程&#39;, url: &#39;http://www.runoob.com&#39;, tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;], likes: 100 &#125;) #例如这样 db.col.find() #查看已插入文档 也可以将document=括号里要插入内容，然后插入document变量，效果一样。 3.2版本新加db.collection.insertOne() #向指定集合中插入一条文档数据 db.collection.insertMany() #向指定集合中插入多条文档数据 插入单条数据 var document = db.collection.insertOne(&#123;&quot;a&quot;: 3&#125;) document{ “acknowledged” : true, “insertedId” : ObjectId(“571a218011a82a1d94c02333”)} 插入多条数据 var res = db.collection.insertMany([&#123;&quot;b&quot;: 3&#125;, &#123;&#39;c&#39;: 4&#125;]) res{ “acknowledged” : true, “insertedIds” : [ ObjectId(“571a22a911a82a1d94c02337”), ObjectId(“571a22a911a82a1d94c02338”) ]} 更新、添加文档db.col.update(&#123;&#39;title&#39;:&#39;MongoDB 教程&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;&#125;) #更新标题 db.collection.save( #通过传入的文档来替换已有文档 &lt;document&gt;, &#123; writeConcern: &lt;document&gt; &#125;) 参数说明：document : 文档数据。writeConcern : 可选，抛出异常的级别。 eg： 实例中替换了 _id 为 56064f89ade2f21f36b03136 的文档数据： db.col.save(&#123; &quot;_id&quot; : ObjectId(&quot;56064f89ade2f21f36b03136&quot;), &quot;title&quot; : &quot;MongoDB&quot;, &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;, &quot;by&quot; : &quot;Runoob&quot;, &quot;url&quot; : &quot;http://www.runoob.com&quot;, &quot;tags&quot; : [ &quot;mongodb&quot;, &quot;NoSQL&quot; ], &quot;likes&quot; : 110 }) 导入csv文件mongoimport --db Trader_1Min_Db --collection Au(T+D) --type csv --file D:\\\\IFData\\\\md_Au(T+D)_20170101_20170531\\\\md_Au(T+D)_2017010301.csv --headerline --upsert --ignoreBlanks 注意需要另开一个命令行，在其中运行。2017-10-25T08:43:40.917+0800 E QUERY [thread1] SyntaxError: missing ; before statement @(shell):1:16 否则就是这个错误 -d 指定把数据导入到哪一个数据库中 -c 指定把数据导入到哪一个集合中 --type 指定导入的数据类型 csv/tsv 逗号或者tab分割值 --file 指定从哪一个文件中导入数据 --headerline 仅适用于导入csv,tsv格式的数据，表示文件中的第一行作为数据头 --upsert 以新增或者更新的方式来导入数据 --f 导入字段名 --ignoreBlanks 忽略空白符 导出mongoexport -d test -c students -o students.dat connected to: 127.0.0.1 exported 9 records # 指明导出格式为csv mongoexport -d test -c students --csv -f classid,name,age -o students_csv.dat connected to: 127.0.0.1 exported 9 records 添加db.collectionName.update(&#123;&#125;, &#123;$set:&#123;&#39;key&#39; : value&#125;&#125;, false, true); 改.update 更改字段名称db.CollectionName.update(&#123;&#125;, &#123;$rename : &#123;&quot;OldName&quot; : &quot;NewName&quot;&#125;&#125;, false, true) # false为如不存在update记录，是否插入新的纪录 # ture位置为更新全部数据，如设定false 则为只更新第一条 # 另外 没有输入名称时没有输全，也会显示查找，但不会执行更改 统配db.CollectionName.update(&lt;query&gt;, &lt;update&gt;,&#123;upsert : &lt;boolean&gt;, multi : &lt;boolean&gt;, writeConcern : &lt;document&gt;&#125;) # query : update 查找条件，类似sql update查询内where后面的 # update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查 #&gt;询内set后面的 # upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插 #&gt;入，默认是false，不插入。 # multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把 #&gt;按条件查出来多条记录全部更新。 # writeConcern :可选，抛出异常的级别。 egdb.col.update(&#123;&#39;title&#39;:&#39;MongoDB&#39;&#125;,&#123;$set:&#123;&#39;title&#39;:&#39;IamNewTitle&#39;&#125;&#125;) 删除文档remove()函数是用来移除集合中的数据。 db.collection.remove( &lt;query&gt;, &lt;justOne&gt; ) 2.6版以后db.collection.remove( &lt;query&gt;, &#123; justOne: &lt;boolean&gt;, writeConcern: &lt;document&gt; &#125;) 参数说明：query :（可选）删除的文档的条件。justOne : （可选）如果设为 true 或 1，则只删除一个文档。writeConcern :（可选）抛出异常的级别。 db.col.remove(&#123;&#125;) #删除所有 (就很恐怖) 查询文档 操作 格式 范例 RDBMS中的类似语句 等于 {&lt;key&gt;:&lt;value&gt;} db.col.find(&#123;&quot;by&quot;:&quot;教程&quot;&#125;).pretty() where by = &#39;教程&#39; 小于 {&lt;key&gt;:&#123;$lt:&lt;value&gt;}} db.col.find(&#123;&quot;likes&quot;:&#123;$lt:50&#125;&#125;).pretty() where likes &lt; 50 小于或等于 {&lt;key&gt;:&#123;$lte:&lt;value&gt;}} db.col.find(&#123;&quot;likes&quot;:&#123;$lte:50&#125;&#125;).pretty() … 大于 {&lt;key&gt;:&#123;$gt:&lt;value&gt;}} db.col.find(&#123;&quot;likes&quot;:&#123;$gt:50&#125;&#125;).pretty() … 大于或等于 {&lt;key&gt;:&#123;$gte:&lt;value&gt;}} db.col.find(&#123;&quot;likes&quot;:&#123;$gte:50&#125;&#125;).pretty() … 不等于 {&lt;key&gt;:&#123;$ne:&lt;value&gt;}} db.col.find(&#123;&quot;likes&quot;:&#123;$ne:50&#125;&#125;).pretty() where likes != 50 Andfind可以传入多个键(key),逗号隔开： db.col.find(&#123;key1:value1, key2:value2&#125;).pretty() db.col.find(&#123;&quot;by&quot;:&quot;教程&quot;, &quot;title&quot;:&quot;MongoDB &quot;&#125;).pretty() #类似于 WHERE by=&#39;教程&#39; AND title=&#39;MongoDB &#39; Ordb.test.find(&#123;$[&#123;key1:value1&#125;,(key2:value2)]&#125;).pretty() #注意小中大括号😰 db.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB &quot;&#125;]&#125;) And 与 Ordb.col.find(&#123;&quot;likes&quot;: &#123;$gt:50&#125;, $or: [&#123;&quot;by&quot;: &quot;教程&quot;&#125;,&#123;&quot;title&quot;: &quot;MongoDB &quot;&#125;]&#125;) #类似于（其中pretty()是显示样式） where likes&gt;50 AND (by = &#39;教程&#39; OR title = &#39;MongoDB ‘ 简写说明 $gt ——– greater than &gt; $gte ——— gt equal &gt;= $lt ——– less than &lt; $lte ——— lt equal &lt;= $ne ———– not equal != $eq ——– equal = Typedb.col.find(&#123;&quot;title&quot; : &#123;$type : 2&#125;&#125;) #获取“col”集合中title为String的数据 对照表： 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 Limit() Skip()方法db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(2) 参数说明： “title”后1为判断语句，表示是否只查询“title”内容0为否，显示这条的全部信息。_id的0亦为判断表示是否显示“_id”内容。limit为限制搜索信息条数。 db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).limit(1).skip(1) skip(NUMBER) #NUMBER为阶跃，即每隔几条数据来搜索 排序db.COLLECTION_NAME.find().sort(&#123;KEY:1&#125;) #KEY后数字可为1OR-1，升序OR降序 db.col.find(&#123;&#125;,&#123;&quot;title&quot;:1,_id:0&#125;).sort(&#123;&quot;likes&quot;:-1&#125; #按“likes”降序排序 MongoDB 索引 （建立索引干嘛……）ensureIndex() 方法db.COLLECTION_NAME.ensureIndex(&#123;KEY:1&#125;) # Key 值为要创建的索引字段，1为指定按升序创建索引，降序-1 聚合aggregate()方法db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : 1&#125;&#125;&#125;]) #类似于 select by_user, count(*) from mycol group by by_user 输出结果：{ “_id” : “Neo4j”, “num_tutorial” : 1 }{ “_id” : “runoob.com”, “num_tutorial” : 2 }{ “_id” : null, “num_tutorial” : 1 } 参数说明：“$by_user” 即为分类依据，并打印出来（如上）。num_tutorial 仅为显示提示，可以更改为任意提示甚至汉字。$sum : 1 其中1为每次计数值，即重复一次加几。1+1+1+1…… ：重复一次加1；0.1+0.1+0.1……重复一次加0.1。这个意思 计算符： 表达式 描述 实例 $sum 计算总和。 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : &quot;$likes&quot;&#125;&#125;&#125;]) $avg 计算平均值 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$avg : &quot;$likes&quot;&#125;&#125;&#125;]) $min 获取集合中所有文档对应值得最小值。 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$min : &quot;$likes&quot;&#125;&#125;&#125;]) $max 获取集合中所有文档对应值得最大值。 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$max : &quot;$likes&quot;&#125;&#125;&#125;]) $push 在结果文档中插入值到一个数组中。 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$push: &quot;$url&quot;&#125;&#125;&#125;]) $addToSet 在结果文档中插入值到一个数组中，但不创建副本。 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$addToSet : &quot;$url&quot;&#125;&#125;&#125;]) $first 根据资源文档的排序获取第一个文档数据。 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, first_url : &#123;$first : &quot;$url&quot;&#125;&#125;&#125;]) $last 根据资源文档的排序获取最后一个文档数据 db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, last_url : &#123;$last : &quot;$url&quot;&#125;&#125;&#125;]) 条件操作符$gt 大于 $lt 小于 $gte 大于等于 $lte 小于等于 eg：db.col.find(&#123;likes : &#123;$gte : 100&#125;&#125;) # 查询“col”集合中&quot;likes&quot;大于100的数据 # 比较与 `SQL Select * from col where likes &gt;=100;` 取前n条数据.find().limit(n) 执行顺序skip(), limilt(), sort()三个放在一起执行的时候，执行的顺序是先 sort(), 然后是 skip()，最后是显示的 limit()。 数据导出mongoexport -d *** -c *** -o *** # -d 后为 dbName -c 后为 collectionName -o 后为 outputFileName 导出文件名 名字都不用加引号，直接上的~， 然后导出格式都是json 那样，不管后缀是什么用文本打开都是一个样子——骗鬼👻 数据导入 mongoimport -h 127.0.0.1 -p 27017 -d Trader_1Min_Db -c ag1806 --file /home/ian/Downloads/ag1806.json Linux 下使用Robo3T错误错误最后字段为：已放弃 (核心已转储) mkdir ~/robo-backup mv robo3t-1.1.1-linux-x86_64-*/lib/libstdc++* ~/robo-backup/robo3t-1.1.1-linux-x86_64-*/bin/robo3t 移动备份之后即可运行 For PythonPyMongofrom pymongo import MongoClient client = MongoClient(&quot;localhost&quot;, 27017) client.server_info() # 查看信息，检测是否成功连接 db = client[&quot;someData&quot;] collection = db.zn1801_30Min # 两种命名方式，一种是直接. 一种是使用“” 乖乖的用双引号，因为，在这里的单双引号是区分的… 我现在也懒得去管它是字符字符串的什么鬼。┏┛墓┗┓…(((m -__-)m insertcollection.insert( &#123;&quot;name&quot;:&quot;text&quot; &#125; ) findd = &#123;u&#39;Volume&#39;:&#123;&#39;$gte&#39;:50353,&#39;$lte&#39;:50355&#125;&#125; a = collection.find(d) 最小与最大，另外，find出来的东西是数据库指针，需要用for...in...来循环取出内容来 查询库名from pymongo import MongoClient client = MongoClient(&#39;localhost&#39;, 27017) client.database_names() [u’Trader_1Min_Db’, u’Trader_30Min_Db’, u’Trader_Tick_Db’, u’VnTrader_Log_Db’, u’VnTrader_Position_Db’, u’admin’, u’local’, u’someData’, u’test’] 查询集合名collectionNames = client[dbName].collection_names() print collectionNames 使用其读写速度还是可以的… 二十万条数据查询的话不到一秒，然而… 频繁多量的读取，再加上不断地往其中写入就出问题了…… 卡的极慢…简直恐怖（数个小时的延迟 怕不怕）。（当然以上情况是完全没有做任何优化的情况（直接insert 、find），不知道优化之后会怎样） 另外不知道不增加条数，去增加内容会怎样…… emm 果然还是缓存比较好用…在高速多量多频次的情况下还是用内存里面不去手动做任何保存比较好。 等积攒够量之后再去保存，就好比文件压缩不去一个个小文件传输一个道理。 MySQLMySQL 8.0因为在更新8.0 之后更改了用户密码加密形式所以在使用客户端连接的时候会出现错误，所以需要 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER; #修改加密规则 ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;password&#39;; #更新用户的密码 FLUSH PRIVILEGES; #刷新权限 经此步骤，就可以将密码加密形式改为图形化客户端支持的加密形式，也或者更待客户端跟着服务端同步更新。 另外，配置之初，windows 中配置步骤如下： 添加系统环境变量path 为MySQL/bin 初始化 mysqld --initialize --user=mysql --console 根据初始化随机生成密码登陆 修改密码 emm 这里说的是在外部，当然也可以在修改加密形式的时候一并修改 😄 mysqladmin -u root -p password 添加系统服务 mysqld -install 启动服务 net start mysql 另外在图像化里面注意密码格式呦，还有使用navicat的话需要最新版本，否则无法设置加密格式，还得用命令行去修改……果然还是命令行永远最好用 updateMySQL的update在被更新数值和更新传入数值相同时，执行速度相当的快，据说是mysql并不会执行更新动作但是它晓得更新动作的发生 MySQL 中文乱码需要在连接时就指定✱charset✲ 而不该一味纠结于在程序在存储时的数据准备此处使用的是 charset=&#39;gb2312&#39; 另外，干脆就在数据库中设置存为 blob 格式 连接远程 win 数据库123456789开启某端口的示例：添加防火墙例外端口## 导出表记录[^_^] 2021-04-22 看了上面,深表惭愧...```bashmysql -uuser -ppasswd -hhost -e &quot;use db_name; select * from table_name where chat_id in (...);&quot; &gt;&gt; hello2.csv 在bash中直接执行sql语句，重定向保存 好处可以规避 into outfile 的权限问题，导出的东西用csv也是可以看的，分隔符得以保留，csv可以正常阅览 注意点只不过有,时分隔符可能有些问题，全文替换了就好 入站规则设置第一步 选择 入站规则 然后 新建规则，选择 端口，然后下一步 第二步 选择TCP 选择特定端口 然后输入端口，如有多个端口需要用逗号隔开了 例如: 3306第三步 选择允许连接第四步 选择配置文件 第五步 输入规则名称 mysqlport 出站规则设置第一步 选择出站规则 然后 新建规则，选择 端口，然后下一步 第二步 选择TCP 选择特定端口 然后输入端口，如有多个端口需要用逗号隔开了 例如: 3306第三步 选择允许连接第四步 选择配置文件 第五步 输入规则名称 mysqlport（或者无特殊要求下直接关闭防火墙） 12345678910111213141516171819202122232425262728293031323334353637383940---------# 数据迁移因为已有从数据库中读取数据进行返回的函数，所以没有必要再去写读取数据库的步骤（也没法写，因为数据库设计混乱，分不清哪儿是哪儿只有通过其对外函数才能取对相应数据）但对外其是将一段时间内数据全部读取并且打包为`json`返回，所以一次性的话将是极大的一个文件，所以解决方法有：- 阅读其中源码，返回相应数据库指针，以此取出一个迁移一个- 编写分段读取函数，保证每次取出的数据不多，一段一段的迁移反正我是采用`一段一段`了，毕竟源码太… 另外，一段一段的话打好日志，出现问题后可以分段纠正，也能间歇运行，另外下载好再迁也保证了数据emm，考虑如上## 简单总结- 数据迁移程序- 数据检验补差程序- 断点运行机制```md# 初始化1. 读取配置文件（其中保存* 数据迁移顺序——列表（内元素为字典key为* value为相应数据库、表名， 时间起止，一次插入的时间跨度） ）2. 根据移植顺序读取目标数据库中相应数据的最新数据日期（* 若为空开始则开始插入）* 删除此日期的所有数据，* 根据一次插入的时间跨度以及终点生成时间区间* 根据时间区间去移植数据3. 当此类型数据移植完毕之后删除配置文件中列表的相应元素# 执行动作是## 日志将每一步的重要信息都打印~","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"db","slug":"note/db","permalink":"https://ianvzs.github.io/categories/note/db/"},{"name":"learning","slug":"note/db/learning","permalink":"https://ianvzs.github.io/categories/note/db/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"mongo","slug":"mongo","permalink":"https://ianvzs.github.io/tags/mongo/"},{"name":"mysql","slug":"mysql","permalink":"https://ianvzs.github.io/tags/mysql/"}]},{"title":"new Things","slug":"newThings","date":"2017-08-15T02:26:09.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2017/08/15/newThings/","link":"","permalink":"https://ianvzs.github.io/2017/08/15/newThings/","excerpt":"","text":"评测 Sony XZ1 Compact标题：小三验正妻 Sony XZ1 Compact 评测国外手机谈体验，国内手机堆配置… 3D Creator 支持列表https://forum.xda-developers.com/android/apps-games/app-sony-3d-creator-t3669576/amp/ 外观浅谈大家好，我是谷歌娘。由于up主的舌头废了，所以评测就由我来解说，希望大家能够喜欢~ 颜色：这次索尼的Xperia XZ1 Compact，有白、黑、红、蓝，四种颜色，各个地方叫法各异月银、鉑銀，夜黑、魅黑都有的叫。不过从官网宣传片来看，霞粉是真的了，但其实说粉…它并不像XZ1的粉的这么明显，而是平时感觉更深，有时觉的好像砖红，有时又觉得其实还挺嫩，但到晚霞铺满之际它有完美嵌入，没错，它会变色…… 最惊艳的还是点亮屏幕解锁的那一刻，屏幕于边色融为一体，或许这才是合一设计。 形状：与Z3 Compact相比较，边角方正，除了角角硌手之外，边缘要比Z3C圆润，也舒服一些。至于布局，一切就如视频所示了。 续航：在up主打开流量没有关闭我家全家桶的情况下，依然用了三十多个小时，不过up也什么国产软件都没装，只装了鹅信，其他常用都在小三里。在使用的第三天，一天下来50%，也是一天流量，没禁用谷歌服务，VnPnNn经常挂一会儿会断…考虑晚上不掉电，所以关闭谷歌或者科学用网的话两天一夜还是妥妥的。为了验证这个想法，up主第二天就这么拿着仅剩40%电量的手机一早出了门…不过因为没戴现金，所以为了能够活着回来，up仅在扫码支付的时候打开流量，中午，又连无线看了看新闻，聊了聊鹅信。到了下午，掉到了15%启用了省电模式，然后待机，结果三个小时过去直到晚上回来八点愣是只掉了不到3%的电量。所以，两天一夜一冲是真心没有问题的。 不过由于每个人使用方式不一样，也有人可能半天就用完，或者玩游戏几个小时耗光。那这个手机能做的就只是在你使用的时候根据你的习惯准确的预报它还能撑多长时间。 功能：首先令up主难过的就是文件管理器没有了自建局域网传输文件到电脑的功能，虽说之前那个File Commander有广告，功能也多。而现在简洁了，却砍掉了up最常用也最喜欢的功能。Multi camera，在up主终于买了两个索尼手机的时候，可以使用此功能的时候，居然没了，哈哈哈——然后就是下拉列表里电池没法儿点，不像这Z3可以直接点电池去设置电池优化方案。最后就是在使用小程序里的扫码时，第一次打开出现画面扭曲的现象，想扫码骑个车吧，在那儿找二维码就得半天，而且对的越准越打不开。解决方法呢，也很简单，就是点击扫码界面里的显示我的二维码，然后再退回来就可以了。这么往返了两次，之后扫码居然正了。不知道是小程序增加了安卓8的支持还是就如索尼官网所说，使用时间越久越懂你，如果是后者那就厉害了。不过才不可能哈哈哈。 拍照：拍照方面肯定是不虚XZP的，而关于XZP网上评测很多，所以就不多说了，但今晚，令up注意到了惊艳的东西——就是120°广角啊~ 虽说拍照时up极为羞耻，路人也多所以基本是手机划过，瞬间拍照的，在背光的情况下人脸依然被照的这么清楚，还是很难得的。 在官网上高挂“超级慢动作摄影”、预测拍摄、追焦对焦连拍。可我找了这么长时间依然没有找懂啊预测拍摄那个拍完分四个照片的功能……莫非还是得用那个应用？ 音量对比：这次XZ1 Compact如果我说别的都有别人反驳，那么这次音量的提升是真的提升了！简直可以一改当初被室友各种宿舍外放歌曲压制的局面，真的不像日系手机。 下面是Z3C 和 XZ1C播放视频的对比。大家忽视色彩…因为拿红米1S录得，它看见粉色就跟着把画面一起抹红了，其实人眼看起来up觉得比Z3C要更舒服。另外，视频加载速度是因为挂了不同的梯子，并不是手机原因。 大家听音量就好了。","categories":[{"name":"new Things","slug":"new-Things","permalink":"https://ianvzs.github.io/categories/new-Things/"},{"name":"手机","slug":"new-Things/手机","permalink":"https://ianvzs.github.io/categories/new-Things/%E6%89%8B%E6%9C%BA/"}],"tags":[{"name":"Sony XZ1 Compact","slug":"Sony-XZ1-Compact","permalink":"https://ianvzs.github.io/tags/Sony-XZ1-Compact/"}]},{"title":"机器学习库","slug":"notes/noteOfmachineLearning","date":"2017-07-24T10:40:00.000Z","updated":"2022-06-15T07:32:39.334Z","comments":true,"path":"2017/07/24/notes/noteOfmachineLearning/","link":"","permalink":"https://ianvzs.github.io/2017/07/24/notes/noteOfmachineLearning/","excerpt":"","text":"Python 机器学习库 👽Plotly与matplotlib 都是绘图工具，不过效果炫一些，我也没画过，所以只放链接，不放实例了 Plotly Python Library : https://plot.ly/python/ matplotlibimport matplotlib.pyplot as plt 参数等太多，链接最可靠pyplot参数 还是粘一些常用的： marker 属性（下面写在分号里呦） o . v ^ &lt; &gt; 1 2 3 4 8 s p * h H + x D d | _ 之类 画出一些“花儿” 绘图plt.plot(x, y) # 在y之后可添加参数，例如常用的label = ‘IamLabel’之类 # 线的样式、颜色 ：b: blue g: green r: red c: cyan m: magenta y: yellow k: black w: white &#39;-&#39; : solid , &#39;--&#39; : dashed, &#39;-.&#39; : dashdot &#39;:&#39; : dotted &#39; &#39;&#39;, &#39; &#39; &#39;: None # 粗细 lw=3 更改数字 # 数值折点显示样式 marker = ‘o’ plot.show() 绘制图表1plt.figure(1) 绘图 plt.figure(2) 绘图 2（未测试）plt.figure(1) # 创建图表1 plt.figure(2) # 创建图表2 hi1 = plt.subplot(211) # 在图表2中创建子图1 hi2 = plt.subplot(212) # 在图表2中创建子图2 一表多图pCapital = plt.subplot(4, 1, 1) pCapital.set_ylabel(&quot;capital&quot;) pCapital.plot(d[&#39;capitalList&#39;], color=&#39;r&#39;, lw=0.8) plt.show() 标注点eg1for w, m in enumerate(self.lowestPrice): if w % 120*10 == 0: plt.plot([w, w], [m, self.highestPrice[w]], linestyle = &#39;--&#39;) #plt.scatter(self.dealPoints,color = &#39;c&#39;) for i in self.dealPoints: plt.scatter([i[0]], [i[1]], color = &#39;c&#39;) for ii in self.ydealPoints: plt.scatter([ii[0]], [ii[1]], color = &#39;m&#39;) plt.title(&#39;Tick &amp; TradePoint&#39;) plt.legend() plt.show() plt.legend() # show() 之前不加这句是不会显示出标注的呦 eg2(还不晓得咋回事儿)import numpy as np t = 2 * np.pi / 3 plt.plot([t, t], [0, np.cos(t)], color=&#39;blue&#39;, linewidth=2.5, linestyle=&quot;--&quot;) plt.scatter([t, ], [np.cos(t), ], 50, color=&#39;blue&#39;) plt.annotate(r&#39;$sin(\\frac&#123;2\\pi&#125;&#123;3&#125;)=\\frac&#123;\\sqrt&#123;3&#125;&#125;&#123;2&#125;$&#39;, xy=(t, np.sin(t)), xycoords=&#39;data&#39;, xytext=(+10, +30), textcoords=&#39;offset points&#39;, fontsize=16, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) plt.plot([t, t],[0, np.sin(t)], color=&#39;red&#39;, linewidth=2.5, linestyle=&quot;--&quot;) plt.scatter([t, ],[np.sin(t), ], 50, color=&#39;red&#39;) plt.annotate(r&#39;$cos(\\frac&#123;2\\pi&#125;&#123;3&#125;)=-\\frac&#123;1&#125;&#123;2&#125;$&#39;, xy=(t, np.cos(t)), xycoords=&#39;data&#39;, xytext=(-90, -50), textcoords=&#39;offset points&#39;, fontsize=16, arrowprops=dict(arrowstyle=&quot;-&gt;&quot;, connectionstyle=&quot;arc3,rad=.2&quot;)) 坐标标签显示方案plt.setp(plt.gca().get_xticklabels(), rotation=20, horizontalalignment=&#39;right&#39;) # 貌似除了角度和right，没有了修改内容 来画一个动态图吧（感觉没啥作用所以就小标题了）import matplotlib.pyplot as plt from matplotlib.patches import Circle import numpy as np import math plt.close() #clf() # 清图 cla() # 清坐标轴 close() # 关窗口 fig=plt.figure() ax=fig.add_subplot(1,1,1) ax.axis(&quot;equal&quot;) #设置图像显示的时候XY轴比例 plt.grid(True) #添加网格 plt.ion() #interactive mode on打开交互模式 而不是plt.show() IniObsX=0000 IniObsY=4000 IniObsAngle=135 IniObsSpeed=10*math.sqrt(2) #米/秒 print(&#39;开始仿真&#39;) try: for t in range(180): #障碍物船只轨迹 obsX=IniObsX+IniObsSpeed*math.sin(IniObsAngle/180*math.pi)*t obsY=IniObsY+IniObsSpeed*math.cos(IniObsAngle/180*math.pi)*t ax.scatter(obsX,obsY,c=&#39;b&#39;,marker=&#39;.&#39;) #散点图 #ax.lines.pop(1) 删除轨迹 #下面的图,两船的距离 plt.pause(0.1) except Exception as err: print(err) pandasDataFrameimport pandas as pd import numpy as np a = &#123;&#39;a&#39;:[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;], &#39;b&#39;:[1,2,3], &#39;c&#39;:[&#39;lo&#39;, &#39;hel&#39;, &#39;hi&#39;], &#39;d&#39;:[7,8,9]&#125; df = pd.DataFrame(a) # 字典转换为dataFrame（每一个Key 和 Value构成一列，key为列标） df = df.set_index(&#39;a&#39;) # 将‘a‘列设置为行标 sr = pd.Series(a) sr2 = df[&#39;b&#39;] df[[&#39;b&#39;,&#39;c&#39;]].to_records()[1][&#39;b&#39;] df[[&#39;b&#39;,&#39;c&#39;]] columns index列，参数(行) 取用方法1dfValue.loc[indexKey][colKey] 一个将DataFrame字符串化之后重新解析的程序😓12345678910111213141516171819def parseSTR(self, _str, indexKey, colKey, setIndexNum=0, setColNum=0): &quot;&quot;&quot; 通过setIndexNum来确定第几列数据为行标题， setColNum确定使用第几行数据作为列标题 返回通过indexKey行标题 与 colKey列标题 确定的结果 &quot;&quot;&quot; rows = _str.split(&#x27;\\n&#x27;) columns = rows[0].split(&#x27;,&#x27;)[1:] tempRow = [] index = [] for row in rows[1:]: if len(row): index.append(row.split(&#x27;,&#x27;)[setIndexNum]) tempRow.append(row.split(&#x27;,&#x27;)[1:]) dfValue = pd.DataFrame(tempRow, index=index, columns=columns) try: return dfValue.loc[indexKey][colKey] except: print u&#x27;【error:】信息不全&#x27; return None Emm,有点儿… 嗯… 嗯…[^_^]: 2018年6月21日17点17分 numpyrandomrandom.seed(int类型) # 理解可以为设定开始随机的开始，也就是说每次设定之后再开始取值就会得到相同的随机数() 即 np.random.seed(1) np.random.random(1) np.random.seed(1) np.random.random(1) array([ 0.417022]) array([ 0.417022]) 标准差a = np.arange(10) np.std(a) a.std() 样本标准差a.std(ddof = 1) np.std(a, ddof = 1) 以上 a.std 只有当a为&lt;type ‘numpy.ndarray’&gt; 即用numpy生成的矩阵，array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])才可有，如果是python的列表list 则只能用np.std 来算 scikit-learnOpenCVInsatllcaffe： sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev libhdf5-serial-dev protobuf-compiler sudo apt-get install --no-install-recommends libboost-all-dev sudo apt-get install libatlas-base-dev sudo apt-get install libgflags-dev libgoogle-glog-dev liblmdb-dev PILhis = im.histogram() values = {} for i in range(256): values[i] = his[i] for j,k in sorted(values.items(),key=lambda x:x[1],reverse = True)[:10]: print j,k 爬虫 先链接 为实例视频教程，貌似不错，还没看。 问题虽然, 以前已经积累了一些东西, 知道 headers cookie啥的, 但今天突然碰到了这个报错: Caused by SSLError(SSLError(“bad handshake: Error([(‘SSL routines’, ‘tls_process_server_certificate’, ‘certificate verify failed’)]) 没见过, 之后碰到其余, 统一汇总在此. SSLError HTTPS有人指点到: 因用https的缘故, 其中报 verify failed 所以可以通过 1requests.get(url, verify=False) 将verify关闭可通过. Selenium从网页粘来的，下方有作者以及来源链接，格式就保留原有不改了…1、基本使用from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.support.wait import WebDriverWait browser = webdriver.Chrome()browser.get(‘https://www.taobao.com/&#39;) 显示等待10swait = WebDriverWait(browser, 10) 等待直到元素加载出input = wait.until(EC.presence_of_element_located((By.ID, ‘q’))) 等待直到元素可点击button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, ‘.btn-search’)))print(input, button)from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWait 创建一个浏览器对象browser = webdriver.Chrome()try: # 开启一个浏览器并访问https://www.baidu.com browser.get(‘https://www.baidu.com&#39;) # 在打开的网页响应中根据id查找元素 获取到查询框 input = browser.find_element_by_id(‘kw’) # 向查询框中输入Python input.send_keys(‘Python’) # 模拟回车 input.send_keys(Keys.ENTER) # 显示等待， 等待10秒 wait = WebDriverWait(browser, 10) # 显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常 wait.until(EC.presence_of_element_located((By.ID,’content_left’))) # 输出当前的url print(browser.current_url) # 输出Cookies print(browser.get_cookies()) # 输出页面响应内容 print(browser.page_source)finally: pass # 关闭浏览器 browser.close()2、Selenium声明浏览器对象from selenium import webdriver browser = webdriver.Chrome()browser = webdriver.Firefox()browser = webdriver.Edge()browser = webdriver.PhantomJS()browser = webdriver.Safari()3、查找元素3.1、查找单个元素from selenium import webdriver 申明一个浏览器对象browser = webdriver.Chrome() 使用浏览器访问淘宝browser.get(‘https://www.taobao.com&#39;) 在响应结果中通过id查找元素input_first = browser.find_element_by_id(‘q’) 在响应结果中通过css选择器查找元素input_second = browser.find_element_by_css_selector(‘#q’) 在响应结果中通过xpath查找元素input_third = browser.find_element_by_xpath(‘//*[@id=”q”]’)print(input_first)print(input_second)print(input_third)browser.close()find_element_by_name 通过name查找find_element_by_xpath 通过xpath查找find_element_by_link_text 通过链接查找find_element_by_partial_link_text 通过部分链接查找find_element_by_tag_name 通过标签名称查找find_element_by_class_name 通过类名查找find_element_by_css_selector 通过css选择武器查找from selenium import webdriverfrom selenium.webdriver.common.by import By 申明一个浏览器对象browser = webdriver.Chrome() 使用浏览器访问淘宝browser.get(‘https://www.taobao.com&#39;) 第二种方式，通过使用By.xxx指定查找方式input = browser.find_element(By.ID,’q’)print(input)browser.close()3.2、多个元素from selenium import webdriverfrom selenium.webdriver.common.by import By 申明一个浏览器对象browser = webdriver.Chrome() 使用浏览器访问淘宝browser.get(‘https://www.taobao.com&#39;) 根据选择查找多个元素input_first = browser.find_elements_by_css_selector(‘.service-bd li’)input_second = browser.find_elements(By.CSS_SELECTOR,’.service-bd li’)print(input_first)print(input_second)browser.close()find_elements_by_namefind_elements_by_xpathfind_elements_by_link_textfind_elements_by_partial_link_textfind_elements_by_tag_namefind_elements_by_class_namefind_elements_by_css_selector4、元素交互操作对获取的元素调用交互方法 import timefrom selenium import webdriverfrom selenium.webdriver.common.by import By 申明一个浏览器对象browser = webdriver.Chrome() 使用浏览器访问淘宝browser.get(‘https://www.taobao.com&#39;) 根据ID查找元素input_search = browser.find_element(By.ID,’q’) 模拟输入PSV到输入框input_search.send_keys(‘PSV’)time.sleep(2) 清空输入input_search.clear()input_search.send_keys(‘3DS’)button = browser.find_element(By.CLASS_NAME,’btn-search’) 模拟点击button.click()更多的操作 http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.remote.webelement5、交互动作from selenium import webdriverfrom selenium.webdriver import ActionChains browser = webdriver.Chrome()url = ‘http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#39;browser.get(url) 切换id为iframeResult的framebrowser.switch_to.frame(‘iframeResult’)source = browser.find_element_by_css_selector(‘#draggable’)target = browser.find_element_by_css_selector(‘#droppable’)actions = ActionChains(browser)actions.drag_and_drop(source, target)actions.perform()更多操作http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.common.action_chains6、执行JavaScriptfrom selenium import webdriver 申明一个浏览器对象browser = webdriver.Chrome()browser.get(‘https://www.zhihu.com/explore&#39;) 执行JavaScript脚本browser.execute_script(‘window.scrollTo(0, document.body.scrollHeight)’)browser.execute_script(‘alert(“To Bottom”)’)7、获取元素信息7.1、获取属性from selenium import webdriverfrom selenium.webdriver.common.by import By 申明一个浏览器对象browser = webdriver.Chrome()browser.get(‘https://www.zhihu.com/explore&#39;)logo = browser.find_element(By.ID,’zh-top-link-logo’) 获取属性print(logo.get_attribute(‘class’))print(logo)browser.close()7.2、获取文本值from selenium import webdriverfrom selenium.webdriver.common.by import By 申明一个浏览器对象browser = webdriver.Chrome()browser.get(‘https://www.zhihu.com/explore&#39;)submit = browser.find_element(By.ID,’zu-top-add-question’) 获取文本值print(submit.text)print(submit)browser.close()7.3、获取ID、位置、标签名、大小from selenium import webdriverfrom selenium.webdriver.common.by import By 申明一个浏览器对象browser = webdriver.Chrome()browser.get(‘https://www.zhihu.com/explore&#39;)submit = browser.find_element(By.ID,’zu-top-add-question’) 获取id 0.04584255991652042-1print(submit.id) 获取位置 &#123;‘y’: 7, ‘x’: 675&#125;print(submit.location) 获取标签名称 buttonprint(submit.tag_name) 获取大小 &#123;‘width’: 66, ‘height’: 32&#125;print(submit.size)browser.close()8、Framefrom selenium import webdriverfrom selenium.common.exceptions import NoSuchElementException browser = webdriver.Chrome()url = ‘http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#39;browser.get(url) 将操作的响应数据换成iframeResultbrowser.switch_to.frame(‘iframeResult’)source = browser.find_element_by_css_selector(‘#draggable’)print(source)try: logo = browser.find_element_by_class_name(‘logo’)except NoSuchElementException: print(‘NO LOGO’) 切换成父元素browser.switch_to.parent_frame()logo = browser.find_element_by_class_name(‘logo’)print(logo)print(logo.text)9、等待9.1、隐式等待当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常, 换句话说，当查找元素或元素并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是0from selenium import webdriver browser = webdriver.Chrome() 等待10秒browser.implicitly_wait(10)browser.get(‘https://www.zhihu.com/explore&#39;)input = browser.find_element_by_class_name(‘zu-top-add-question’)print(input)9.2、显示等待显式等待指定某个条件，然后设置最长等待时间。如果在这个时间还没有找到元素，那么便会抛出异常了。 from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWait browser = webdriver.Chrome()browser.get(‘https://www.taobao.com/&#39;) 显示等待10swait = WebDriverWait(browser, 10) 等待直到元素加载出input = wait.until(EC.presence_of_element_located((By.ID, ‘q’))) 等待直到元素可点击button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, ‘.btn-search’)))print(input, button)title_is 标题是某内容title_contains 标题包含某内容presence_of_element_located 元素加载出，传入定位元组，如(By.ID, ‘p’)visibility_of_element_located 元素可见，传入定位元组visibility_of 可见，传入元素对象presence_of_all_elements_located 所有元素加载出text_to_be_present_in_element 某个元素文本包含某文字text_to_be_present_in_element_value 某个元素值包含某文字frame_to_be_available_and_switch_to_it frame加载并切换invisibility_of_element_located 元素不可见element_to_be_clickable 元素可点击staleness_of 判断一个元素是否仍在DOM，可判断页面是否已经刷新element_to_be_selected 元素可选择，传元素对象element_located_to_be_selected 元素可选择，传入定位元组element_selection_state_to_be 传入元素对象以及状态，相等返回True，否则返回Falseelement_located_selection_state_to_be 传入定位元组以及状态，相等返回True，否则返回Falsealert_is_present 是否出现Alert更多操作http://selenium-python.readthedocs.io/api.html#module-selenium.webdriver.support.expected_conditions10、前进后退import timefrom selenium import webdriver browser = webdriver.Chrome()browser.get(‘https://www.baidu.com/&#39;)browser.get(‘https://www.taobao.com/&#39;)browser.get(‘https://www.python.org/&#39;)browser.back()time.sleep(1)browser.forward()browser.close()11、Cookiesfrom selenium import webdriver browser = webdriver.Chrome()browser.get(‘https://www.zhihu.com/explore&#39;) 获得cookiesprint(browser.get_cookies()) 添加cookiebrowser.add_cookie(&#123;‘name’: ‘name’, ‘domain’: ‘www.zhihu.com&#39;, ‘value’: ‘germey’&#125;)print(browser.get_cookies()) 删除所有cookiesbrowser.delete_all_cookies()print(browser.get_cookies())12、选项卡管理import timefrom selenium import webdriver browser = webdriver.Chrome()browser.get(‘https://www.baidu.com&#39;) 打开一个选项卡browser.execute_script(‘window.open()’)print(browser.window_handles) 选择第二个选项卡browser.switch_to_window(browser.window_handles[1])browser.get(‘https://www.taobao.com&#39;)time.sleep(1)browser.switch_to_window(browser.window_handles[0])browser.get(‘https://python.org&#39;)13、异常处理from selenium import webdriverfrom selenium.common.exceptions import TimeoutException, NoSuchElementException browser = webdriver.Chrome()try: browser.get(‘https://www.baidu.com&#39;)except TimeoutException: print(‘Time Out’)try: browser.find_element_by_id(‘hello’)except NoSuchElementException: print(‘No Element’)finally: browser.close()作者：蒋蜀黍 Python爱好者社区专栏作者 授权原创发布，请勿转载，谢谢。出处：Selenium 库学习笔记 TensorFlowVariable必须用到: ```init = tf.initialize_all_variables() #初始化全部变量 随后即可: ```sess.run(init) Tensorflow 笔记這是在對照官網學習時的前期入門筆記，其實和官網基本沒有區別，好吧，真的沒有區別。因爲官網真的寫的太好了。至於我爲什麼要寫出來，是因爲我之前寫在了紙上，對於邏輯的把握很給力，所以在寫一邊。 不過TensorFlow 變動真的很大，版本更迭也很快，所以，下方只是理清邏輯，具體的東西還是去官網比較好。只不過我這兒網謎之很難等上去… 總而言之一句話，先搭好架子再選擇填充材料。就是它的核心邏輯了。而改進也是在架子基礎上去優化優化器。嗯…現在理解就是這樣。 1导入import tensorflow as tf 步骤：①构建计算图 ②运行计算图 2Build a simple computational Graphnode1 = tf.contant(3.0, dtype = tf.float32) node2 = tf.contant(4.0) #also tf.float32 impicitly print (node1, node2) 输出为：Tensor (&quot;Cast: 0&quot;, shape = (), dtype = float) Tensor (&quot;Cast_1: 0&quot;, shape = (), dtype = float) 打印并不输出值3.0，4.0，而在评估时分别产生3.0和4.0节点。欲实际评估节点，We must run the computational graph within a session. A seesion encapsulation the control and state of the tensorflow runtime. 3Creates a session object , 然后调用run方法运行足够的computational graph to envlute node1 and node2sess = tf.Session() print (sess.run([node1, node2])) 输出为：[3.0, 4.0] #可见预期值 4We can build more complicated computations by combining Tensor nodes with operationsnode3 = tf.add(node1, node2) print (&quot;node3: &quot;, node3) print (&quot;sess.run(node3):&quot;, sess.run(node3)) 输出为：node3: Tensor(&quot;Add:0&quot;, shape = (1,dtype = float32)) sess.run(node3): 7.0 5更进一步的，A graph can be parameterized. To accept external input , 称为placeholdersa = tf.placeholder(tf.float32) b = tf.placeholder(tf.float32) adder_note = a + b #provide a shortcut for tf.add(a, b) and can with multiple input by using print (sess.run(add_note, &#123;a:3, b:4.5&#125;)) print (sess.run(add_note, &#123;a:[1, 3], b:[2, 4]&#125;)) 输出为：7.5 [3. 7.] 5.1more complex by adding anther aperation. for example:add_and_triple = adder_note * 3 print (sess.run(add_and_triple, &#123;a:3, b:4.5&#125;)) 输出为：22.5 In TensorBoard(Tensorflow圖形化界面): 图片.jpg 是下面a+b```` 然后连接到adder_node ,随后再连接到y(add_and_triple)``` 5.2That a model that can take arbitary inputs:To mode the modeel trainable,need to modify the graph to get new a outputs with the some input : Variables allow us:w = tf.Variables([ .3], dtype = tf.float32) b = tf.Variables([ - .3], dtype = tf.float32) x = tf.placeholder(tf.float32) linear_model = w * x + b #线性模型 6使用tf.constant :调用、初始化常数 用tf.Vaiables :變量不被初始化，調用欲初始化所有變量，必須calll a special operation:init = tf.global_variables_initializer() sess.run(init) 7x is a placeholder, we can evaluate lnear_model for several values of x simultaneausly as follow:print (sess.run(linear_model, &#123;x:[1,2,3,4]&#125;)) 輸出爲：[0. 0.30000001 0.60000002 0.90000004] 8有以上結果並不知好壞，因此編寫損失函數：y = tf.placeholder(tf.float32) squared_deltas = tf.square(linear_model - y) #平方（下方差和） loss = tf.reduce_sum(squred_deltas) #差和（上方平方） print (sess.run)loss, &#123;x:[1, 2, 3, 4], y:[0, -1, -2, -3]&#125;) 輸出爲：23.66 #損失值：差平方和 8.1We could improve this manually W,b to perfact values of -1 and 1. A variable is initializef to the value provided to tf.Variable but can be charged using operation like tf.assignW = -1 and b = 1 are optimal parameters:(最優參數)fixW = tf.assign(W, [-1. ]) fixb = tf.assign(b,[1. ]) sess.run(fixW, fixb) print(sess.run(loss, &#123;x:[1, 2, 3, 4], y:[0, -1, -2, -3]&#125;)) 輸出爲：0, 0 # The final print shows the loss now is zero ! 9模型保存与加载：保存：saver = tf.train.Saver() # 生成saver with tf.Session() as sess: sess.run(tf.global_variables_initializer()) # 先对模型初始化 # 然后将数据丢入模型进行训练blablabla # 训练完以后，使用saver.save 来保存 saver.save(sess, &quot;save_path/file_name&quot;) #file_name如果不存在的话，会自动创建 加载：saver = tf.train.Saver() with tf.Session() as sess: #参数可以进行初始化，也可不进行初始化。即使初始化了，初始化的值也会被restore的值给覆盖 sess.run(tf.global_variables_initializer()) saver.restore(sess, &quot;save_path/file_name&quot;) #会将已经保存的变量值resotre到 变量中。 10图形化操作：&gt;http://blog.csdn.net/u014595019/article/details/53912710 这篇写的还不错，等之后用过之后再写。 Variable必须用到: ```init = tf.initialize_all_variables() #初始化全部变量 随后即可: ```sess.run(init) Tensorflow 笔记這是在對照官網學習時的前期入門筆記，其實和官網基本沒有區別，好吧，真的沒有區別。因爲官網真的寫的太好了。至於我爲什麼要寫出來，是因爲我之前寫在了紙上，對於邏輯的把握很給力，所以在寫一邊。 不過TensorFlow 變動真的很大，版本更迭也很快，所以，下方只是理清邏輯，具體的東西還是去官網比較好。只不過我這兒網謎之很難等上去… 總而言之一句話，先搭好架子再選擇填充材料。就是它的核心邏輯了。而改進也是在架子基礎上去優化優化器。嗯…現在理解就是這樣。 1导入import tensorflow as tf 步骤：①构建计算图 ②运行计算图 2Build a simple computational Graphnode1 = tf.contant(3.0, dtype = tf.float32) node2 = tf.contant(4.0) #also tf.float32 impicitly print (node1, node2) 输出为：Tensor (&quot;Cast: 0&quot;, shape = (), dtype = float) Tensor (&quot;Cast_1: 0&quot;, shape = (), dtype = float) 打印并不输出值3.0，4.0，而在评估时分别产生3.0和4.0节点。欲实际评估节点，We must run the computational graph within a session. A seesion encapsulation the control and state of the tensorflow runtime. 3Creates a session object , 然后调用run方法运行足够的computational graph to envlute node1 and node2sess = tf.Session() print (sess.run([node1, node2])) 输出为：[3.0, 4.0] #可见预期值 4We can build more complicated computations by combining Tensor nodes with operationsnode3 = tf.add(node1, node2) print (&quot;node3: &quot;, node3) print (&quot;sess.run(node3):&quot;, sess.run(node3)) 输出为：node3: Tensor(&quot;Add:0&quot;, shape = (1,dtype = float32)) sess.run(node3): 7.0 5更进一步的，A graph can be parameterized. To accept external input , 称为placeholdersa = tf.placeholder(tf.float32) b = tf.placeholder(tf.float32) adder_note = a + b #provide a shortcut for tf.add(a, b) and can with multiple input by using print (sess.run(add_note, &#123;a:3, b:4.5&#125;)) print (sess.run(add_note, &#123;a:[1, 3], b:[2, 4]&#125;)) 输出为：7.5 [3. 7.] 5.1more complex by adding anther aperation. for example:add_and_triple = adder_note * 3 print (sess.run(add_and_triple, &#123;a:3, b:4.5&#125;)) 输出为：22.5 In TensorBoard(Tensorflow圖形化界面): 图片.jpg 是下面a+b```` 然后连接到adder_node ,随后再连接到y(add_and_triple)``` 5.2That a model that can take arbitary inputs:To mode the modeel trainable,need to modify the graph to get new a outputs with the some input : Variables allow us:w = tf.Variables([ .3], dtype = tf.float32) b = tf.Variables([ - .3], dtype = tf.float32) x = tf.placeholder(tf.float32) linear_model = w * x + b #线性模型 6使用tf.constant :调用、初始化常数 用tf.Vaiables :變量不被初始化，調用欲初始化所有變量，必須calll a special operation:init = tf.global_variables_initializer() sess.run(init) 7x is a placeholder, we can evaluate lnear_model for several values of x simultaneausly as follow:print (sess.run(linear_model, &#123;x:[1,2,3,4]&#125;)) 輸出爲：[0. 0.30000001 0.60000002 0.90000004] 8有以上結果並不知好壞，因此編寫損失函數：y = tf.placeholder(tf.float32) squared_deltas = tf.square(linear_model - y) #平方（下方差和） loss = tf.reduce_sum(squred_deltas) #差和（上方平方） print (sess.run)loss, &#123;x:[1, 2, 3, 4], y:[0, -1, -2, -3]&#125;) 輸出爲：23.66 #損失值：差平方和 8.1We could improve this manually W,b to perfact values of -1 and 1. A variable is initializef to the value provided to tf.Variable but can be charged using operation like tf.assignW = -1 and b = 1 are optimal parameters:(最優參數)fixW = tf.assign(W, [-1. ]) fixb = tf.assign(b,[1. ]) sess.run(fixW, fixb) print(sess.run(loss, &#123;x:[1, 2, 3, 4], y:[0, -1, -2, -3]&#125;)) 輸出爲：0, 0 # The final print shows the loss now is zero ! 9模型保存与加载：保存：saver = tf.train.Saver() # 生成saver with tf.Session() as sess: sess.run(tf.global_variables_initializer()) # 先对模型初始化 # 然后将数据丢入模型进行训练blablabla # 训练完以后，使用saver.save 来保存 saver.save(sess, &quot;save_path/file_name&quot;) #file_name如果不存在的话，会自动创建 加载：saver = tf.train.Saver() with tf.Session() as sess: #参数可以进行初始化，也可不进行初始化。即使初始化了，初始化的值也会被restore的值给覆盖 sess.run(tf.global_variables_initializer()) saver.restore(sess, &quot;save_path/file_name&quot;) #会将已经保存的变量值resotre到 变量中。 10图形化操作：&lt;http://blog.csdn.net/u014595019/article/details/53912710&gt; 这篇写的还不错，等之后用过之后再写。","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"learning","slug":"note/learning","permalink":"https://ianvzs.github.io/categories/note/learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ianvzs.github.io/tags/python/"},{"name":"ml","slug":"ml","permalink":"https://ianvzs.github.io/tags/ml/"}],"author":"Ian"},{"title":"图形化界面 （Python Gui）","slug":"notes/noteOfgui","date":"2017-07-01T13:20:00.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2017/07/01/notes/noteOfgui/","link":"","permalink":"https://ianvzs.github.io/2017/07/01/notes/noteOfgui/","excerpt":"","text":"author:Ian Python GUI 💽PyQt 官方说明文档：http://pyqt.sourceforge.net/Docs/PyQt4/index.html照例，先贴网址： http://www.qaulau.com/books/PyQt4_Tutorial/index.html 画界面#PyQt4使用designer.exe import os for root, dirs, files in os.walk(&#39;.&#39;): for file in files: if file.endswith(&#39;.ui&#39;): os.system(&#39;pyuic4 -o ui_%s.py %s&#39; % (file.rsplit(&#39;.&#39;, 1)[0], file)) elif file.endswith(&#39;.qrc&#39;): os.system(&#39;pyrcc4 -o %s_rc.py %s&#39; % (file.rsplit(&#39;.&#39;, 1)[0], file)) # 注：在Win中调用pyrcc4 可能无法识别该命令，即使添加到环境变量也不行，而是 #pyrcc.exe才能调用简直…… 窗口设置resize(8, 8) setWindowTitle(u&#39;标题&#39;) 获取图标def getIcon(filename): &quot;&quot;&quot; 获取图标 &quot;&quot;&quot; fileInfo = Qt.QFileInfo(filename) fileIcon = Qt.QFileIconProvider() icon = QtGui.QIcon(fileIcon.icon(fileInfo)) return icon 使用时： self.setWindowIcon(getIcon(&#39;../hi/app.ico&#39;)) DockwidgetTestM, dockTestM = self.createDock(AllMarketMonitor, vtText.“dock标题”, QtCore.Qt.RightDockWidgetArea) # 方向有： `RightDockWidgetArea`,`BottomDockWidgetArea`,`LeftDockWidgetArea` # 创建dock窗口 # 可利用 self.tabifyDockWidget(dockMarketM, dockAllDataM) 来合并同一个方向上的dock # 此下还没看… dockTradeM.raise_() dockPositionM.raise_() # 连接组件之间的信号 widgetPositionM.itemDoubleClicked.connect(widgetTradingW.closePosition) # 保存默认设置 self.saveWindowSettings(&#39;default&#39;) 其实现函数为：“””创建停靠组件””” def createDock(self, widgetClass, widgetName, widgetArea): widget = widgetClass(self.mainEngine, self.eventEngine) dock = QtGui.QDockWidget(widgetName) dock.setWidget(widget) dock.setObjectName(widgetName) dock.setFeatures(dock.DockWidgetFloatable|dock.DockWidgetMovable) self.addDockWidget(widgetArea, dock) return widget, dock 再本质一点的东西为： widget1 = Ha(self) dock = QtGui.QDockWidget(&#39;haha&#39;) dock.setObjectName(&#39;ha1&#39;) dock.setWidget(widget1) dock.setFeatures(dock.DockWidgetFloatable | dock.DockWidgetMovable) self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock) 动作exit = QtGui.QAction(QtGui.QIcon(&#39;hello.ico&#39;), &#39;exit&#39;, self) exit.setShortcut(&#39;Ctrl+Q&#39;) exit.setStatusTip(&#39;Exit application&#39;) # 图标、文字、快捷键、提示信息 menubar = self.menuBar() file = menubar.addMenu(&#39;&amp;File&#39;) file.addAction(exit) # 创建目录和工具栏，将动作添加进去。工具栏同理 定位布局绝对定位label1 = QtGui.QLabel(u&#39;绝对定位&#39;, self) label1.move(15, 60) # 创建、移动到显示位置 框布局 及 布局元素平均分布okButton = QtGui.QPushButton(&quot;OK&quot;) cancelButton = QtGui.QPushButton(&quot;Cancel&quot;) # 创建按钮 hbox = QtGui.QHBoxLayout() hbox.addStretch(1) hbox.addWidget(okButton) # 增加组件 hbox.addWidget(cancelButton) # 创建水平栏 hbox.addStretch() # 平均分布 vbox = QtGui.QVBoxLayout() vbox.addStretch(1) # 创建竖列 vbox.addLayout(hbox) # 将水平栏插入竖列 self.setLayout(vbox) # 显示最终竖列 注意一下add时选择对类型就好了。 QTableWidget#!/usr/bin/env python #coding=utf-8 from PyQt4.QtGui import * from PyQt4.QtCore import * class MyDialog(QDialog): def __init__(self, parent=None): super(MyDialog, self).__init__(parent) self.MyTable = QTableWidget(4,3) self.MyTable.setHorizontalHeaderLabels(['姓名','身高','体重']) newItem = QTableWidgetItem(&amp;quot;松鼠&amp;quot;) self.MyTable.setItem(0, 0, newItem) newItem = QTableWidgetItem(&amp;quot;10cm&amp;quot;) self.MyTable.setItem(0, 1, newItem) newItem = QTableWidgetItem(&amp;quot;60g&amp;quot;) self.MyTable.setItem(0, 2, newItem) layout = QHBoxLayout() layout.addWidget(self.MyTable) self.setLayout(layout) if name == ‘main‘: import sys app = QApplication(sys.argv) myWindow = MyDialog() myWindow.show() sys.exit(app.exec_()) &nbsp; 其中： self.MyTable = QTableWidget(4,3)&nbsp; 构造了一个QTableWidget的对象，并且设置为4行，3列self.MyTable.setHorizontalHeaderLabels(['姓名','身高','体重']) 则设置表格的表头newItem = QTableWidgetItem(&quot;松鼠&quot;)&nbsp;&nbsp; 则是生成了一个QTableWidgetItem的对象，并让其名为&ldquo;松鼠&rdquo;self.MyTable.setItem(0, 0, newItem)&nbsp;&nbsp;&nbsp; 将刚才生成的Item加载到第0行、0列处 &nbsp; 这样一个简单的QTableWidget就构造完成了。 感谢来源 以上。 之后的设置字体，底色，之类用的的时候再说。其中： 合并单元格效果的实现：self.MyTable.setSpan(0, 0, 3, 1) # 其参数为： 要改变单元格的 1行数 2列数 要合并的 3行数 4列数 表格表头的显示与隐藏self.MyTable.verticalHeader().setVisible(False) self.MyTable.horizontalHeader().setVisible(False) # 默认显示 且标号为： 1，2，3… 空位填补.addStretch() # 不过比较鸡肋，还是下面的调整窗口显示比例比较好玩 调整各部分显示比例QVBoxLayout* layout = new QVBoxLayout; QPushButton* btn = new QPushButton; QTableWidget* tableWidget = new QTableWidget; QHBoxLayout* h_layout = new QHBoxLayout; layout.addWidget(btn); layout.addWidget(tableWidget); layout.addLayout(h_layout) layout-&gt;setStretchFactor(btn, 1); layout-&gt;setStretchFactor(tableWidget, 2); layout-&gt;setStretchFactor(h_layout, 2); 上面是C++ 所以下面的是俺的Python： hbox1[i].addWidget(self.buttonBox[i]) hbox1[i].addWidget(self.paramMonitor[i]) hbox1[i].addWidget(self.varMonitor[i]) # 设置显示比例 hbox1[i].setStretchFactor(self.buttonBox[i], 3) hbox1[i].setStretchFactor(self.paramMonitor[i], 3) hbox1[i].setStretchFactor(self.varMonitor[i], 4) 列表内添加按钮1、定义添加按钮的方法 1 # 列表内添加按钮 2 def buttonForRow(self,id): 3 widget=QWidget() 4 # 修改 5 updateBtn = QPushButton('修改') 6 updateBtn.setStyleSheet(''' text-align : center; 7 background-color : NavajoWhite; 8 height : 30px; 9 border-style: outset; 10 font : 13px ''') 11 12 updateBtn.clicked.connect(lambda:self.updateTable(id)) 13 14 # 查看 15 viewBtn = QPushButton('查看') 16 viewBtn.setStyleSheet(''' text-align : center; 17 background-color : DarkSeaGreen; 18 height : 30px; 19 border-style: outset; 20 font : 13px; ''') 21 22 viewBtn.clicked.connect(lambda: self.viewTable(id)) 23 24 # 删除 25 deleteBtn = QPushButton('删除') 26 deleteBtn.setStyleSheet(''' text-align : center; 27 background-color : LightCoral; 28 height : 30px; 29 border-style: outset; 30 font : 13px; ''') 31 32 33 hLayout = QHBoxLayout() 34 hLayout.addWidget(updateBtn) 35 hLayout.addWidget(viewBtn) 36 hLayout.addWidget(deleteBtn) 37 hLayout.setContentsMargins(5,2,5,2) 38 widget.setLayout(hLayout) 39 return widget 2、在向tableWidget里添加数据时插入即可 1 for row_number, row_data in enumerate(rsdata): 2 self.ui.tableWidget.insertRow(row_number) 3 for i in range(len(row_data)+1): 4 if i&lt;len(row_data): 5 self.ui.tableWidget.setItem(row_number, i, QtWidgets.QTableWidgetItem(str(row_data[i]))) 6 # 添加按钮 7 if i==len(row_data): 8 # 传入当前id 9 self.ui.tableWidget.setCellWidget(row_number, i,self.buttonForRow(str(row_data[0]))) 效果图 就像以上显示的那样来源 值得注意的是，再排布的时候必须只有一个表格对其进行放置（也就是说指挥它去哪儿的只能有一个人），之前我为了测试，两个hbox 对其进行排版，简直…… labelSymbol = QtGui.QLabel(self.CtaEngine.strategyTickDict[self.name]) buttonInit[i] = QtGui.QPushButton(u&#39;初始化&#39;) buttonStart[i] = QtGui.QPushButton(u&#39;启动&#39;) buttonStop[i] = QtGui.QPushButton(u&#39;停止&#39;) buttonUpdate[i] = QtGui.QPushButton(u&#39;更新参数&#39;) buttonSave[i] = QtGui.QPushButton(u&#39;保存参数&#39;) buttonInit[i].clicked.connect(partial(self.init, i)) buttonStart[i].clicked.connect(partial(self.start, i)) buttonStop[i].clicked.connect(partial(self.stop, i)) buttonUpdate[i].clicked.connect(partial(self.updateParams,i)) buttonSave[i].clicked.connect(partial(self.saveParams, i)) hbox1[i] = QtGui.QHBoxLayout() ##参数设置显示 hbox2[i] = QtGui.QHBoxLayout() #hbox1[i].addWidget(labelSymbol) #hbox1[i].addWidget(buttonInit[i]) #hbox1[i].addWidget(buttonStart[i]) #hbox1[i].addWidget(buttonStop[i]) #hbox1[i].addWidget(buttonUpdate[i]) #hbox1[i].addWidget(buttonSave[i]) self.buttonBox[i].setCellWidget(0, 0, buttonInit[i]) self.buttonBox[i].setCellWidget(0, 1, buttonStart[i]) self.buttonBox[i].setCellWidget(0, 2, buttonStop[i]) 组件之间连接信号# classA(QtGui.QTableWidget): # pass classA.itemDoubleClicked.connect(classB.actionFunction) # 这样单纯调用还是可以的，但是数据传输… 就得继续研究一下了。 关闭事件退出提示def closeEvent(self, event): reply = QtGui.QMessageBox.question(self, &#39;Message&#39;,&quot;Are you sure to quit?&quot;, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No) if reply == QtGui.QMessageBox.Yes: event.accept() else: event.ignore() 函数放置位置就是主窗口类下就好。 QTableWidget 清除数据def updateData(self, data): #（缩进没问题吧…🙏） &quot;&quot;&quot;将数据更新到表格中&quot;&quot;&quot; if self.name == u&#39;RiskAlarmWidget&#39;: pass if self.updateBeginAction: data = self.updateBeginAction(data) if not data: return if self.updateAction: self.updateAction(data) else: if isinstance(data, unicode) and self.dataKey: # 删除模式 key = data if key in self.dataDict: d = self.dataDict[key] row = d[self.headerList[0]].row() self.removeRow(row) del self.dataDict[key] else: # 如果设置了dataKey，则采用存量更新模式 if self.InsertMode: # 如果允许了排序功能，则插入数据前必须关闭，否则插入新的数据会变乱 if self._sorting: self.setSortingEnabled(False) newRow = 0 if self.InsertTopRow else self.rowCount() self.insertRow(newRow) for n, header in enumerate(self.headerList): content = self.getContents(data, header) cellType = self.headerDict[header][&#39;cellType&#39;] cell = cellType(content) if self.font: cell.setFont(self.font) if self._saveData: cell.data = data self.setItem(newRow, n, cell) # 重新打开排序 if self._sorting: self.setSortingEnabled(True) else: key = data.__getattribute__(self.dataKey) if key in self.dataDict: # 已存在数据字典中，则更新相关单元格 d = self.dataDict[key] for header in self.headerList: content = self.getContents(data, header) cell = d[header] cell.setContent(content) if self._saveData: # 如果设置了保存数据对象，则进行对象保存 cell.data = data else: # 如果允许了排序功能，则插入数据前必须关闭， #否则插入新的数据会变乱 if self._sorting: self.setSortingEnabled(False) # 不存在数据字典中，插入新行，创建此行单元格 newRow = 0 if self.InsertTopRow else self.rowCount() self.insertRow(newRow) d = &#123;&#125; for n, header in enumerate(self.headerList): content = self.getContents(data, header) cellType = self.headerDict[header][&#39;cellType&#39;] cell = cellType(content) if self.font: cell.setFont(self.font) # 如果设置了特殊字体，则进行单元格设置 if self._saveData: # 如果设置了保存数据对象，则进行对象保存 cell.data = data self.setItem(newRow, n, cell) d[header] = cell self.dataDict[key] = d # 重新打开排序 if self._sorting: self.setSortingEnabled(True) if self.updateAfterAction: self.updateAfterAction(data) 插入后数据需要清理只需.clearContentsText()，这样是清理数据但保留表格，方便更新内容。.clear()则清理数据以及表格方便重新填入新的内容 调用Windows程序import win32api path = &#39;D:/.../dockerTrader/gateway/ctpGateway/CTP_connect.json&#39; win32api.ShellExecute(0, &#39;open&#39;, &#39;notepad.exe&#39;, path, &#39;&#39;, 1) # 使用记事本打开此文件 Jsonwith open(&#39;D:/.../dockerTrader/gateway/ctpGateway/CTP_connect.json&#39;, &#39;r&#39;) as f: setting = json.load(f) self.userID = str(setting[&#39;userID&#39;]) self.password = str(setting[&#39;password&#39;]) 信号槽（传输额外参数）一般来说，比如一个按钮吧。 在链接点击信号与槽时buttonInit[i].clicked.connect(partial(self.init, i))就完事了。然而，当循环创建按钮，对应同样的槽函数，只是需要执行的变量有区别时，就需要传输额外的参数。这时，方法有二： 环境： python2.7.8 pyqt 4.11.1 一： 使用lambda表达式from PyQt4.QtCore import * from PyQt4.QtGui import * class MyForm(QMainWindow): def __init__(self, parent=None): super(MyForm, self).__init__(parent) button1 = QPushButton('Button 1') button2 = QPushButton('Button 1') button1.clicked.connect(lambda: self.on_button(1)) button2.clicked.connect(lambda: self.on_button(2)) layout = QHBoxLayout() layout.addWidget(button1) layout.addWidget(button2) main_frame = QWidget() main_frame.setLayout(layout) self.setCentralWidget(main_frame) def on_button(self, n): print('Button &#123;0&#125; clicked'.format(n)) if __name__ == \"__main__\": import sys app = QApplication(sys.argv) form = MyForm() form.show() app.exec_() 解释一下，on_button是怎样处理从两个按钮传来的信号。我们使用lambda传递按钮数字给槽，也可以传递任何其他东西—甚至是按钮组件本身（假如，槽打算把传递信号的按钮修改为不可用） 二： 使用functools里的partial函数button1.clicked.connect(partial(self.on_button, 1)) button2.clicked.connect(partial(self.on_button, 2)) 《Rapid GUI Program with Python and QT》 P143例子。 from PyQt4.QtCore import * from PyQt4.QtGui import * from functools import partial import sys class Bu1(QWidget): def __init__(self, parent=None): super(Bu1, self).__init__(parent) #水平盒式布局 layout = QHBoxLayout() #显示 self.lbl = QLabel('no button is pressed') #循环5个按钮 for i in range(5): but = QPushButton(str(i)) layout.addWidget(but) #信号和槽连接 but.clicked.connect(self.cliked) #使用封装，lambda but = QPushButton('5') layout.addWidget(but) but.clicked.connect(lambda: self.on_click('5')) #使用个who变量，结果不正常，显示 False is pressed #but.clicked.connect(lambda who=\"5\": self.on_click(who)) #使用封装，partial函数 but = QPushButton('6') layout.addWidget(but) but.clicked.connect(partial(self.on_click, '6')) layout.addWidget(self.lbl) #设置布局 self.setLayout(layout) #传递额外参数 def cliked(self): bu = self.sender() if isinstance(bu, QPushButton): self.lbl.setText('%s is pressed' % bu.text()) else: self.lbl.setText('no effect') def on_click(self, n): self.lbl.setText('%s is pressed' % n) if __name__ == '__main__': app = QApplication(sys.argv) bu =Bu1() bu.show() app.exec_() 三：感谢来源 PyQt + echarts图表echarts绘制图标会在本地保存一个`html`文件，所以使用`PyQt`将之作为一个网页页面加载即可： from PyQt4.QtWebKit import * from PyQt4.QtGui import * from PyQt4.QtCore import * from pyecharts import Kline, Page def creat_charts(): page = Page() chart_init = &#123; &quot;width&quot;: 1600, &quot;height&quot;: 900, &#125; chart = Kline(&quot;K 线图&quot;, **chart_init) chart.add(&quot;日K&quot;, [&quot;2017/7/&#123;&#125;&quot;.format(i + 1) for i in range(31)], v1) page.add(chart) return page creat_charts()_render() # 生成`render.html`文件 self.view = QWebView() self.create_charts().render() url = QUrl(&quot;render.html&quot;) # 需要加载`QUrl`使用字符串转化 self.view.load(url) addWidget在窗口布局的时候这玩意至关重要，因为要先创建一个框架，再往里面塞东西。而塞的方法就是addWidget。所以简单记录一下小年这一天经常用到的环套： hbox = QtGui.QHBoxLayout() vbox = QtGui.QVBoxLayout() 可以通过`addWidget`来塞入`QtGui.QWidget`, `QtGui.QGroupBox`, QtGui.QTableWidget ,QScrollArea等 还可以addWidget诸如QtGui.QPushButton, QtGui.QLabel,QtGui.QComboBox, QtGui.QLineEdit等小部件 `hbox`和`vbox`可以通过`addLayout`互相添加（这两个是 框架，即页面上的“骨头”。来摆设“肌肉”-&gt;“Widget”、&quot;Box&quot;等的） 当然最后要显示谁，需要`self.setLayout(hbox)` 而支持`setLayout`少不了有 QWidget,QScrollArea, 所以它们好像能够无限互相套下去… 小部件的方法其实哪些方法也不用记…打开QtDesigner直接搜索拖拽，然后看右边的清单就行了，但这几个还是记录下来吧，在网上找太累了~ QtGui.QComboBox: addItems, ‘’’addItem, currentText QtGui.QSpinBox: setValue`, QString2Stringdef QString2PyString(self, qStr): #QString，如果内容是中文，则直接使用会有问题，要转换成 python #string return unicode(qStr.toUtf8(), &#39;utf-8&#39;, &#39;ignore&#39;) QLineEdit之所以放这么后面是因为我觉得这东西没什么好说的，也就是一个输入框嘛，但因为出现在后面所以说是现在发现了其中有趣的东西。那就是最近在做输入密码的时候想要限制，但在程序中去判断显然并不是什么有意思的事情。然后想起来输入的时候可以直接限制住啊。于是采用了textChanged去connect一个函数，来动态监测输入。但在调试中打开错了窗口所以以为没有用就找了其他的方法。那就是在初始化的时候直接卡死，结果没有找到设置长度的.set***但找到了现用的setValidator其配合正则表达式的食用方法如下： import re a = QtCore.QRegExp(&quot;[A-Za-z]&#123;0,5&#125;[1-9][0-9]&#123;0,5&#125;&quot;) a = QtCore.QRegExp(&quot;[a-zA-Z0-9]&#123;0,12&#125;$&quot;) self.txtPasswd.setValidator(QtGui.QRegExpValidator(a)) # emm,很显然，把a替换成limitRule就要顺眼一些了。 不过值得注意的是：如果用setText将其它字符写进这个编辑小框框中的话，那么这个框框的规则就会被打破然后随便写。但要是setText的内容没有超出所规定的形式之外的话，那么规则照旧，依然执行。 PyQtGraph:Link import pyqtgraph.examples pyqtgraph.examples.run()","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"Gui","slug":"note/Gui","permalink":"https://ianvzs.github.io/categories/note/Gui/"},{"name":"learning","slug":"note/Gui/learning","permalink":"https://ianvzs.github.io/categories/note/Gui/learning/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ianvzs.github.io/tags/python/"},{"name":"pyqt","slug":"pyqt","permalink":"https://ianvzs.github.io/tags/pyqt/"},{"name":"Gui","slug":"Gui","permalink":"https://ianvzs.github.io/tags/Gui/"}]},{"title":"Python笔记(notes of Python)","slug":"notes/noteOfpython","date":"2017-07-01T13:20:00.000Z","updated":"2022-06-15T07:32:39.334Z","comments":true,"path":"2017/07/01/notes/noteOfpython/","link":"","permalink":"https://ianvzs.github.io/2017/07/01/notes/noteOfpython/","excerpt":"","text":"author:Ian 彻底摆脱to_dict和from_dict使用 pydanticBaseModel类型支持: b = BattleAxiePositionInfo.parse_obj(DICT_DATA) b.json() b.dict() parse_file parse_raw12345678910111213141516from pydantic import BaseModelclass PositionInfo(BaseModel): error: int = -1 # 收集错误 none: int = 0 # 还没开始 clicked: int = 1 # 在client 赋此值 done: int = 2 # 在server 赋此值 xy: List[int] = [0, 0] status: int = 0 # clicked or done or none or errorclass BattleAxiePositionInfo(BaseModel): our: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] enemy: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()]pp = BattleAxiePositionInfo()print(f&quot;pp json: &#123;pp.json()&#125;&quot;)dict_pp = pp.dict()pp = BattleAxiePositionInfo.parse_obj(dict_pp) pp json: {“our”: [{“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}], “enemy”: [{“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}, {“error”: -1, “none”: 0, “clicked”: 1, “done”: 2, “xy”: [0, 0], “status”: 0}]} 多个类属性一次赋值No: 12self.a = aself.b = b Yes: 1self.__dict__.update(&#123;&quot;a&quot;: a, &quot;b&quot;: b&#125;) 列表表达式 二维数组边一维 取字典内变一维123knowninfo = &#123;&#x27;axie_id3&#x27;: &#123;&#x27;init_cards&#x27;: [&#x27;Sunder Claw&#x27;, &#x27;October Treat&#x27;, &#x27;Gas Unleash&#x27;, &#x27;Disguise&#x27;], &#x27;sort&#x27;: 4&#125;&#125;[vv for _,v in knowninfo.items() for vv in v[&quot;init_cards&quot;]]# [&#x27;Sunder Claw&#x27;, &#x27;October Treat&#x27;, &#x27;Gas Unleash&#x27;, &#x27;Disguise&#x27;] PiP Not Found Issue使用pip安装某包时， 提示让更新， 按提示操作更新没效果没反应再用就提示ModuleNotFoundError: No module named &#39;pip&#39; (ˉ▽ˉ；)… ModuleNotFoundError: No module named ‘pip’升级PiP时出现问题可由下方命令修复12python -m ensurepippython -m pip install --upgrade pip SSL校验安装EasyOCR时,reader = easyocr.Reader([&#39;ch_sim&#39;,&#39;en&#39;])下载到接近90,结果报错了…. 估计是SSL问题加入以下两条,不知如何. 12import sslssl._create_default_https_context = ssl._create_unverified_context from http.clientTo revert to the previous, unverified, behavior ssl._create_unverified_context() can be passed to the context parameter. 使用国内镜像下载Python1234pip install --index https://pypi.mirrors.ustc.edu.cn/simple/ dlib(numpy等包名) # 一键更新pip 包资源(利用管道grep传输查询到的需要更新包名，传输到install命令) pip3 freeze --local | grep -v &#x27;^\\-e&#x27; | cut -d = -f 1 | xargs -n1 pip3 install -U # 权限不够的话就在`pip3 install` 之前加`sudo`反正我不习惯用`root` 声明参数类型python3 在定义函数的时候可以声明函数类型啦：虽然不做限制，但作为label还是蛮好的。 123456789101112import iodef add(x:int, y:int) -&gt; int: return x + ydef write(f: io.BytesIO, data: bytes) -&gt; bool: try: f.write(data) except IOError: return False else: return True 终于不会之后写的忘了，要调用函数还得看半天这个函数应该怎么用… 时间处理以下可以做周、月的加减处理relativedelta examplesLet’s begin our trip: 12from datetime import *; from dateutil.relativedelta import *import calendar Store some values:123NOW = datetime.now()TODAY = date.today()NOW datetime.datetime(2003, 9, 17, 20, 54, 47, 282310) 1TODAY datetime.date(2003, 9, 17) Next month NOW+relativedelta(months=+1) 1datetime.datetime(2003, 10, 17, 20, 54, 47, 282310) 合并字典1234a = &#123;&#125;b = &#123;&#x27;a&#x27;: 1&#125;c = &#123;**a, **b&#125; key重复b中覆盖a, 否则单纯合并。 聊胜于无的小玩意 preety tools彩色输出模块名儿忘了，以后贴2019.03.01 03:08one minute later:pip3 install ansicolors 12345678from colors import red, green, blueprint(red(&#x27;This is red&#x27;))print(green(&#x27;This is green&#x27;))print(blue(&#x27;This is blue&#x27;))from colors import colorfor i in range(256): print(color(&#x27;Color #%d&#x27; % i, fg=i)) 以上程序只能写在.py文件中,运行，而不能在…‘偷懒模式‘中。 Python3 ThreadPoolExecutor 线程池内库在python3之后不久，有关线程池的使用就被集成到内库之中。from concurrent.futures import ThreadPoolExecutor使用方法： 12345678910 ThreadPoolExecutor(max_workers=12) # 设置线程池大小 .submit(func_name, (para)) # 提交任务 .done() # 查看任务是否完成 .cancel() # 没有被放入线程池中才能生效 .result() # 获取该任务返回值 from concurrent.futures import as_completed # 用于取出所有任务结果，省去一直用.done去查看的繁琐。但该方法# 是一个生成器，所以任务未完成会阻塞。 还有 wait map 等用法就去看文档吧。 安装错误？居然有pip3 install XX的错误…这也是因为有旧版pip3存留。需要 12$bash -d pip3 $bash -r pip3 来清理shell中旧版pip缓存。 IDE?其实要不要IDE都无所为，因为本就是脚本，要IDE只能说打开一个陌生项目查看时能够跳转函数。至于vim大概不能跳转吧，毕竟跳转需要把文件都加载才能实现。emm 来来，IDE的话就PyCharm除了编程页面颜色难看之外其他功能都不错，另外不支持中文路径，不过应该不是由于Python语言造成的，因为蟒蛇脚本是可以在中文路径下运行didate:2018年5月28日17点16分 print语句： 含有自动换行，所以要想不换行的话需要在结尾加一个”,”如：for i in range(0,5): print i, 而Python3版本则应该也可以 print(a,b,c);然而Python2.7不行 根据字典中值大小排列：sorted(dict2.iteritems(),key=lambda item:item[1],reverse=True) # item[0]即根据键来排列[1]为根据对应值 format：如:print(&#39;my name is&#123;0&#125;,and my age is&#123;1&#125;&#39;.format(&#39;song&#39;,18)) or:url = &#39;http://www.google.com/page=&#123;&#125;/&#39; newsurl = url.format(i) # 旋即其后内容则代替&#123;&#125;位置 另，在{a}{b}{c}可通過format(a=1,b=2,c=3)來賦值 BeautifulSoupselect语句：在内容前加’#’可以获得其内容，如：soup.select(&#39;artibodyTitle&#39;)[0].text select().contents &quot;&quot;&quot; 把标签变成不同list，同List中的不同元素 然后用[0]可取得第一个元素内容，而不与后方的内容合到一起 *.strip()可将取出的‘\\t\\t’移除 &quot;&quot;&quot; .select(&#39;time-source span a&#39;) # 从time-source中的&lt;span下&lt;a下取得内容e .select(&#39;.productPrice&#39;)[0].text # 獲取class=&quot;productPrice&quot;下價格內容 datetime字符串转时间 时间转字符串:from datetime import datetime dt = datetime.strptime(timesource,&#39;%Y年%m月%d日%H:%M&#39;)(****年*月*日*22:03) dt.strftime(&#39;%Y-%m-%d&#39;) 保存數據到xlsx，sqlite3、csv：.to_excel(&#39;name.xlsx&#39;)：输出为excle文件 import sqlite3 #保存到数据库 with sqlite3.connect(&#39;name.sqlite&#39;) as db: df.to_sql(&#39;name&#39;,con = db) 从数据库取出with sqlite3.connect(&#39;name.sqlite&#39;) as db: df2 = pandas.read_sql_query(&#39;SELECT&#39; * FROM name&#39;,con = db) 類型錯誤 TypeError: a bytes-like object is required, not ‘str’csv_file = open(&quot;rent.csv&quot;,&quot;wb&quot;) csv_writer = csv.writer(csv_file, delimiter=&#39;,&#39;) #创建writer对象，指定文件与分隔符 writer.writerow([&#39;title&#39;, &#39;summary&#39;, &#39;year&#39;, &#39;id&#39;, &#39;count&#39;, &#39;link&#39;]) Python2.7 轉到 3.5下時提示由此錯誤，代碼爲 原因，解決方法：因爲Python3.5 對於str與bytes類型區分變得敏感，所以原本在2.7下正常的代碼不能正常運行。 雖然，利用str.encode() 或者 str = bytes(str, encoding = &#39;utf-8&#39;)可以轉換格式 然而錯誤依然有……解決辦法則是放棄論壇裏的說法，找到官網Demo 更改如下：123csvfile = open(&#x27;goodsList.csv&#x27;, &#x27;w&#x27;, newline=&#x27;&#x27;)spamwriter = csv.writer(csvfile, delimiter=&#x27;,&#x27;)spamwriter.writerow([productTitle, productPrice, productShop]) 細節在於，在打開文件的時候去除wb裏面的b即不用二進制模式打開。 Image下：获取图像分辨率： 123im = Image.open(0.0)width = im.size[0]height = im.size[1] Pandas:12345678box = pd.read_csv(&quot;filename.csv, index_col=&quot;Date&quot;, parse_dates=Ture) #读入文件，讲Date作为日期box.columns = [&#x27;&#x27;,&#x27;&#x27;] # 更改列名box[&#x27;new&#x27;] = box[&#x27;1&#x27;]+box[&#x27;2&#x27;]# 新增一列为1与2之和box.resample(&#x27;d&#x27;, &#x27;sum&#x27;) # 重新按照‘d’:每天，进行采样 方式为取和(&#x27;w&#x27;,&#x27;sum&#x27;)所有数据在一周内进行取和 闲语：while True与while 1的区别：在Python2 中，循环判断一亿次，我的小电脑的执行速度是 while one: 9.97739481926 while_true: 18.8063299656 while 1 以压倒性胜利。 到了Python3中，则成了 while one: 16.101972927001043 while_true: 16.25536527499935 嗯，不错，不分伯仲——个鬼啊。整体变差了好吧。0.0 原因待明。 Python 小记 📖先贴一个客观的教程文档网站http://www.runoob.com/python/python-tutorial.html Windows 下添加环境变量，CMD中Python2 与Python3 共存Windows 下 把python2 路径加入到环境变量中，再修改python2.exe可以和python3区分方便在CMD中调用，但代价就是经常命令报错…… 不过也可以使用py -2来区分，所以还是不改名字了吧Windows 下 用py -2 -m pip install ***以及py -3 -m pip install ***来区分安装到python2 或者 python3. 变量类下直接定义的变量可以继承，然而并不能被自己的函数所调用，意义不明… 被继承的类可以调用继承类中定义的self.* 变量，俺认为这是因为它们在实例时都被当成了self 本身。另外，优先调用自己中的self变量，没有，才会去被继承类中去查找（先后顺序可得前方解答）。 变换数据类型Python 在从服务器接收或者发送数据时需要字符类型转换，’’’struct’’’便是为此而工作 struct.pack123456789import structa = 20b = 400str = struct.pack(&quot;ii&quot;, a, b) #转换后的str虽然是字符串类型，但相当于其他语言中的字节流（字节数组），可以在网络#上传输print &#x27;length:&#x27;, len(str)print strprint repr(str) —- resultlength: 8 #—-这里是乱码‘/x14/x00/x00/x00/x90/x01/x00/x00’ 格式符”i”表示转换为int，’ii’表示有两个int变量。进行转换后的结果长度为8个字节（int类型占用4个字节，两个int为8个字节），可以看到输出的结果是乱码，因为结果是二进制数据，所以显示为乱码。可以使用python的内置函数repr来获取可识别的字符串，其中十六进制的0x00000014, 0x00001009分别表示20和400。 struct.unpack1234str = struct.pack(&quot;ii&quot;, 20, 400)a1, a2 = struct.unpack(&quot;ii&quot;, str)print &#x27;a1:&#x27;, a1print &#x27;a2:&#x27;, a2 —- result:a1: 20a2: 400 struct.unpack做的工作刚好与struct.pack相反，用于将字节流转换成python数据类型。它的函数原型为：struct.unpack(fmt, string)，该函数返回一个元组。 struct.calcsize1234struct.calcsize(&#x27;i&#x27;)struct.calcsize(&#x27;ii&#x27;)struct.calcsize(&#x27;iic&#x27;)struct.calcsize(&#x27;iicd&#x27;) 48924 struct.calcsize用于计算格式字符串所对应的结果的长度，如：struct.calcsize(‘ii’)，返回8。因为两个int类型所占用的长度是8个字节。 struct.pack_into, struct.unpack_from12345678import structfrom ctypes import create_string_bufferbuf = create_string_buffer(12)print repr(buf.raw)struct.pack_into(&quot;iii&quot;, buf, 0, 1, 2, -1)print repr(buf.raw)print struct.unpack_from(&#x27;iii&#x27;, buf, 0) —- result‘/x00/x00/x00/x00/x00/x00/x00/x00/x00/x00/x00/x00’‘/x01/x00/x00/x00/x02/x00/x00/x00/xff/xff/xff/xff’(1, 2, -1) Python3在Python3中，转换字符串时，不能直接pack(&#39;8s&#39;, &#39;i am str&#39;), 需要将字符串转换成二进制所以在语法中标记pack(&#39;8s&#39;, b&#39;i am str&#39;)使用&#39;b&#39;来进行标记 以上来自Darkbull 这是转贴地址，不知道为什么我看的转贴挂的原帖地址失效了 😰 一不小心发现的语法py2.7 while &#39;a&#39; in a or b: break # 没错，意思就是如果a或者是b包含‘a’的话… * 与 ** 方法:呃，原来*在MarkDown里面是斜体的意思啊——需要斜体显示的前后各一个星号 def a(* a, **b): balabala 这里的*a， a在函数中被赋值为一个元组，b被赋值为一个字典。所以在调用的时候嘞，只能把能往一个元组里塞的放在前面，而能够生成字典的放在后面 a(1,2,3,4,5,6,7,8,9,a:&#39;a&#39;,b:1,c:&#39;nihao&#39;) 就像这么一样来调用。 另外，def a()函数中还能在前方再新加一个输入 def aa(jiushishuowo, *a, **b): pass 这样的话，那么在调用的时候第一个逗号前面的内容会赋值给它。over，回去拿快递了~~~ 🐶 年假前再来补充一下：约定名*args, **kwargs 获取文件路径path = os.path.abspath(os.path.dirname(__file__)) # 获取当前运行文件的路径。需在本地有此文件，在命令行中出错 for root, subdirs, files in os.walk(path): # 遍历所有path下文件 path为要遍历的路径 同获取路径os.path.abspath(&#39;./&#39;) os.path.abspath(&#39;Deskop&#39;) os.path.abspath(&#39;Deskop&#39;) + os.path.sep ‘C:\\Users\\Administrator’ ‘C:\\Users\\Administrator\\Deskop’ ‘C:\\Users\\Administrator\\Deskop\\‘ 获取指定目录下所有文件名列表os.listdir(&#39;D\\IFData&#39;) _dict_class Province: country = &#39;China&#39; def __init__(self, name, count): self.name = name self.count = count def func(self, *args, **kwargs): print &#39;func&#39; print Province.__dict__ # 类输出 obj1 = Province(&#39;HuBei&#39;, 100) print obj1.__dict__ # 对象1 obj2 = Province(&#39;hulala&#39;, 3888) print obj2.__dict__ # 对象2 &#123;&#39;country&#39;: &#39;China&#39;, &#39;__module__&#39;: &#39;__main__&#39;, &#39;func&#39;: &lt;function func at 0x049EF470&gt;, &#39;__init__&#39;: &lt;function __init__ at 0x049EF4F0&gt;, &#39;__doc__&#39;: None&#125; &#123;&#39;count&#39;: 100, &#39;name&#39;: &#39;HuBei&#39;&#125; &#123;&#39;count&#39;: 3888, &#39;name&#39;: &#39;hulala&#39;&#125; 类输出的是全局的函数，变量等信息。对象输出的只是对象拥有的普通变量而已 呃(⊙﹏⊙)，等下再去拿吧… 差点忘了说，这个__dict__与字典相配合来回赋值简直舒服… 步骤为：将某个变量=一个类（数据类（就是能够a.b这么调用的数值））然后这个变量就能a.b的这么使用了。 而后也能通过a.__dict__（这是一个字典）再将所需要的数值取出来，转赋值为别的东西。 反正我是用到了… 在想要实现一个函数来保存一个变量的某些属性的时候。（呃(⊙﹏⊙)用爱去理解我所描述的场合吧。） IF ELSE# 执行时会将IF前面整个表达式作为判断结果后的执行对象， # 而不是仅仅替换某一个数字或者变量。 即 下方表达式运算结果 # 不是 `4` 和 `5` 而是如下所示 a = 1 + 3 if 1 == 2 else 2 + 1 a a = 1 + 3 if 1 == 1 else 2 + 1 a 3 4 Python 2 中的object新式类和经典类# 作者：邹冲 # 链接：https://www.zhihu.com/question/19754936/answer/202650790 class A: def foo(self): print(&#39;called A.foo()&#39;) class B(A): pass class C(A): def foo(self): print(&#39;called C.foo()&#39;) class D(B, C): pass if __name__ == &#39;__main__&#39;: d = D() d.foo() B、C 是 A 的子类，D 多继承了 B、C 两个类，其中 C 重写了 A 中的 foo() 方法。 如果 A 是经典类（如上代码），当调用 D 的实例的 foo() 方法时，Python 会按照深度优先的方法去搜索 foo() ，路径是 B-A-C ，执行的是 A 中的 foo() ； 如果 A 是新式类，当调用 D 的实例的 foo() 方法时，Python 会按照广度优先的方法去搜索 foo() ，路径是 B-C-A ，执行的是 C 中的 foo() 。 因为 D 是直接继承 C 的，从逻辑上说，执行 C 中的 foo() 更加合理，因此新式类对多继承的处理更为合乎逻辑。 在 Python 3.x 中的新式类貌似已经兼容了经典类，无论 A 是否继承 object 类， D 实例中的 foo() 都会执行 C 中的 foo() 。但是在 Python 2.7 中这种差异仍然存在，因此还是推荐使用新式类，要继承 object 类。 .items()一个字典 a，其a.items()为将每对对应值组为一个元组。即使键值也为一个字典也是将此字典作为元组元素。(￣▽￣)” emm Queue队列，先进先出型。可存数字、字符…嘛，Python里啥都一样。所以啥都能存。用于事件按顺序执行。示例如~： import Queue mqueue = Queue.Queue(maxsize = 3) mqueue.put(10) mqueue.put(15) mqueue.put(12) # 此时如果再往里存呢，就会卡住… 持续等待有空位置 # 所以 mqueue.get() #取出第一个存入 mqueue.put(&#39;14sas4&#39;) #继续存 ## 在接触的项目中，是借用字典，来将处理函数作为Value，将Keys，put到队 列中，再进行取出执行。 如果队列中没有数值之后再get也会卡住……所以以下东西就显得比较重要了： series和dataframe先贴来源：http://blog.csdn.net/ly_ysys629/article/details/54944153 属性series ：.index, .values, .name, .index.name dataframe ：.columns, .index, .values series:一组数组（列表或元组），series除了一组数据外还包括一组索引（即只有行索引），索引可自行定义也可利用Series(),自动生成索引; dataframe:是表格型数据，既有行索引又有列索引，每列数据可以为不同类型数据（数值、字符串、布尔型值），可利用DataFrame（其他数据，dataframe属性)指定dataframe的属性创建dataframe。 实例series#创建series import pandas as pd obj_list=[1,2,3,4] obj_tuple=(4,5,6,7) obj_dict=&#123;&#39;a&#39;:[1,2],&#39;b&#39;:[2,3],&#39;c&#39;:[3,4],&#39;d&#39;:[4,5]&#125; obj_series_list=pd.Series(obj_list)#通过列表创建series obj_series_tuple=pd.Series(obj_tuple,index=list(&#39;abcd&#39;)) #通过元组创建series obj_series_dict=pd.Series(obj_dict)#通过字典创建series #定义属性 obj_series_list.index.name=&#39;zimu&#39; obj_series_list.name=&#39;data&#39; print &quot;#通过列表创建series&quot; print obj_series_list print &quot;#通过元组创建series&quot; print obj_series_tuple print &quot;#通过字典创建series&quot; print obj_series_dict #显示series类型及属性 print type(obj_series_list),obj_series_list.dtype print obj_series_list.index,obj_series_list.index.name print obj_series_list.values,obj_series_list.name #通过列表创建series zimu 0 1 1 2 2 3 3 4 Name: data, dtype: int64 #通过元组创建series a 4 b 5 c 6 d 7 dtype: int32 #通过字典创建series a [1, 2] b [2, 3] c [3, 4] d [4, 5] dtype: object &lt;class &#39;pandas.core.series.Series&#39;&gt; int64 RangeIndex(start=0, stop=4, step=1, name=u&#39;zimu&#39;) zimu [1 2 3 4] data dataframe#创建dataframe import pandas as pd import numpy as np obj_dict=&#123;&#39;a&#39;:[1,2],&#39;b&#39;:[2,3],&#39;c&#39;:[3,4],&#39;d&#39;:[4,5]&#125; obj_array=np.array([[1,2,3,4],[3,4,5,6]]) obj_series_1=pd.Series([11,12,13,14]) obj_series_2=pd.Series([21,22,23,24]) obj_dataframe_dict=pd.DataFrame(obj_dict) #通过字典创建dataframe obj_dataframe_array=pd.DataFrame(obj_array,index=[&#39;one&#39;,&#39;two&#39;]) #通过矩阵创建dataframe obj_dataframe_series=pd.DataFrame([obj_series_1,obj_series_2]) #通过series创建dataframe obj_dataframe_dataframe=pd.DataFrame(obj_dataframe_series,index= [0,1,&#39;one&#39;],columns=[0,1,2,&#39;a&#39;]) #通过其他dataframe创建dataframe print &quot;#通过字典创建dataframe&quot; print obj_dataframe_dict print &quot;#通过矩阵创建dataframe&quot; print obj_dataframe_array print &quot;#通过series创建dataframe&quot; print obj_dataframe_series print &quot;#通过其他dataframe创建dataframe&quot; print obj_dataframe_dataframe #dataframe属性 print obj_dataframe_dataframe.dtypes print obj_dataframe_dataframe.values print obj_dataframe_dataframe.columns print obj_dataframe_dataframe.index 输出结果为： #通过字典创建dataframe a b c d 0 1 2 3 4 1 2 3 4 5 #通过矩阵创建dataframe 0 1 2 3 one 1 2 3 4 two 3 4 5 6 #通过series创建dataframe 0 1 2 3 0 11 12 13 14 1 21 22 23 24 #通过其他dataframe创建dataframe 0 1 2 a 0 11.0 12.0 13.0 NaN 1 21.0 22.0 23.0 NaN one NaN NaN NaN NaN 0 float64 1 float64 2 float64 a float64 dtype: object [[ 11. 12. 13. nan] [ 21. 22. 23. nan] [ nan nan nan nan]] Index([0, 1, 2, u’a’], dtype=’object’) Index([0, 1, u’one’], dtype=’object’)取数据的话，便是obj_dataframe_dict[&#39;a&#39;][0]取出数值即为1 自命名创建方式df4 = pd.DataFrame(np.random.randn(6, 4), index=[u&#39;第二&#39;, 4, 3, 2, 1, 0], columns=[u&#39;第一&#39;,5,4,1]) #行为： 第一， 5， 4， 1 #列为：第二 -0.091305 ... # 4 ... # 3 # 2 # 1 # 0 ... 查看.dtypes 查看各行数据格式 .head() 查看前几行（默认5） .tail() 查看后几行 .index 查看数据框引索 .columns 查看列名 .values 数据值 .T 转置 .sort 排序 .sort(columns = &#39;***&#39;)根据***列数据进行排序 取数据方法见上zip 和 数组变字典a = [1,2,3] b = [4,5,6] c = [4,5,6,7,8] zipped = zip(a,b) [(1, 4), (2, 5), (3, 6)] zip(a,c) [(1, 4), (2, 5), (3, 6)] zip(*zipped) [(1, 2, 3), (4, 5, 6)] zip 也可以二维矩阵变换（矩阵的行列互换）因为其作用为按序号重组数组。（其英语翻译为拉链……） 数组变字典~：dic(zip(a, b)) # a中值为key b中值为values 字典操作dict= sorted(dic.items(), key=lambda d:d[0]) # 将字典按照键值升序排列 # d： 无所谓的参数 # d[0]：0为升序，1为降序 # 如果是字符型，那么‘1’‘10’‘12’… 才是‘2’’20‘，因为Python的比较是按照 # 按序提取第一个字符进行比较。所以要排序，还是得用int # 排序之后被转换为list类型。 for i in orderIDic: spamwriter.writerow(orderIDic[i]) # 变为 for i in orderIDic: spamwriter.writerow(i[1]) namedtupleimport collections person = collections.namedtuple(&#39;P&#39;, &#39;name age gender&#39;) # P: 类名 后面空格隔开的为变量名称 bob = person(name = &#39;B&#39;, age = 30, gender = &#39;male&#39;) jane = Person(name = &#39;J&#39;, age = 29, gender = &#39;female&#39;) for people in [bob, jane]: print (&quot;%s is %d years old %s&quot; % people) 元组的命名—— 命名之后可以由bob.name 来调用 （看了那个Python面向对象进阶， 老多__hahah__()函数之后，所以这明显是当成基本类的变量在用了。 emm 这么么说也不贴切 😔 果然理解程度还是跟不上的… emm 现在需要跟进的不是怎么用Python了，而是python的用法了，走起~ 继续写future笔记去了—— 这个得看的明白点儿😄） CSV读取import csv reader = csv.reader(open(&#39;test.csv&#39;, &#39;rb&#39;)) for item in reader: print item 官方是这么教你的#我记得我写过一次，怎么不见了… import csv with open(&#39;names.csv&#39;) as csvfile: reader = csv.DictReader(csvfilr) for row in reader: print (row[&#39;first_name&#39;], row[&#39;last_name&#39;]) 写入import csv writer = csv.writer(open(&#39;test2.csv&#39;, &#39;wb&#39;)) writer.writerow([&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;]) data = [range(3) for i in range(3)] for item in data: writer.writerow(item) 官方教你这么写import csv with open(&#39;names.csv&#39;) as csvfile: fieldnames = [&#39;first_name&#39;, &#39;last_name&#39;] writer = csv.DictWriter(csvfile, fieldnames = fieldnames) writer.writeheader() writer.writerow(&#39;first_name&#39; : &#39;Naled&#39;, &#39;last_name&#39; : &#39;Beans&#39;) 须注意之处：writer.writerow()方法中的参数是list类型，如果你想在A1列写入’hello’，则必须是writer.writerow(‘hello’)，不然’hello’会被看成是个list从而被分写入5列。写入CSV时，CSV文件的创建必须加上’b’参数，即csv.writer(open(‘test.csv’, ‘wb’))，不然会出现隔行的现象。网上搜到的解释是：python正常写入文件的时候，每行的结束默认添加’\\n’，即0x0D，而writerow命令的结束会再增加一个0x0D0A，因此对于windows系统来说，就是两行，而采用’b’参数，用二进制进行文件写入，系统默认是不添加0x0D的。 关闭csvfile.close() 值得注意的是上面的文档是覆盖型创建，即，写数据只能在关闭文档之前完成，之后再打开文件，再写就会覆盖掉之前（清空再写） 下面的txt mode = &#39;a&#39; 就属于添加型写入了，再关闭之后再打开会在最后一条开始继续添加。然后将csv中的’w’替换成‘a’就行了。记得带上’b’要不会出现数据隔行…隔行显示 官方还叫你这么写嘞with open(&#39;na1me.csv&#39;, &#39;ab&#39;) as csvfile: spamwriter = csv.writer(csvfile, delimiter = &#39;,&#39;) spamwriter.writerow([&#39;adasd&#39;, &#39;w.c.w&#39;, &#39;lol&#39;]) txt保存# 基本与CSV一致，emm其实都是保存为文档，就只有个后缀区别… def text_save(content,filename,mode=&#39;a&#39;): # Try to save a list variable in txt file. file = open(filename,mode) file.write(str(content)+&#39;\\n&#39;) file.close() text_save(np.mean(self.trueRange[start: ]), &#39;atr.txt&#39;) 关于保存路径呢，windows 下必须?用 ‘.\\.\\..’没错，当前路径（相对路径）和绝对路径都是这样用的 mode b代表二进制模式打开，而a就有用了，表示有此文件就打开，没的话就创建。 json和上述txt文件保存差不过，嗯应该说完全一样。因为我是用的是`json.dumps` dumps、loads 这两个语句前者是将字典转化为str格式，后者是将str转换为字典。所以保 存到文件也不过是 字典 -&gt; str -&gt;(用`write`写入)-&gt; 本地文件， 反之。 与之相对比的是`dump`和`load`这个是直接保存至文件，但`s`多好用 需注意的是`dumps`有`indent`参数可用来指明转换为`str`之后的缩进参 数。一般`4`（所以说这里说的是空格数？）。 哦，`loads`直接加载文件也 行，不用读出来`str`再去转换 Shelve对象的持久化存储—— 目的：Shelve模块为任意能够pickle的Python对象实现持久化存储，并提供一个类似字典的 接口。 列表List需提前定义，不能像变量一样随用随写… 以下来自于 Python 列表(List)操作方法详解 列表操作包含以下函数:cmp(list1, list2) # 比较两个列表的元素 len(list) # 列表元素个数 max(list) # 返回列表元素最大值 min(list) # 返回列表元素最小值 list(seq) # 将元组转换为列表 列表操作包含以下方法:list.append(obj) # 在列表末尾添加新的对象 list.count(obj) # 统计某个元素在列表中出现的次数 list.extend(seq) # 在列表末尾一次性 # 追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) # 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) # 将对象插入列表 list.pop(obj=list[-1]) #移除列表中的一个元素（默认最后一个元素） #，并且返回该元素的值 list.remove(obj) # 移除列表中某个值的第一个匹配项 list.reverse() # 反向列表中元素 list.sort([func]) # 对原列表进行排序 字符串连接来自http://www.cnblogs.com/chenjingyi/p/5741901.html 方法一website = &#39;python&#39; + &#39;tab&#39; + &#39;.com&#39; 方法二listStr = [&#39;python&#39;, &#39;tab&#39;, &#39;.com&#39;] website = &#39;&#39;.join(listStr) 方法三website = &#39;%s%s%s&#39; % (&#39;python&#39;, &#39;tab&#39;, &#39;.com&#39;) 结论： 连接个数少使用一，个数多使用二。 推荐，使用三 ~ ，~ 手动编译Py文件import compileall compileall.compile_dir(目录) 时间datetimefrom datetime import datetime a = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0) a.year a.hour #int 型变量 2017 0 获取当前本机电脑💻时间，replace为自定义某个数值。单独调用某个信息如a.year、a.hour datetime 类型变量可直接相减获得间隔日a = datetime.datetime.now() # datetime.datetime(2017, 10, 18, 8, 52, 27, 5000) b = datetime(2005, 2, 6) # datetime.datetime(2005, 2, 6, 0, 0) c = a - b # datetime.timedelta(4637, 31947, 5000) c.days # int 型 4637 timedeltatimedelta为datetime类型相减而来（datetime不能相加…），然后嘞，datetime.timedelta(1,35340)这是它的样子，前是天数，后是秒数。也就是说所有相减就是告诉你相距多少天零多少秒，都是标准单位（误）。要取出可 .days 和 `seconds`` 格式化输出当前时间import time print time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())) 2017-08-21 10:54:31 timeimport time time.time() # 返回当前时间的时间戳（1970纪元后经过的浮点秒数） # 返回值为float 可直接拿来运算，还是很舒服的。 线程 threading用于实现定时器import threading def hel(): print &quot;so you sucsessful to kill 5 seconde&quot; time = threading.Timer(5, hel) time.start() so you sucsessful to kill 5 seconde在命令行中按下回车后消失，很有意思，并且当第二调用时time.start()时就会—— RuntimeError: threads can only be started once 循环调用以上的不能循环调用的话就没啥价值了，所以下面有个妖艳用法为： def fun(): print &quot;So jian&quot; global timer timer = threading.Timer(5.5, fun) timer.start() timer = threading.Timer(1, fun) timer.start() # 通过自调自的方法循环创建时间线程，另外，timer.cancel()可停止定时器工作。 # 值得注意的是，上面不循环调用的 在执行完函数之后依然会持续运行 # 所以得记得关闭。 比方说这个妖艳……呃 本来打算在调用函数里写上cancel但是…依然之后不能再次start() 线程池自实现或者使用threadpool.ThreadPool: 1234567891011121314import timeimport threadpool def sayhello(str): print &quot;Hello &quot;,str time.sleep(2)name_list =[&#x27;dd&#x27;,&#x27;aa&#x27;,&#x27;bb&#x27;,&#x27;cc&#x27;]start_time = time.time()pool = threadpool.ThreadPool(10) requests = threadpool.makeRequests(sayhello, name_list) for req in requests: pool.putRequest(req) pool.wait() print &#x27;%d second&#x27;% (time.time()-start_time) Math 库import math 数值取整ceil、floor 还有一个不是此库中的round 找来翻译就是 ： 小区、地板、回合………… 好吧，是（抹灰泥装镶板、最低的，最小的、周围，围绕） # 使用方法为： math.ceil(3.12) math.floor(3.24) round(3.51) round(3.10999999999, 10) #取值时的参考步长，好像（😭）是10就是最大步长了，再大没意义 # 手动赋值超过9位也就是10位小数的时候在PyCharm里直接赋值调试就自己约了， # 而一般产生精度漂移都是十几位小数开外的。emm 就这么表达了，看得懂 4.0 3.0 4.0 3.11 令程序有序执行的方法对象（伪类）间变量传递Like This： class A(object): &quot;&quot;&quot;docstring for A&quot;&quot;&quot; def __init__(self, name): super(A, self).__init__() self.name = name self.a = 0 def da(self): print self.name print self.a a = A(&#39;I am A&#39;) a.da() class B(object): &quot;&quot;&quot;docstring for B&quot;&quot;&quot; def __init__(self, aclass): super(B, self).__init__() self.aclass = aclass self.aclass.a += 1 def dada(self): self.aclass.da() b = B(a) b.dada() class C(object): &quot;&quot;&quot;docstring for B&quot;&quot;&quot; def __init__(self, aclass): super(C, self).__init__() self.aclass = aclass self.aclass.a += 1 def dada(self): self.aclass.da() c = C(a) c.dada() I am A 0 I am A 1 I am A 2 B与C分别在去改变读取在A中定义的数值。 嗯，没错，这么看的画确实时Python基础……所以没有这个基础的我看起来前期还挺费劲。当然，理解很好理解，就是在实现方法上不知原理的话就很难过。最主要的是，知道了原理在自己编写的时候可以的心用手，信手拈来。嗯~ o(￣▽￣)o就是这么写意和惬意。在VN.PY中有记录，不过还是拿过来吧，毕竟python用法 字典中建立函数映射，方便调用~def add(x, y): return x + y def sub(x, y): return x - y a = &#123;&#39;add&#39;:add, &#39;sub&#39;:sub&#125; a a[&#39;add&#39;](1, 2) a[&#39;sub&#39;](1, 2) {‘add’: &lt;function add at 0x02D162B0&gt;, ‘sub’: &lt;function sub at 0x02D16530&gt;} 3 -1 collections 模块namedtuple给元组元素命名（貌似写过这个笔记欸，不过现在才发现这几个都是在一个模块下的） deque#双端队列 快速插入 以及取出 l.insert(0, v) l.pop(0) l.popleft() l.appendleft() # 数据量大时，速度优于原生list a Game:import sys import time from collections import deque fancy_loading = deque(&#39;&gt;--------------------&#39;) while True: print &#39;\\r%s&#39; % &#39;&#39;.join(fancy_loading), fancy_loading.rotate(1) sys.stdout.flush() time.sleep(0.08) Result: # 一个无尽循环的跑马灯 Counter# 计数器 from collections import Counter s = &#39;&#39;&#39;A Counter is a dict subclass for counting hashable objects. It is an unordered collection where elements are stored as dictionary keys and their counts are stored as dictionary values. Counts are allowed to be any integer value including zero or negative counts. The Counter class is similar to bags or multisets in other languages.&#39;&#39;&#39;.lower() c = Counter(s) print c.most_common(5) [(‘ ‘, 54), (‘e’, 32), (‘s’, 25), (‘a’, 24), (‘t’, 24)] OrderDict# 有序字典：记录了数据存入时的先后顺序 # 不过发现一个骚操作： defaultdict# 默认字典： 当key不存在时，返回此结果 线程创建线程： 使用Threading模块创建，从threading.Thread继承，然后重写__init__ 和run 方法 12345678910111213141516171819202122import threadingimport time exitFlag = 0 class myThread (threading.Thread): #继承父类threading.Thread def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): #把要执行的代码写到run函数里面 线程在创建后会直接运行run函数 print &quot;Starting &quot; + self.name 写到这儿 print &quot;Exiting &quot; + self.namethread1 = myThread(1, &quot;Thread - 1&quot; , 1)thread1 = myThread(2, &quot;Thread - 2&quot; , 2)# 开启thread1.start()thread2.start() 线程同步不同线程对某个数据同时修改就很刺激，所以需要同步。（当然也可以选择不）其实也简单，如下： import threading threadingLock = threading.Lock() # 从这儿领一把锁 # 然后在 run()函数中，“写到这儿——也就是工作函数之前，写上 threadingLock.acquire() # 随后在工作函数之后 # threadingLock.release() 然后拿到小锁子的函数就能运行，运行完了把小锁子释放掉。为啥不是钥匙🔑……好吧。我就称呼它我就称呼它梭子吧—— 队列12345678910111213141516171819线程优先级队列Queue.qsize() 返回队列的里站了几个Queue.empty() 如果队列为空，返回True,反之FalseQueue.full() 如果队列满了，返回True,反之FalseQueue.full 与 maxsize 大小对应Queue.get([block[, timeout]]) 获取队列,timeout`等待时间Queue.get_nowait() 相当 Queue.get(False)Queue.put(item) 写入队列，timeout 等待时间Queue.put_nowait(item) 相当Queue.put(item, False)Queue.task_done() 在完成一项工作之后，Queue.task_done() 函数向任务已经完成的队列发送一个信号Queue.join() 实际上意味着等到队列为空，再执行别的操作 来段儿示例：来自这儿 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#!/usr/bin/python# -*- coding: UTF-8 -*- import Queueimport threadingimport time exitFlag = 0 class myThread (threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.q = q def run(self): print &quot;Starting &quot; + self.name process_data(self.name, self.q) print &quot;Exiting &quot; + self.namedef process_data(threadName, q): while not exitFlag: queueLock.acquire() if not workQueue.empty(): data = q.get() queueLock.release() print &quot;%s processing %s&quot; % (threadName, data) else: queueLock.release() time.sleep(1) threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;]nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;]queueLock = threading.Lock()workQueue = Queue.Queue(10)threads = []threadID = 1 # 创建新线程for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1 # 填充队列queueLock.acquire()for word in nameList: workQueue.put(word)queueLock.release() # 等待队列清空while not workQueue.empty(): pass # 通知线程是时候退出exitFlag = 1 # 等待所有线程完成for t in threads: t.join()print &quot;Exiting Main Thread&quot; Starting Thread-1 Starting Thread-2 Starting Thread-3 Thread-1 processing One Thread-2 processing Two Thread-3 processing Three Thread-1 processing Four Thread-2 processing Five Exiting Thread-3 Exiting Thread-1 Exiting Thread-2 Exiting Main Thread 呃， 以上就是我现知道的终极用法，当然其基础于： workQueue = Queue.Queue(10) # 创建+设定队列长度（emm 小心卡死就是了） # 只要满了再往里塞绝对死，无意外……(lll￢ω￢) workQueue.put(word) # 往里塞。 基础就是塞个数字，高级就是塞个线程 workQueue.get() # 顺序往外取 # 括号里里面可以写进参数，然而，依然按照顺序往外取，插队办理啥的不存在 # 另外，队列空的话取依然会死…… 一些方法1234567891011q = queue.Queue(maxsize=0) q.qsize() #查看队列大小 q.empty() #判断队列是否为空 q.full() #如果maxsize设置了大小(eg:2)，如果q.put()了2个元素，则返回真，反之，则为假 q.get_nowait() # 如果队列中没有元素了，只用q.get()（当然，可以设置`q.get(block=False）`）会使程序卡住，用q.get_nowait()则会报错而不卡住 q.put_nowait() # 如果maxsize设置了大小，用q.put()超过范围则会卡住（当然# 可以设置属性q.put(block=False)）。用q.put_nowait()则会报错而不卡住 老夫的Demo消费生产者关系 123456789101112131415161718192021222324252627282930313233343536373839import threadingimport queueimport threadpoolimport timepool = threadpool.ThreadPool(2)que = queue.Queue()dataList = [1,2,3,4,5,6,7,8,9,0]dataList1 = [1,2,3,&#x27;a&#x27;, &#x27;b&#x27;]dataList2 = [4,5,6]dataList3 = [7,8,9,0]printLock = threading.Lock()workList = [dataList1, dataList2, dataList3]def worker(): ## 消费者 #printLock.acquire() aaa = que.get() print(aaa) for i in aaa: print (i) #printLock.release() time.sleep(5)def geter(task): ## 生产者 print(&quot;emm, put in_:&quot;, task) time.sleep(1) que.put(task) a = threading.Thread(target=worker) a.start()for i in workList: geter(i) 进程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import multiprocessingimport timedef worker_1(interval, lock, low): print (&quot;worker_1&quot;) print (time.time()) lock.acquire() time.sleep(0.1) print(&quot;I got the lock&quot;) time.sleep(interval) print(low) print (&quot;end worker_1&quot;) lock.release()def worker_2(interval, lock): print (&quot;worker_2&quot;) print (time.time()) lock.acquire() print(&quot;I got the lock&quot;) time.sleep(interval) print (&quot;end worker_2&quot;) lock.release()def worker_3(interval, lock): print (&quot;worker_3&quot;) print (time.time()) lock.acquire() print(&quot;I got the lock&quot;) time.sleep(interval) print (&quot;end worker_3&quot;) lock.release()if __name__ == &quot;__main__&quot;: printLock = multiprocessing.Lock() # 🔒 来自关爱的小锁子 p1 = multiprocessing.Process(target = worker_1, args = (2, printLock, [&quot;asd&quot;, &#123;&#x27;s&#x27;:1&#125;, [1,2,3]])).start() p2 = multiprocessing.Process(target = worker_2, args = (3, printLock)).start() p3 = multiprocessing.Process(target = worker_3, args = (4, printLock)).start() w = &#123;&#x27;a&#x27;:p1, &#x27;b&#x27;:p2, &#x27;c&#x27;:p3&#125; # 创建三个进程去运行这三个函数 #p1.start() #p2.start() #p3.start() #for i in w: # w[i].start() # 启动进程 print(&quot;The number of CPU is:&quot; + str(multiprocessing.cpu_count())) for p in multiprocessing.active_children(): print(&quot;child p.name:&quot; + p.name + &quot;\\tp.id&quot; + str(p.pid)) print (&quot;Main All Done&quot;) # dt 2018年5月18日11点22分 worker_11526613489.1864893worker_21526613489.1932006The number of CPU is:4child p.name:Process-3 p.id208child p.name:Process-1 p.id206child p.name:Process-2 p.id207Main All Doneworker_31526613489.1968668I got the lock[‘asd’, {‘s’: 1}, [1, 2, 3]]end worker_1I got the lock end worker_2I got the lockend worker_3 插一句话线程和进程的关系，貌似与电脑双系统和系统再开虚拟机的关系emm 对于资源利用的角度上。 没有传参的进程12345678910111213import multiprocessingdef sayHello(): print(&#x27;hello~ I can see you&#x27;)if __name__ == &#x27;__main__&#x27;: p1 = multiprocessing.Process(target=sayHello) p2 = multiprocessing.Process(target=sayHello) p3 = multiprocessing.Process(target=sayHello) p1.start() p2.start() p3.start() 如果只是单纯运行，这样就可以了，之所以做这个测试是因为我忌惮于那个args的传参，毕竟()里面若有元素存在就必须要有逗号… 看来没有传参的话就不需要了一个参数a的时候: (a, )emmm🤔 将进程定义为类import multiprocessing import time class ClockProcess(multiprocessing.Process): def __init__(self, interval): multiprocessing.Process.__init__(self) self.interval = interval def run(self): n = 5 while n &gt; 0: print(&quot;the time is &#123;0&#125;&quot;.format(time.ctime())) time.sleep(self.interval) n -= 1 if __name__ == &#39;__main__&#39;: p = ClockProcess(3) p.start() 以上，p.start()被调用时，自动调用run() 另外时间戳都是瞎戳的，所以… emm 这都一年之前的东西了，现在才想起来戳时间有点儿纪念意义(⊙﹏⊙) 2018年5月18日 属性daemon ：是否伴随主程序结束而结束 Lock: 锁：（如下， 防止访问共享资源时冲突，如以上打印时间时出现的不连续打印😰） def worker(lock, var): try: *** finally: lock.release() lock = multiprocessing.Lock() var = &#39;我是变量&#39; p = multiptocessing.Process(target = worker, args = (lock, var)) 警个告创建进程分支的函数选择只能隶属于__main__下或者是隶属与创建进程的函数级别相同的级别，例如今天在main下一个函数中选择目标函数为此函数的函数就不可以… 如下： 12345678def a(): def c(para): pass *(target=b, args=(1,)) 🌹 *(target=c, args=(1,)) ❌ def b(para): pass emm，上述表述的很明确，但是昨天又重新犯了这个问题… 进程的执行者放到了类中的某个函数，然后又提出到__main__ 中函数，所以都不能执行，最终放到`__main__``外，与它同级，也就是def 前无空格。 才能“受命”。 通过队列来存储不同进程产生的结果{来自}(https://blog.csdn.net/u014556057/article/details/66974452) 1234567891011121314151617181920212223242526# -*- coding:utf-8 -*-from multiprocessing import Process, Queue, LockL = [1, 2, 3]def add(q, lock, a, b): lock.acquire() # 加锁避免写入时出现不可预知的错误 L1 = range(a, b) lock.release() q.put(L1) print L1if __name__ == &#x27;__main__&#x27;: q = Queue() lock = Lock() p1 = Process(target=add, args=(q, lock, 20, 30)) p2 = Process(target=add, args=(q, lock, 30, 40)) p1.start() p2.start() p1.join() p2.join() L += q.get() + q.get() print L [20, 21, 22, 23, 24, 25, 26, 27, 28, 29][30, 31, 32, 33, 34, 35, 36, 37, 38, 39][1, 2, 3, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39] 再加一个协程基础实现：12345678910# yielddef creatAor(): mylist = range(3) for i in mylist: yield i*imygenerator = creatAor() # 生成一个生成器print (mygenerator)for i in mygenerator: print (i) &lt;generator object creatAor at 0x7f54ed368f10&gt;014 当调用函数时，其返回并不立马执行（显示）——emm 经过十几分钟😰的观察👀说那么玄乎，.其实就是在函数执行过程中，在yield处把后面紧接的东西记录下来，之后最后生成一个可迭代的对象。 所以网上说时生成器也不可厚非，但表达真的是……不过貌似.不仅仅是记录后面紧跟的东西… 1234567891011121314$ vim def creatAor(): mylist = range(3) print(&quot;so jia nei?&quot;) for i in mylist: print(&quot;pre a hou ga&quot;) yield i*i print (&quot;nihoua&quot;) print (&quot;2333333&quot;)mygenerator = creatAor()print (mygenerator)for i in mygenerator: print (i) &lt;generator object creatAor at 0x7fe2585a8f10&gt;so jia nei?pre a hou ga0nihouapre a hou ga1nihouapre a hou ga4nihoua2333333 所以看这苗头像是重新执行了一次函数，但是将后面紧跟的东西也进行了记录 应用到协程中，便是： 123456789101112131415161718192021222324252627import timedef consumer(): r = &#x27;&#x27; while True: n = yield r if not n: return print(&#x27;[CONSUMER] Consuming %s....&#x27; % n) time.sleep(1) r = &#x27;200 OK&#x27;def produce(c): c.next() n = 0 while n &lt; 5: n = n + 1 print(&#x27;[PRODUCER] Producing %s...&#x27; % n) r = c.send(n) print(&#x27;[PRODUCER] Consumer return: %s\\n&#x27; % r) c.close()if __name__==&#x27;__main__&#x27;: c = consumer() produce(c) for i in c: print(i) [PRODUCER] Producing 1…[CONSUMER] Consuming 1….[PRODUCER] Consumer return: 200 OK [PRODUCER] Producing 2…[CONSUMER] Consuming 2….[PRODUCER] Consumer return: 200 OK [PRODUCER] Producing 3…[CONSUMER] Consuming 3….[PRODUCER] Consumer return: 200 OK…… 那么，是什么道理呢？ send next 方法的背后今生12345678def my(): value = yield 1 value = yield value print(&#x27;finally: &#x27;, value)ge = my()print(ge.next())print(ge.send(2))print(ge.send(3)) 12(‘finally: ‘, 3)Traceback (most recent call last): File “yield_emm3.py”, line 8, in print(ge.send(3))StopIteration 可知： 当next时，yield挂起，但将之后的1返回。而后send激活了之前挂起赋值动作，但此时yield 1被替换为send来的2所以value被置为2. 再第三次调用，完成赋值动作之后，由于只被挂起两次动作，而这里调取了三次，所以报错 停止递归 。若直接递归则得到1 和 None. 所以 next与send都是用来激活挂起动作而使用的，但send好在可以与之交互。在send``之前需先next否则提示can’t send * to a just-started generator`(⊙﹏⊙) 我上面阐述的挂起，激活，是不是出现了什么偏差… 2018年5月18日16点30分 较完善方案：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 1import geventdef f(n): for i in range(n): print gevent.getcurrent(), ig2 = gevent.spawn(f, 5)g3 = gevent.spawn(f, 5)g1.join()g3.join()# 2import geventfrom gevent import monkey; monkey.patch_all()import urllib2def f(url): print &#x27;GET: %s&#x27; % url resp = urllib2.urlopen(url) data = resp.read() print &#x27;[%d] bytes received from %s\\n&#x27; %(len(data), url) gevent.joinall([ gevent.spawn(f, &#x27;http://www.cnblogs.com/kaituorensheng/&#x27;), gevent.spawn(f, &#x27;https://www.python.org/&#x27;), gevent.spawn(f, &#x27;https://www.baidu.com&#x27;),])# 3from gevent import monkey monkey.patch_all() import gevent from gevent import Greenlet class Task(Greenlet): def __init__(self, name): Greenlet.__init__(self) self.name = name def _run(self): print &quot;Task %s: some task...&quot; % self.name t1 = Task(&quot;task1&quot;) t2 = Task(&quot;task2&quot;) t1.start() t2.start() # here we are waiting all tasks gevent.joinall([t1,t2]) 和线程 进程 差不多一个用法，只不过没锁，也不需要锁。 futuresfutures.ThreadPoolExecutor123with futures.ThreadPoolExecutor(16) as executor: executor.map(run, urls) # 这里是个爬虫，urls就是一个前方run函数的输入变量 父类中的变量与类中变量在使用self.a 的时候——呃其实是实例化之后a.a时，会只在父类中寻找相关变量，而解决办法居然是将super(A, self).__init__(CtaEngine, setting)移动到变量定义之后，所以谁说这玩意放前面和放后面没有区别的！（欸?😘 这个之后有过说明，不过忘记写在哪儿了，再说一下，就是super….表示父类的初始化动作，__init__因为这个函数名子父相同不会重写，会合并。） 列表的增删添append # 在最后添加一元素 extend # c.extend(a) 将列表a中元素加到c中去。可自加 + # 连接两方数组元素 c = a + c 然而创建新对象，耗内存… 所以没啥 用 del # 删除对应下标元素 del c[0] 删除c列表第一位元素 pop # c.pop() 删除最后一位元素 remove # 删除指定值元素，有相同值时只会删除第一位 [ : ] # 使用切片进行删除 insert # c.insert(0, 1)将1插入到c的最前方，可插列表，插入还是列表 一个函数的有效方式只在循环中执行一次 - 代码日志这是原链接emm 代码反正照着输入是不会有结果的，但感觉挺有戏先保留，以后技术提升再来看 自己的方法自己的方法很简单，很暴力，就是用字典啊—— 当执行过一次之后直接把调用关系扭到别的地方，反正只要是知道结果的判断都可以用字典来代替么。 函数调用函数 and 语法糖 @import time def timehel(hell): def wrapper(): start = time.clock() hell() end =time.clock() print &#39;used:&#39;, end - start return wrapper @timeheldef foo(): print ‘a ho ga’ a ho ga used: 0.000489465229975 其上@timehel 和 foo = timehel(foo)等价（感谢被遗忘的博客）… 就是把下方函数当成输入，然后执行通俗来翻译就是： @：呼叫timehel 来执行下面这孙子。 这里是官方教你怎么用： https://wiki.python.org/moin/PythonDecoratorLibrary 其中 函数中定义函数就类似于“父子关系”，也或者叫另辟空间。每次执行父函数时，子函数会有也尽在此时会有被执行的机会，会不会被执行，就看其在其父亲面前的表现了（他爸有没有叫他（有没有调用…））。 变量作用域因为从这个@ 这儿学到的，所以： def hel(x): def inner(): print x return inner p1 = hel(1) p1 = hel(1) p1() 1 p2() 2 闭包——如果没有inner这东西，下面绝不会输出东西，反而会报错。 直接p1,p2又不会再输出任何东西，只有在定义时会运行一次。 对比于def hel(x): print x 其中内层原因 先不深究，就脑补成外层需运行时才能去找那些变量，而其中的函数会主动去外围找所需的变量。 应用案例import time def coseTime(func): print func def inner(*args, **kwargs): print args, kwargs start = time.clock() func(*args, **kwargs) end = time.clock() print args, kwargs print (&#39;Running time: %s Seconds&#39; % (end-start)) return inner @coseTime def hel(x): print (&#39;hello~&#39;) hel(12) &lt;function hel at 0x02BC5070&gt;(12,) {}hello~(12,) {}Running time: 0.000446197317167 Seconds 用来无视变量来记录 函数运行所需时间的——同时输出其在运行时接入的变量 functools就姑且放这儿吧，毕竟也算是为了有序执行而接触到的 partialimport functools def add(a, b): print a, b return a, b addplus = functools.partial(add, 3) addplus(7) 3 7 addplus(add, b = 6) addplus(7) 7 6 这函数作用是 提前给定函数一个变量值…The functools module is for higher-order functions: functions that act on or return other functions. In general, any callable object can be treated as a function for the purposes of this module. 我的接触场景是在PyQt 中信号槽循环连接时，用了partial在connect之后.connect(partial(self.start, i))去唯一化相同功能的复用。不过我之前也应该写过类似的，那时我找的解决办法时在连接调用时传参(在Python GUI里面应该会写有吧，假如两三个月前我没脑子短期性失忆的话😭)。emm那个传参是利用Qt机制 不知道孰优孰劣😄 运气好，直接翻到： ——那里的应用场景是在鼠标点击按钮捕获点击事件click时传递的参数~ lambda使用方法为： func = lambda x:x*x # :前x表示函数输入，:后为返回值，x*x是这个函数收到输入后所执行的动作 w = lambda x:func(x) 网络编程socketimport socket # 服务端 s = socket.socket() host = socket.gethostname() port = 12345 s.bind((host, port)) s.listen(5) while True: c, addr = s.accept() print &quot;link address is&quot;, addr c.send(&#39;welcome here&#39;) c.close() # 客户端 s = socket.socket() host = socket.gethostname() port = 12345 s.connect((host, port)) # 此时服务端便弹出 link address is：(&#39;192.168.*.*&#39;, 64*5) print s.recv(1024) # 客户端显示welcome here select : 与Socket配合的跨平台的异步io模型import selectimport socketimport Queue #create a socketserver = socket.socket(socket.AF_INET,socket.SOCK_STREAM)server.setblocking(False)#set option reusedserver.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR , 1) server_address= (‘192.168.1.102’,10001)server.bind(server_address) server.listen(10) #sockets from which we except to readinputs = [server] #sockets from which we expect to writeoutputs = [] #Outgoing message queues (socket:Queue)message_queues = {} #A optional parameter for select is TIMEOUTtimeout = 20 while inputs: print “waiting for next event” readable , writable , exceptional = select.select(inputs, outputs, inputs, timeout) # When timeout reached , select return three empty lists if not (readable or writable or exceptional) : print &quot;Time out ! &quot; break; for s in readable : if s is server: # A &quot;readable&quot; socket is ready to accept a connection connection, client_address = s.accept() print &quot; connection from &quot;, client_address connection.setblocking(0) inputs.append(connection) message_queues[connection] = Queue.Queue() else: data = s.recv(1024) if data : print &quot; received &quot; , data , &quot;from &quot;,s.getpeername() message_queues[s].put(data) # Add output channel for response if s not in outputs: outputs.append(s) else: #Interpret empty result as closed connection print &quot; closing&quot;, client_address if s in outputs : outputs.remove(s) inputs.remove(s) s.close() #remove message queue del message_queues[s] for s in writable: try: next_msg = message_queues[s].get_nowait() except Queue.Empty: print &quot; &quot; , s.getpeername() , &#39;queue empty&#39; outputs.remove(s) else: print &quot; sending &quot; , next_msg , &quot; to &quot;, s.getpeername() s.send(next_msg) for s in exceptional: print &quot; exception condition on &quot;, s.getpeername() #stop listening for input on the connection inputs.remove(s) if s in outputs: outputs.remove(s) s.close() #Remove message queue del message_queues[s] 糖拌咸鱼 - 记录学习的点点滴滴~ 简单来说一下select的作用： 返回值：三个列表 select方法用来监视文件描述符(当文件描述符条件不满足时，select会阻塞)，当某个文件描述符状态改变后，会返回三个列表 1、当参数1 序列中的fd满足“可读”条件时，则获取发生变化的fd并添加到fd_r_list中 2、当参数2 序列中含有fd时，则将该序列中所有的fd添加到 fd_w_list中 3、当参数3 序列中的fd发生错误时，则将该发生错误的fd添加到 fd_e_list中 4、当超时时间为空，则select会一直阻塞，直到监听的句柄发生变化 当超时时间 ＝ n(正整数)时，那么如果监听的句柄均无任何变化，则select会阻塞n秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行。 epoll很好的改进了select 具体请看(深入理解python中的select模块)[http://blog.csdn.net/songfreeman/article/details/51179213] 引用模块action.py中引用model.py为例 同一文件夹下from model import * # or import model 其下级文件”here”下# 在model.py 文件中创建__init__.py空文件 from here import model # or form here.model import * 在上级文件下import sys sys.path.append(&quot;..&quot;) # 添加上级文件 路径 # import model 在上级文件的下级文件中（也就是在隔壁“wang”文件中）# 需要创建__init__.py空文件 # 添加上级文件路径 import wang.model 解决编码问题import sys reload(sys) sys.setdefaultencoding(&#39;utf8&#39;) # 这段直接塞它嘴里 输出提示打印乱码#coding: utf-8 n=raw_input(unicode(&#39;请输入文字&#39;,&#39;utf-8&#39;).encode(&#39;gbk&#39;)) print n 内存异常占用import sys v = 1 sys.getsizeof(v) # 可以读出 此变量emm 或者说 对象的内存占用大小 异常plan1 ：try: #正常的操作 except: #发生异常，执行这块代码 else: #如果没有异常执行这块代码(在执行完try下函数没有异常发生) 列表的坑当a 为一个列表 a = [1, 2, 3] b = a c = a d = a b.append(4) 这时，abcd四个列表都变成[1, 2, 3, 4]，emm… 所以直接以后不要把一个列表赋值给两个变量…除非不涉及修改，慎重慎重。。不过python中列表有copy一说，不过还没试过 @staticmethod定义类中的的这个方法为静态方法，同理的还有`@classmethod`类方法。 常见异常1.AssertionError：当assert断言条件为假的时候抛出的异常 2.AttributeError：当访问的对象属性不存在的时候抛出的异常 3.IndexError：超出对象索引的范围时抛出的异常 4.KeyError：在字典中查找一个不存在的key抛出的异常 5.NameError：访问一个不存在的变量时抛出的异常 6.OSError：操作系统产生的异常 7.SyntaxError：语法错误时会抛出此异常 8.TypeError：类型错误，通常是不通类型之间的操作会出现此异常 9.ZeroDivisionError：进行数学运算时除数为0时会出现此异常·· 事件模式中，事件篡改事故在循环创建事件时，将event put到队列中，此时，被处理一半，因为不在一个线程所以下一个循环来临就将event的内容进行了修改。 杜绝此方法除了添加锁，只好将事件copy之后再传入时间引擎。如此便可暂防止事件处理一半被修改的事情发生。 代码块注释Surrounding Blocks of Code with Language Constructs VisualStudio模式：#region Description(说明) print &quot;code here&quot; #endregion NetBeans模式：// &lt;editor-fold desc=&quot;Description&quot;&gt; code here // &lt;/editor-fold&gt; 类以后详谈，本着一切皆对象的原则，所以对于类的了解决定了Python的认知，先记一个 def __init__(self): super(Proformance, self).__init__() #这个super表示了继承类和被继承类的 __init__调用时序，其它重名函数是覆盖，这个…… 数据类用一个类来表示一个数据类型（这几天想着这个表示不同数据类型的组合方法恰类似于C中的结构体，然后Python中的数组元素存储各种东西什么类啊、数组套数组啊，字典存储啊，恰巧与C中的指针指向指针……emm ）如： class A(object): def __init__(self): self.a = &#39;a&#39; self.b = &#39;b&#39; A().__dict__ {‘a’: ‘a’, ‘b’: ‘b’} 但是A().__dict__[&#39;a&#39;] = &#39;It is a&#39; 虽然不会报错，但之后再次调用A().__dict__显示结果还是一样，但： a = A() a.__dict__[&#39;a&#39;] = &#39;It is a&#39; a.__dict__ {‘a’: ‘It is a’, ‘b’: ‘b’} 这样我就用过一次，在不确定数据类会有几个元素甚至不知道会是什么名称的时候来创建的，毕竟：(这样的方式可以随便添加嘛) a.__dict__[&#39;w&#39;] = &#39;It is www&#39; a.__dict__ {‘a’: ‘It is a’, ‘b’: ‘b’, ‘w’: ‘It is www’ 若出现docx模块pyInstaller打包问题大概的解决步骤是这样的：找到python-docx包安装路径下的一个名为default.docx的文件，我是通过everything这个强大的搜索工具全局搜索找到这个文件的，它在我本地所在的路径是：E:\\code\\env.env\\Lib\\site-packages\\docx\\templates把找到的default.docx文件复制到我的py脚本文件所在的目录下。修改脚本中创建Document对象的方式：从原来的创建方式：document = Document()修改为：import osdocument = Document(docx=os.path.join(os.getcwd(), ‘default.docx’))再次用pyinstaller工具打包脚本为exe文件把default.docx文件复制到与生成的exe文件相同的路径下，再次运行exe文件，顺利运行通过，没有再出现之前的报错，问题得到解决。作者：(m2fox)[https://www.jianshu.com/p/94ac13f6633e]來源：简书 拼接List字符串将list中的元素拼接起来，并使用,隔开可这么来： import itertools list = [&#39;123&#39;, &#39;567&#39;] xlist = &quot;,&quot;.join(list) or ylist = &quot;,&quot;.join(*list) s = .join(itertools.chain(kwargs.keys())) 区别在于x为一个元素添加一个,，y为把列表中的素也拆分之后再添加 SimpleHTTPServer小型的局域网嘛☺，很常用，不过在Python3中有了变化… 12345$ Python2python -m SimpleHTTPServer ---$ Python3python -m http.server 顺带一提：-m是可以在外执行内库的操作，🦑大概是这个意思吧—— 用pdb的时候也是这么用的… 老夫的月份生成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158# -*- coding:utf-8 -*-import datetimeimport copydef splitMonth(start, end): start = str2Date(start) end = str2Date(end) _delta = end - start datelist = [] if _delta.days &gt; 10: # 拆分 # 按*月*拆分（10日间隔） n = 0 _start = copy.copy(start) while _delta.days &gt; 0: n += 1 if _start.day &lt; 10: _end = datetime.date(_start.year, _start.month, 10) if end &gt; _end: datelist.append((date2str(_start), date2str(_end))) _start = _end + datetime.timedelta(1) else: datelist.append((date2str(_start), date2str(end))) break elif _start.day &lt; 20: _end = datetime.date(_start.year, _start.month, 20) if end &gt; _end: datelist.append((date2str(_start), date2str(_end))) _start = _end + datetime.timedelta(1) else: datelist.append((date2str(_start), date2str(end))) break else: _end = datetime.date(_start.year, _start.month, _start.day) + datetime.timedelta(15) _end = datetime.date(_end.year, _end.month, 1) - datetime.timedelta(1) if end &gt; _end: datelist.append((date2str(_start), date2str(_end))) _start = _end + datetime.timedelta(1) else: datelist.append(date2str(_start), date2str(end)) break _delta = end - _start + datetime.timedelta(1) return datelist else: return [(date2str(start), date2str(end))]def splitMouthBySE_N(start, end, n): start = str2Date(start) end = str2Date(end) _delta = end - start datelist = [] if _delta.days &gt; n: # 拆分 # 按*月*拆分（10日间隔） _start = copy.copy(start) while _delta.days &gt; 0: _loop = 0 for _n in range(int(30/n)): _loop = _loop + n if _start.day &lt; _loop: if _start.month == 2 and _loop &gt; 28: if _start.year%4: _end = datetime.date(_start.year, _start.month, 28) else: _end = datetime.date(_start.year, _start.month, 29) else: _end = datetime.date(_start.year, _start.month, _loop) if end &gt; _end: datelist.append((date2str(_start), date2str(_end))) _start = _end + datetime.timedelta(1) else: datelist.append((date2str(_start), date2str(end))) _delta = datetime.timedelta(0) break _end = datetime.date(_start.year, _start.month, _start.day) + datetime.timedelta(15) else: continue else: _end = datetime.date(_end.year, _end.month, 1) - datetime.timedelta(1) if end &gt; _end: if _start &gt; _end: _delta = end - _start + datetime.timedelta(1) else: datelist.append((date2str(_start), date2str(_end))) _start = _end + datetime.timedelta(1) else: datelist.append((date2str(_start), date2str(end))) _delta = datetime.timedelta(0) break _delta = end - _start + datetime.timedelta(1) return datelist else: return [(date2str(start), date2str(end))]def gropdate(datelist, itemNum=0, gropNum=0): #将传入datelist[(str(start1), str(end1)), (str(start2), str(end2))...] -&gt; 传入为月碎片 # 打按月对月碎片进行打组。 # 传入参数 itemNum: 一个组含几个月, gropNum: 将这些碎片打为几组 _dic = collections.OrderedDict() for i in datelist: # 按月分组 keyName = i[0].split(&#x27;-&#x27;)[1] if keyName not in _dic: _dic[keyName] = [] _dic[keyName].append(i) monthList = [] groups = [] groupListTemp = [] groupList = [] for i in _dic.keys(): # 得到月份列表 monthList.append(i) #[1,2,3...,7,8,9] monthNum = len(monthList) if gropNum: itemNum = round(float(monthNum)/gropNum) itemNum = int(itemNum) if itemNum: slipNum = int(monthNum/itemNum) start = 0 end = int(itemNum) for mon in range(slipNum): groups.append(monthList[int(start):int(end)]) start = copy.copy(end) end = end + itemNum if monthNum%itemNum: groups.append(monthList[start:monthNum]) # 非整除补足 for i in groups: for ii in i: groupListTemp.append(_dic[ii]) groupList.append(groupListTemp) groupListTemp = [] return groupList else: return None # region 日期`date`格式与`str`转换处理def date2str(_date): # datetime.date 转换为 str (有为了适配原程序的补零操作…) if _date.month &lt; 10: strDate = str(_date.year) + &#x27;-&#x27; + &#x27;0&#x27;+str(_date.month) + &#x27;-&#x27; + str(_date.day) else: strDate = str(_date.year) + &#x27;-&#x27; + str(_date.month) + &#x27;-&#x27; + str(_date.day) if _date.day &lt; 10: strDate = strDate[:-1] + &#x27;0&#x27;+str(_date.day) return strDatedef str2Date(_str): # str 转换为 datetime.date y, m, d = _str.split(&#x27;-&#x27;) return datetime.date(int(y), int(m), int(d))# endregion if __name__ == &#x27;__main__&#x27;: print(splitMouthBySE_N(&#x27;2016-01-02&#x27;, &#x27;2018-03-01&#x27;, 5)) Python3.6之后的奇淫技巧 可使用下划线将长数字隔开，便于阅读 10000=10_000 字符串操作除了 %和format之外还有f操作1234567891011121314151617181920212223$ %s = &quot;%s is %d&quot; % (&#x27;two&#x27;, 2)$ formats = &quot;&#123;fruit&#125; is &#123;color&#125;&quot;.format(fruit=&#x27;apple&#x27;, color=&#x27;red&#x27;)$ fname = &#x27;Bob&#x27;f&#x27;Hello, &#123;name&#125;!&#x27;### 甚至a = 5b = 10f&#x27;Five plus ten is &#123;a + b&#125; and not &#123;2 * (a + b)&#125;.&#x27;#### 精度PI = 3.141592653f&quot;Pi is &#123;PI:.2f&#125;&quot;&gt;&gt;&gt; &#x27;Pi is 3.14&#x27;&gt;&gt;&gt; error = 50159747054##### 以16进制格式化f&#x27;Programmer Error: &#123;error:#x&#125;&#x27;&gt;&gt;&gt;&#x27;Programmer Error: 0xbadc0ffee&#x27;##### 以二进制格式化f&#x27;Programmer Error: &#123;error:#b&#125;&#x27;&gt;&gt;&gt; &#x27;Programmer Error: 0b101110101101110000001111111111101110&#x27; 变量注释 def my_add(a: int, b: int) -&gt; int: \\n return 0 仅仅用来注释，其实传参出参并不受控制… 魔法方法假设定义类 EmmNe, EmmNe拥有self.aaa与self.aaadict、列表self.aaalist 且__init__允许两个传参 __len__: 123def __len__(self): return len(self.aaa)# 则在外`len`此实例化对象时，会返回这个结果 __getitem__: 123456789101112def __getitem__(self, key) return self.aaadict[key]en = EmmNe(1, 2)print(en[`])&gt; 2#就像上面那样。 不过还有下面的用法def __getitem__(self, index): retrun self.aaalist[index]w = Emm(1,2)for i in w: print (i)# 则输出列表中内容 __setitem__: 123456def __setitem__(self, key, value) return self.aaadict[key] = value# 拥有此方法，则在外可将实例对象当作字典操作:enp[&#x27;a&#x27;] = &#x27;asd&#x27;# 就像这样 collectionss总结一句话： collections出品， 必属精品。马上能想到的 有序字典，还有那啥都是出自此个模块之下。今天用的 计数也是出自此处 反正之后 这个里面能实现的功能，那就放弃手写吧————😓from collections import Counter Function AnnotationsAnnotations are stored in the annotations attribute of the function as a dictionary and have no effect on any other part of the function. Parameter annotations are defined by a colon after the parameter name, followed by an expression evaluating to the value of the annotation. Return annotations are defined by a literal -&gt;, followed by an expression, between the parameter list and the colon denoting the end of the def statement. The following example has a positional argument, a keyword argument, and the return value annotated: 1234567891011&gt;&gt;&gt;def f(ham: str, eggs: str = &#x27;eggs&#x27;) -&gt; str: print(&quot;Annotations:&quot;, f.__annotations__) print(&quot;Arguments:&quot;, ham, eggs) return ham + &#x27; and &#x27; + eggsf(&#x27;spam&#x27;)&gt;&gt;&gt; Annotations: &#123;&#x27;ham&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;return&#x27;: &lt;class &#x27;str&#x27;&gt;, &#x27;eggs&#x27;: &lt;class &#x27;str&#x27;&gt;&#125;&gt;&gt;&gt; Arguments: spam eggs&gt;&gt;&gt; &#x27;spam and eggs&#x27; Logger模块名： logging上手容易，功能丰富，性能肯定也好过自己✍另外，懒——— 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import sysimport loggingimport logging_errorlogger1 = logging.getLogger(&#x27;loger1&#x27;)logger2 = logging.getLogger(&#x27;loger2&#x27;)#实例化两个logger,默认名称为：`root`&quot;&quot;&quot;我居然以为root是程序执行处的名字，以为放到函数中就会显示函数名。emm所以才有了下面多层函数嵌套…，以及调用外部`import`&quot;&quot;&quot;formatter = logging.Formatter(&#x27;[%(name)s]%(asctime)s %(levelname)-8s: %(message)s&#x27;)#定义日志格式：&quot;&quot;&quot;%(name)s Logger的名字%(levelno)s 数字形式的日志级别%(levelname)s 文本形式的日志级别%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有%(filename)s 调用日志输出函数的模块的文件名%(module)s 调用日志输出函数的模块名|%(funcName)s 调用日志输出函数的函数名|%(lineno)d 调用日志输出函数的语句所在的代码行%(created)f 当前时间，用UNIX标准的表示时间的浮点数表示|%(relativeCreated)d 输出日志信息时的，自Logger创建以来的毫秒数|%(asctime)s 字符串形式的当前时间。默认格式是“2003-07-08 16:49:45,896”。逗号后面的是毫秒%(thread)d 线程ID。可能没有%(threadName)s 线程名。可能没有%(process)d 进程ID。可能没有%(message)s 用户输出的消息&quot;&quot;&quot;fileHandler = logging.FileHandler(&#x27;loger.log&#x27;)fileHandler.setFormatter(formatter)consoleHandler = logging.StreamHandler(sys.stdout)consoleHandler.formatter = formatter#配置文件、终端日志处理器。可以使用不同格式，来区分处理logger1.addHandler(fileHandler)logger2.addHandler(fileHandler)logger1.addHandler(consoleHandler)logger2.addHandler(consoleHandler)#为日志机添加处理器logger1.setLevel(logging.INFO)#logger2.setLevel()#设置各日志机打印等级logger1.debug(&#x27;debugO&#x27;)logger1.info(&#x27;info&#x27;)logger2.info(&#x27;info&#x27;)logger1.error(&#x27;error&#x27;)def warn_msg(): logger1.warn(&#x27;warn msg&#x27;) warn_msg2()def warn_msg2(): logger2.warn(u&#x27;warn 信息&#x27;) logging_error.error_demo()warn_msg() 当然，logger还有别的调用方法，不过这应该就够了，具体要怎么实现，就去找官方文档了。预防针： 多种配置方法、日志重复输出:见此 lambda函数排序123456aaa&gt;&gt;&gt; [&#123;&#x27;time&#x27;: 1&#125;, &#123;&#x27;time&#x27;: 3&#125;, &#123;&#x27;time&#x27;: 2&#125;]sorted(aaa, key = lambda x: x[&quot;time&quot;])&gt;&gt;&gt; [&#123;&#x27;time&#x27;: 1&#125;, &#123;&#x27;time&#x27;: 2&#125;, &#123;&#x27;time&#x27;: 3&#125;]sorted(aaa, key = lambda x: x[&quot;time&quot;], reverse=True)&gt;&gt;&gt; [&#123;&#x27;time&#x27;: 3&#125;, &#123;&#x27;time&#x27;: 2&#125;, &#123;&#x27;time&#x27;: 1&#125;] Mock使用: unittest 12345678910mock.patch.object: Mock # 一个类, 后接方法mock.patch: Mock # 一个方法, 按路径@mock.patch(&quot;databases.wx_service.get_user_base_info&quot;)@mock.patch.object(wx_service.WeChat_OAP, &quot;send_template_msg&quot;)def test_create_weawarning(self, mock_send_template_msg, mock_get_user_base_info): # 装饰器生效从内到外, 传入参数顺序, 从左到右 pass mock_send_template_msg.return_value = &#x27;&#x27;/&#123;&#125;/[]/() 皆可 设定mock返回值 mock_get_user_base_info.side_effect = [&#x27;&#x27;/&#123;&#125;/[]/(), &#x27;&#x27;/&#123;&#125;/[]/()] 设定每次调用mock函数依次返回返回值","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"python","slug":"note/python","permalink":"https://ianvzs.github.io/categories/note/python/"},{"name":"learning","slug":"note/python/learning","permalink":"https://ianvzs.github.io/categories/note/python/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"python","slug":"python","permalink":"https://ianvzs.github.io/tags/python/"}]},{"title":"Japanese Learning","slug":"japaneseLearning","date":"2016-11-07T16:00:00.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2016/11/08/japaneseLearning/","link":"","permalink":"https://ianvzs.github.io/2016/11/08/japaneseLearning/","excerpt":"","text":"より、ほど2月は 1月より ずっど 寒いです。 1がつは 2月ほど さむくないです（寒くない）。 ーーーー比较 前，肯定，后否定。 1月より 2月ほうが 寒いです。 家族で誰が 一番歌が上手ですか。 ーーーより被比者 ほが选定者、更加者 ーーーで：划分范围 いちばん：最高 1月と 2月と とどちらが 寒いですか。 ...2月のほうが寒いです。 ーー二选一句型。...と..と 答句：のほうがーー更～冷。 ほうが いいです 一类形/二类形 ほうが いいです いる：犬がいる 有狗 N-&gt;N 窗那儿有的人 变化いー＞く +なる（なります) だー＞に +する（します） 成为…变成… 使成/变为…前者，无主观后者有主观要变 二类形/名 に なります …に します变成某种N ーーー性质状态发生变化 后者因主语意志、动作引起 電気を消し（けし）で、暗（くら）くします。 もう春になったから、暖かくなる。 （あたたかい） 夜（よる）に なりました。部屋が暗くなりました。 名词に します。要什么 息子は 医者に なります。 話を 簡単（かんたん）に します。 今年（ことし）七歳に なりました。 欲しい なりました だー＞なこの会社で歌が一番上手な人はだれですか。 ーー森さんだ+と思（おも）います 并列一类形 て 一类形(いー＞く) 二类形 で 二类形 名1 で 名2 动て+います 词语细分音（おと）：物体发出 声（こえ）：人、动物意志物发出 できるだけ 軽い（かるい）します。ーー尽量…… 假定+れば：現実を直視なければ．人間変わらないんだ。 直視ければ んだ＝！！…れば、…ほど …れば、…だけ 越…越…前者 .^. 表程度 后者 .^. 表两件事物食べれば食べるほど美味しいですよ。 〜 、〜 意愿邀请…たい ゲエム(game)をしたいです。 勉強しくないです。…ましょう/ませんが もう遅(おそ)いですから、寝(ね)ましょう。…ましょうか 暑いですから、クーラーを(くーらーを)つけましょうか。 あっ、雨(あめ)が降っていますね。傘を貸(か)しましょうが。お見合い(おみあい)故郷へ帰りました。 回家相亲（有个老家的词，打不出来哦 実家(じっか)貌似促音的听不出来……） 词性转换V-&gt;N:..+こと..ことが できます ケーキを作ることが できますか。 ...は..ことです 仕事(しこと)は日本語を教(おし)えることです。 ..前に ご飯を食べる前に手(て)を洗(あら)っとください。食事（しょくじ） N-&gt;N:…+ところあの 窓（まど）のところに いる人は誰ですか。 ..那儿（人也可+）","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"language","slug":"note/language","permalink":"https://ianvzs.github.io/categories/note/language/"},{"name":"learning","slug":"note/language/learning","permalink":"https://ianvzs.github.io/categories/note/language/learning/"}],"tags":[{"name":"Japanese","slug":"Japanese","permalink":"https://ianvzs.github.io/tags/Japanese/"}]},{"title":"编辑器使用","slug":"editer","date":"2016-10-29T08:58:56.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2016/10/29/editer/","link":"","permalink":"https://ianvzs.github.io/2016/10/29/editer/","excerpt":"","text":"Vim vim 查看日志中文乱码(2021).bash_profile1export LC_ALL=en_US.utf-8 .vimrc123set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936set termencoding=utf-8set encoding=utf-8 双管齐下, 一个解决系统配置, 一个解决vim配置 中文乱码问题(2018)在.bash_profile中增加 12export LANG=zh_CN.utf8export LC_ALL=zh_CN.utf8 即可增加中文支持。 不过，还是 12export LANG=en_US.utf8export LC_ALL=en_US.utf8 比较香，因为中文字体很难看…^_^: 2019年5月5日19点46分 vscode vs codevenvPythonCommand Palette...(Ctrl+Shift+p) 1&gt;Python: Select Interpreter 然后选择就好了. 当然不会那么安逸(.vscode/launch.json)2022-01-18 11：34 .vscode/launch.json配置(图形化都是骗人的)123456789101112131415161718&#123; // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;Python: Current File&quot;, // 自定义名称 &quot;type&quot;: &quot;python&quot;, &quot;pythonPath&quot;: &quot;&#123;配置python解释器路径&#125;&quot;, //调试程序时的工作目录，一般为$&#123;workspaceRoot&#125;即代码所在目录 &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;file&#125;&quot;, // 可直接指定文件 &quot;console&quot;: &quot;integratedTerminal&quot; &#125; ]&#125; 三兄弟查看文本 列1awk -F &#x27;,&#x27; &#x27;&#123;print $NF&#125;&#x27; , 分隔符 $NF 末尾 同理也可 $1 $1, $3 表示1列+3列,并不含2列 find + vim 查找打开一条龙1find * -name &quot;*wd.csv&quot; -exec vim &#123;&#125; \\; 来自find --help的解释: -exec COMMAND ; -exec COMMAND &#123;&#125; + -ok COMMAND ;-exec兼容多条命令, bash监控;,但find也用;中断,所以在bash运行需要转义一层….也就变成了\\; Grep排除某(些)文件(夹)文件:--exclude= 文件类型:1grep &quot;get_wx_mapping&quot; . -r --exclude=*.&#123;log,&#125; &#123;&#125;中貌似必须有,， 也就是说必须传入为列表， 不然不生效， 倒和Python的tuple类型有些相像。 文件夹:--exclude-dir= 1234个:grep &quot;get_wx_mapping&quot; . -r --exclude-dir=log些:grep &quot;get_wx_mapping&quot; . -r --exclude-dir=&#123;log,__pycache__&#125;","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"杂笔记(Note)","slug":"notes/note","date":"2016-10-28T16:00:00.000Z","updated":"2022-06-15T07:32:39.333Z","comments":true,"path":"2016/10/29/notes/note/","link":"","permalink":"https://ianvzs.github.io/2016/10/29/notes/note/","excerpt":"","text":"Swift：[Swift教程]&gt;https://github.com/ipader/SwiftGuide; Swift 开源项目精选:&gt;https://github.com/ipader/SwiftGuide/blob/master/Featured.md SwiftGuide:&gt;https://github.com/ipader/SwiftGuide/blob/master/Featured-Articles.md Swift，以上。 Pelican：高亮显示Markdown:void main() &#123; printf(&quot;高亮？&quot;); // 另起一行 首行缩进，书写即可 &#125; 标题：在编辑文字的时候，在前面加上“#”号，可以将之后一行文字作为标题大字体显示，编辑中瞎按，手误敲出来的字符，结果却很有用呢。或许其他字符也有作用，不过这已经满足日常编辑所需，不做过多探究了。充实内容，往往是首要的。 利用Disqus添加评论系统：在此网站注册一个帐号，在设置中找见shortname，应该为自己设置。 然后在Pelicanconf.py这个配置文件中添加 :::iidentifier DISQUS_SITENAME = “yours shortname” 贴图片：在国内找了一个Z4A图床，感觉不错。 注册完毕，上传好图片应用链接自动生成，直接诶复制粘贴即可。HTML、BBCode、Markdown的，另外分为完整图片，中等图片，缩略图三种不同尺寸的链接。感觉良心。另外，点击图片后跳转图床，可以查看原图片文件，更是舒心赏心悦目～ 免费使用，极力推荐。只不过图片不能加入缩进后的“代码栏”。 数学公式： $ $e^{i\\pi} + 1 = 0$ $ $之间无空格 $$e^{i\\pi} + 1 = 0$$ 失败……插入插件失败。之后有需要时再查找原因。(不过这个图床已经废了。……默哀) Linux 嵌入式C編程Git 协助开发提交代码之类参考流程（复制于 &gt;https://github.com/numbbbbb/the-swift-programming-language-in-chinese）有些朋友可能不太清楚如何帮忙翻译，我这里写一个简单的流程，大家可以参考一下：首先fork我的项目把fork过去的项目也就是你的项目clone到你的本地在命令行运行git branch develop来创建一个新分支运行git checkout develop来切换到新分支运行git remote add upstream https://github.com/numbbbbb/the-swift-programming-language-in-chinese.git 把我的库添加为远端库 运行git remote update更新 运行git fetch upstream gh-pages拉取我的库的更新到本地 运行git rebase upstream/gh-pages将我的更新合并到你的分支 这是一个初始化流程，只需要做一遍就行，之后请一直在develop分支进行修改。 如果修改过程中我的库有了更新，请重复6、7、8步。 修改之后，首先push到你的库，然后登录GitHub，在你的库的首页可以看到一个pull request```按钮，点击它，填写一些说明信息，然后提交即可。 关于Pelican这个文章写的完完全全了：&gt;http://www.wengweitao.com/shi-yong-pelican-github-pagesda-jian-ge-ren-bo-ke.html VimVim中添加多行注释or删除：使用Ctrl+v进入VISUAL BLOCK状态 然后上下移动光标选择行数，输入I，改为INSERT(paste)状态，键入内容按下Esc结束，即可。 删除则为选中之后直接按删除功能键如：d、c皆可，即可删除所选一列 BlogPelicanPelican Static Site Generator, Powered by Python：Pelican是python语言写的静态网站生成器。因为之前一直弄不好Jekyll 犯不着掉在这一颗树上，所以搜到了此同类软件。 网上的那些教程不知道为什么鲜有一次效仿成功的，都是各种问题。真心他们没有遇见过吗？因此我也不自己贴这个教程了，除非那一天弄懂了那些问题所在，否则不过张贴一些网上现有的示例而已，而且还是不能保证完全正确的示例，没有任何价值。 1Date: 2016-06-18 Title:The 2st Blog Tags: 2st,pelicanのはじて初体験 Slug: test2 就像这样 接下来将本地的更到Gite: 2016-06-18tHub，至此就算告一段落。未能解决的问题还有很多，换言之其实就是问题们还没着手去解决。 例如，回车符怎么敲现在都不知道，一篇文章只能这么一条龙一直打下去。真是囧…。另外没法添加链接，旁边那个邮件的地址都还是别人的——这个主题的开发者。如果搞清这两处，估计就能不再去研究别的功能了，毕竟只是一个博客，能更看的过去就好。哈。 另外，将用到的命令在此备份 make html———— make serve———— output文件夹内： git init———— git add .———— git commit -m ‘first commit’ ———— git remote add origin &#103;&#105;&#116;&#x40;&#x67;&#x69;&#116;&#x68;&#x75;&#98;&#x2e;&#x63;&#111;&#109;:IanVzs/IanVzs.github.io.git———— git push -u origin master 此外刚刚发现编辑时首行空格开始则将此段红色高亮显示 就像这样 就像这样并不会… 只不过在刚开始。 不过应该是汉字缩进，并且上一行没有内容，会有高亮显示。貌似是为了方便写程序？或许程序可以用这样的方式来插入，而不需要用那个专用的高亮语句:::*er什么的。 然而事实并不像以上那么顺利……上传依然错误频出 所以接下来是成功代码依次再排列 git init 1234567891011git add -Agit remote remove origingit remote add origin https://github.com/IanVzs/IanVzs.github.io.gitgit add -Agit push --set-upstream origin master -fgit initgit add -Agit remote remove origingit remote add origin https://github.com/IanVzs/IanVzs.github.io.gitgit add -Agit push --set-upstream origin master -f 并且之前写在此处的更新文章也一直没法更新出来，所以将第二篇拆分了，分两个文件来上传，否则只看那个成功update 实在有不信任感觉，现在如果这篇文章还是无法更新，那真的是…… 如果能的话，看来一篇文章还有字数限制？ 应该没 按理，更新后的文件也不是一个文件了，我也换了文件名都不能更新其内容是在令人不解。 现在呢，就感觉顺手多了，只需要 git init git add . git git commit -m “hia” git push –set-upstream -f 即可。 现在，创建完新的 之后，官网有了详细的说明： 123456echo &quot;# ianvzs.github.io&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin https://github.com/IanVzs/ianvzs.github.io.gitgit push -u origin master 简单明了。 hexo而之后因为其主题我选的不好，然后又觊觎nodejs，所以将blog使用hexo来写了。以下是使用教程了——title: Hello World Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 修改配置blog根目录下_config.yml, 以及themes下_config.yml 连接github:1234deploy: type: git repo: https://github.com/*******/**.git branch: master 1npm install hexo-deploy-git --save themes hueman主题的图片配置地址为: /themes/hueman/source/css/images 可在themes/hueman/_config.yml中进行修改各项图片配置 Gitgit 版本切换将项目克隆之后，可通过 12345678910111213$ git tag // 查看tag&gt; v1&gt; v2&gt; v3$ git show v1 //根据tag 查看版本号&gt; tag v1&gt; Tagger: user&gt; Data: Fri May 23 17:47:00 2018 +0800&gt; &#x27;为了部落&#x27;&gt; commit 5b123b31h4bvb31&gt; Aurhor user&gt; 等$ git reset --hard 5b123b31h4bvb31 // 根据版本号回退版本 部署到服务器在部署到服务器的时候，发现有‘node’: No such file or directory的错误，解决办法是创建软连接： 1ln -s /usr/bin/nodejs /usr/bin/node 另外，直接拷过去的blog项目没法用hexo直接运行…解决办法是： 1// 并没有解决啊！！！！ (⊙﹏⊙)，╮(╯-╰)╭其实是npm在服务器apt安装的版本太低了… 在官网下了最新版，然后再次通过新版npm安装hexo就可以直接用了。 2021-04-21emmmmm如今重新再次翻看，觉得o(∩∩)o…哈哈。这次找了个不错的模板，比之前用的没有分页强多了，而且还有了搜索功能。简直完美符合平时查阅的需求。","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"Something","slug":"note/Something","permalink":"https://ianvzs.github.io/categories/note/Something/"}],"tags":[{"name":"经验笔记","slug":"经验笔记","permalink":"https://ianvzs.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%AC%94%E8%AE%B0/"}]},{"title":"Make things easy and enjoy","slug":"makeThingsEasyAndEnjoy","date":"2016-10-08T08:58:56.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2016/10/08/makeThingsEasyAndEnjoy/","link":"","permalink":"https://ianvzs.github.io/2016/10/08/makeThingsEasyAndEnjoy/","excerpt":"","text":"命令行的简便生活 💦🤣 apt 安装前查看库里版本1sudo apt-cache madison kdenlive 4K显示器软件不适配导致的字太小问题在路径: /usr/share/applications下将对应的.desktop文件使用文本编辑器打开,将Exec修改为: 1Exec=env QT_DEVICE_PIXEL_RATIO=2 /opt/resolve/bin/resolve 主要是增加env QT_DEVICE_PIXEL_RATIO=2, 上述例中所示为达芬奇的配置. (不过很可惜它并不能和我的AMD 5700g+Ubuntu22.04+不知哪儿来的驱动一起工作. 虽然确实变好了.) 切换用户默认终端程序 赢在起跑线: useradd -s /bin/bash ian 力挽狂澜: usermod -s /bin/bash ian 奋起反抗: chsh + 按提示操作 Github Personal access tokensgithub 干掉了https账号密码pull push 之后https pull push 专用url 4k码字更改语言1234export LC_ALL=C# 改了确实大多数成英文了，不过树莓派汉化太狠了，console-setup里还有若干是中文就很蠢...unset LC_ALL# 改回原始 更改tty1字体大小1sudo dpkg-reconfigure console-setup 操作粘贴板xsel 将输出存储到粘贴板1echo &quot;ashsaihs&quot; | xsel -i -b 输出粘贴板信息1xsel -o -b 由xsel --help可得-i -o分别代表标准输入输出(input output)-b代表: -b, –clipboard Operate on the CLIPBOARD selection 美化themesOrchisFlatabulousXFCE Flatabulous 图标12sudo add-apt-repository ppa:numix/ppasudo apt install numix-icon-theme-circle 文件编码格式嗅探12pip install chardetpython 1234f = open(&quot;file.path&quot;, &quot;rb&quot;)bdata = f.read()f.close()result = chardet.detect(bdata) debian增加docker用户组,优化每次sudo问题摘抄自这里 检查是否已有docker用户组1cat /etc/group | grep docker 1无则创建1sudo groupadd docker 添加指定用户到docker用户组1sudo usermod -aG docker &#123;用户名&#125; 使用1检查2是否成功 重启docker1sudo systemctl restart docker 给.sock添加权限1sudo chmod a+rw /var/run/docker.sock 检查是否成功12su &#123;用户名&#125;docker ps -a 使用各种跳板之后的远程文件传输sz &amp;&amp; rz安装1234#mac安装brew install zssh#linux安装sudo apt-get install zssh 取代ssh连接1zssh username@xxx.xxx.x.x 使用1234567891011cd destination_dir #进入到目的地目录输入crtl+@组合键(mac是command+@)切换到zssh -- 2022-06-08 发现mac也是`control`+@ 即(`shift+2`和键盘布局有关)cd orgin_dir #进入源目录sz example.txt #上传文件exit #退出zsshsz 在服务器上准备要下载文件sz abcde.py输入crtl+@组合键(mac是command+@)切换到zsshcd destination_dir #进入到下载目录rz #接收下载文件 在执行上传下载过程，开始时在界面上体现不太明显，需要耐心等待一下 诗句123sudo apt install fortunes-zh# 显示fortune 代码量统计12345678910111213141516171819202122232425262728293031$ cloc . 6605 text files. 5869 unique files. 1049 files ignored.github.com/AlDanial/cloc v 1.86 T=6.47 s (862.2 files/s, 137709.8 lines/s)--------------------------------------------------------------------------------Language files blank comment code--------------------------------------------------------------------------------JavaScript 4200 69941 83775 452071HTML 169 42890 164 69664JSON 306 62 0 51362Markdown 363 17792 0 49232CSS 135 1670 901 14540Stylus 131 1401 1112 6947XML 8 3004 1289 5010TypeScript 92 881 2953 4684SVG 6 0 1 4299EJS 105 49 15 1921YAML 55 71 117 1564Bourne Shell 1 163 112 791DTD 1 179 177 514make 5 42 8 114Nix 1 1 0 19Bourne Again Shell 1 5 13 7zsh 1 4 13 7DOS Batch 1 0 0 5CoffeeScript 1 1 0 0--------------------------------------------------------------------------------SUM: 5582 138156 90650 662751-------------------------------------------------------------------------------- xfce添加屏幕分辨率Virtual1: 使用vmware虚拟出来的显示器名称 具体执行时替换之 123xrandr --newmode &quot;1920x1080_60.00&quot; 173.00 1920 2048 2248 2576 1080 1083 1088 1120 -hsync +vsyncxrandr --addmode Virtual1 &quot;1920x1080_60.00&quot;xrandr --output Virtual1 --mode &quot;1920x1080_60.00&quot; 给用户添加sudo权限echo: 使用vim添加这行比较保险 1234567chmod u+w /etc/sudoersecho &#x27;&#123;username&#125; ALL=(ALL) ALL&#x27; &gt; /etc/sudoerschmod u-w /etc/sudoers=======## 查看端口占用```bashnetstat -ntulp | grep 80 find 文件查找今天(2018年12月12日，17点08分)在众多文件里找一个文件的时候… 想到find命令。不过之前没有怎么了解过，所以…我居然用了tree | grep filename.filetype来找东西。 结果路径太深——就最多确认了此文件的存在性。随后，才知道find要加-name参数。 emm…不过对于find多功能来说也说得过去。 随后便有了以下这个命令: 1find . -name &quot;cifar.py&quot; -exec vim &#123;&#125; \\; 没错~，查找之后并编辑——😄除此之外，当然可能用于 rm、grep等去替换vim进行操作。其中，&#123;&#125;自然时代表匹配文件的路径。 如果不止一个那么…就： vim为例，会关闭一个窗口再打开另一个😓另外，配合grep查找文本内容的时候，需要在最后面加-print否则只有匹配文本，不显示文件路径。 Windows 转换磁盘分区格式方法/步骤11.U盘引导，进入PE系统 2 用pe进去，找到运行输入cmd 3输入”Diskpart”(不用输入引号，下同)，并按回车，进入操作界面 4输入：”list disk”，查看磁盘信息。一般会出现两个选项，一个是你的硬盘，一个是U盘，要注意区分。 5输入：”select disk 0”，选择disk 0为当前操作的磁盘（也就是电脑的 硬盘） 6输入：”Clean”，清空当前磁盘分区 7输入：”convert mbr”，转换为MBR分区。 8OK，搞定，可以安装WIN7了 Windows远程桌面mstsc # WIn自带应用，不过用的时候得关闭防火墙就很伤 Windows 输入法故障ctfmon.exe win+R 执行此，重启输入法 Win 安装Ubuntu#在powerShell中管理员运行 Enable-WindowsOptionalFeature -Online -FeatureName Microsoft- Windows-Subsystem-Linux Windows 自启动项目录C:\\Users\\Administrator\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 在此目录下添加入快捷方式则在系统启动之后自动加载，但会有一些延时，不同于直接定义的自启动项，算是优先级最落后的项目吧 Windows 查看电池使用情况powercfg /BatteryReport # 适用于Win8+ Python Pippip install -r *.txt # 从*.txt 文件读取需要安装的插件列表 win Ubuntu 时间不一致timedatectl set-local-rtc true #采用本地时间 推荐 Ubuntu 升级系统sudo update-manager -c -d #会检测是否有系统更新， #如果都更新完毕， #则提醒有新版本系统是否更新 Windows 更新系统错误dism++ 你值得拥有 另外：无法连接到更新服务。我们将稍后再试，你也可以立即进行检查。如果问题仍然存在，请确保你已连接到 Internet。可能是本地组策略中的windows更新的“指定Intranet Microsoft更新服务位置”被更改过 解决办法为 gpedit.msc 打开“本地组策略编辑器”展开“计算机配置”—“管理模版”—“Windows组件”—“Windows 更新”（专业版称为Windows Update） “指定Intranet Microsoft更新服务位置”，点击“未配置” Ubuntu 桌面显示问题卸载 ibus 输入法，会出现桌面显示不完全的情况，任务栏显示，启动栏消失，键盘快捷键无法使用。解决办法是重新安装 Unity 之后启动Unity 就会重新打开桌面环境…其实是又重新安装了 ibus 嗯……… Vim 设置Tab空格数:set tabstop=4 #添加至用户vim配置文件： .vimrc 下即可 正则表达式作为短小精悍的东西嘞，今天在限制密码类型和长度的时候尝尽了甜头。但在分类时…不好分，应该单独写一个笔记的，但短小精悍嘛，所以就放在命令行这里了。 import re # 好吧，其实无所谓的，因为下面并没有用到Python正则模块 a = QtCore.QRegExp(&quot;[A-Za-z]&#123;0,5&#125;[1-9][0-9]&#123;0,5&#125;&quot;) a = QtCore.QRegExp(&quot;[a-zA-Z0-9]&#123;0,12&#125;$&quot;) a = QtCore.QRegExp(&quot;[a-zA-Z0-9]+$&quot;) a = QtCore.QRegExp(&quot;[a-zA-Z0-9\\,\\.\\\\\\!\\?\\#\\$\\%\\^\\&amp;\\*\\(\\)\\)_\\_\\=\\`\\+]+$&quot;) 这里的[]中内容是输入范围，&#123;&#125;中的则是长度限制，而+就是不限长度 与*类似。 $ 是结尾标志。 over。 闲的没事找事记：安装了一个美国版的windows 10 pro N 结果字体缺失，系统默认编码方式是Ascii不是utf……导致程序中的输出中文都出现问题。结果在这些不构成生产力的份儿上浪费时间，真是闲的没事找事… Vim查看编码格式 `:set fenc` 设置文件格式`:set fileformat=unix`或者`:set fileformat=dos` ——针对于换行符 set tabstop=4、set expandtab前者是一个tab的长度，后者是tab换为空格… GoodAppsNitrux、Flatabulous-master：主题，图标 用来美化很漂亮，图例样式可以参看这两者的Github。 GoldenDict：一款词典，其可以添加网络翻译源，还可以自行下载本地翻译文件，本地内容我下载的含有：日汉、汉日、英牛津，朗道，还有本本草纲目……没错，确实还有科普类的翻译源。各种奇异翻译本都有。 Xware：一款迅雷的替代，网络远程下载，完全能当一个没有广告的迅雷来使。 只不过需要账户密码，还有，在安装完毕之后，需要预先设置一番，将Xware托管改为用户态upstar，或者简单的自动启动。否则会显示ETM 没有链接，不能使用。另外将挂载，实际作用是下载保存位置，也设置一下。这么长时间了，英文路径应该养成习惯…… MyPaint：画图工具，很好使。 Chrome:这个浏览器不用说，这里介绍的是关于它修改hosts文件之后可能仍然无法使用谷歌搜索的问题。 1.因为，默认的是http，故显示已被重定向啊，啥的。只要在地址栏前输入https就可以正常访问了。2.当然，这样的话无法使用网页里的按钮“使用谷歌搜索”，所以需要修改其默认。可以在Chrome://net-internals/ 中，找见HSTS选项卡，Domain中输入想要默认强制使用https的网址。（PS：因为我的使用google自动跳转谷歌香港，所以这里用google.com还是不行的，得加上.hk的后缀。）3.以上修改方法应该只能设置一个默认网址呢，不过一个google搜索就够了…… 嗯，我要求比较低。 至于其他浏览器，大概是默认https的，因为可以直接访问嘛。自然还有很好的别的稍微专业的工具，这个会在之后持续更新出来，用学习笔记的形式（而且，等我学会在文章里添加链接啊，图片啊之后）。以上入门级、常用级的也会持续更新的～ 下载链接我以及之后都不会贴出来，嗯，毕竟没有永远保存的，链接经常失效。自行搜索总是好的，还能顺便了解一下这块软件的使用方法，以及类似替代软件的出现。 Nethack：終端運行的一款地牢遊戲，相當高的自由度和隨機程度，除卻一切怪物和地圖都是用符號來代替，戰鬥過程就是用文字信息來描述，在創造和思索方面簡直一流。以後有空閒肯定要玩一玩～ Virbox ：sudo mount /dev/cdrom // ^^^目標地^^^ //掛載光盤 sudo mount -t vboxsf //^^Name^^ ^^^目標地^^^ //掛載虛擬機共享文件 下面是其他软件的学习笔记：（等待更新——） Linux：嗯，这是个软件…详见《Linuxのノート》 Pelican :静态网页编辑生成工具。 keywords：Python、markdown Blender：開源建模，動畫軟件。 快捷鍵記錄：N、T //編輯欄呼出、隱藏 T //側重物體，N側重編輯窗口 B //選擇 Tab //模式切換 Ctrl+U //用戶界面保存 Z //物體顯示樣式切換 線框、透視 H //刪除 G //移動 musicbox：Linux 命令行下的 網易雲音樂 。夠精簡夠豐富，實爲經驗驚豔。 基於Python：&gt;https://github.com/darknessomi/musicbox xSwipe：多指触控软件。通过将触控板手势映射成快捷键，可以支持甚至五指操作，还有侧边功能。在github中搜索xSwipe即可，其中有详细安装说明。之后可以在.conf文件中查看和修改映射快捷键。另最后如果不能运行，可能需要注销重启电脑方可。运行 perl xSwipe.pl即可执行。 OpenCV：开源计算机视觉库。 简单记录一下编译过程：(其實沒啥用的，自己爬官網找安裝教程去，基本沒用。) 1. 解决依赖，编译工具sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev` 2. github 下载源程序git clone https://github.com/opencv/opencv.git 3. Building OpenCV from Source Using CMake, Using the Command Linecd ~/opencv mkdir release cd release cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 4.make sudo make install all from &gt;http://docs.opencv.org/2.4/doc/tutorials/introduction/linux_install/linux_install.html // (或許安裝過程就這句有用 23333) Thanks for your teaching. Simplenote:一款笔记软件，支持markdown编辑，很轻量、只能记录文字有点儿伤。不过有Linux版就很爽。而且同步速度、启动速度都很迅速。界面简单到不行。手机一次不幸刷机之后，有道云笔记懒得装，之后就用此软件吧… scpserver copy? 这个简写不晓得，不过确实是适用于远程连接传输文件的… 12scp ian@123.123.41.3(😀):/home/ian/nihou.txt ./filesscp ./files ian@123.123.41.3(😀):/home/ian/nihou.txt 删除Win系统服务1sc delete serverName tmux丰富纯文字终端窗口，可以创建终端副本(反正也是我取得名字)—–类似于win的多桌面。也可以分割终端(界面类似vim分割)l–这便是类似于win的多窗口了。 (官方翻译: ‘窗格’？) 进入: tmux 退出: exit 类似于vim命令模式： ctrl+b以下简写为CL_B。 创建多桌面: CL_B + c 查看全部窗口，类似win+Tab: CL_B + s 使用窗口号切换桌面: CL_B + NUM 关闭当前窗口: CL_B + &amp;,emm直接exit… 创建多窗口: CL_B + “ (垂直上下)、CL_B + % (水平左右) 调整窗口位置、大小 CL_B + space (默认布局轮换) 显示窗口编号: CL_B + q 暂时最大化当前窗格: CL_B + z 切换到下一个窗格: CL_B + o 对换窗格位置: CL_B + CL_O(ctrl + o) 设置复制 12set-window-option -g mode-keys vi #可以设置为vi或emacsset-window-option -g utf8 on #开启窗口的UTF-8支持 CL_B + [ Space空格开始选择(可使用?,/vi工具辅助定位) Enter回车确认选择 CB_B + ] 可粘贴 必须保证以上全在Tmux中进行哈 启用鼠标触控板 1set -g mouse on Termux类似于WIN端的Subsystem——其实更像Ubuntu下的虚拟终端。 不过这东西功能强大，除了将安卓里的Linux发挥出来。还有Termux API来调用手机的底层接口。 ssh与手机连接其实应该放在ssh的操作里面？ emm，还是就这儿吧。 *pc**电脑生成密匙,无视密码设置全部回车 1ssh-keygen -t rsa **电脑开启sshd服务,用于手机的ssh连接到电脑拷贝id_rsa.pub内容 1systemctl start sshd 然而我用的是win子系统所以：sshd re-exec requires execution with an absolute path phone**手机连接拷贝 1$HOME/.ssh/authorized_keys -&gt; 不管用什么复制，然后放到这个路径就好。 **查看手机的用户名 1whoami **开启服务 1sshd -p 9000 *pc连接到手机 1ssh u0_222@192.168.1.14 -p 9000 Over, 其余问题查看文件权限？ 不过还是自建文件.ssh出错率为0吧。 2018年12月4日11点27分,当我反过来操作的时候… 嗯，果然在权限这里出问题了…另外，电脑端开启sshd的时候用的绝对地址… 因为是Syb？ 12chmod 700 ~/.sshchmod 600 ~/.ssh/authorized_keys 😓 快捷键(有用的音量键？)显示扩展功能按键 方法一: 从左向右滑动,显示隐藏式导航栏,长按左下角的KEYBOARD. 方法二: 使用Termux快捷键:音量++Q键 常用快捷键 Ctrl键是终端用户常用的按键 – 但大多数触摸键盘都没有这个按键。为此，Termux使用音量减小按钮来模拟Ctrl键。在触摸键盘上按音量减小+ L发送与在硬件键盘上按Ctrl + L相同的输入。 Ctrl+A -&gt; 将光标移动到行首 Ctrl+C -&gt; 中止当前进程 Ctrl+D -&gt; 注销终端会话 Ctrl+E -&gt; 将光标移动到行尾 Ctrl+K -&gt; 从光标删除到行尾 Ctrl+L -&gt; 清除终端 Ctrl+Z -&gt; 挂起（发送SIGTSTP到）当前进程 音量加键也可以作为产生特定输入的特殊键. 音量加+E -&gt; Esc键 音量加+T -&gt; Tab键 音量加+1 -&gt; F1（和音量增加+ 2→F2等） 音量加+0 -&gt; F10 音量加+B -&gt; Alt + B，使用readline时返回一个单词 音量加+F -&gt; Alt + F，使用readline时转发一个单词 音量加+X -&gt; Alt+X 音量加+W -&gt; 向上箭头键 音量加+A -&gt; 向左箭头键 音量加+S -&gt; 向下箭头键 音量加+D -&gt; 向右箭头键 音量加+L -&gt; | （管道字符） 音量加+H -&gt; 〜（波浪号字符） 音量加+U -&gt; _ (下划线字符) 音量加+P -&gt; 上一页 音量加+N -&gt; 下一页 音量加+. -&gt; Ctrl + \\（SIGQUIT） 音量加+V -&gt; 显示音量控制 音量加+Q -&gt; 显示额外的按键视图 Rdfind替代方案Rdfind是命令行的, DuplicatePhotoFinder1.6.3是有UI的, 可以展示出内容, 不过很傻, 不能多选一次删除, 只能一个一个删除…..所以我做了一个托管鼠标点击器. 如下 使用Rdfind 进行重复文件查询, 然后删了, 节省磁盘空间. 不过我准备自己做一个, 更方便删减图片, 所以以后应该会用自己做的, 这个就留下参考吧.[^_^]: 2021-04-22 查询重复drfind /Image/`, 结果报表存于当前目录`results.txt 终端输出rdfind -dryrun true /Image 删除空文件和重复文件rdfind -deleteduplicates true -ignoreempty false /Image 删除重复文件rdfind -deleteduplicates true /Image 鼠标自动点击选择点, 不到1s一点, 终端无法立即实时中断, 估计要用上Listener不过现在这样也可以啦. 123456789101112131415161718192021222324252627import timefrom datetime import date, datetimefrom pynput import mousefrom pynput.mouse import Button, Controllermouse = Controller()sign_start = Falseprint(&quot;请将鼠标移动到指定位置, 输入`r`开始.&quot;)str_input = Noneposition_loop = Nonewhile 1: str_input = str_input or input() if str_input == &#x27;r&#x27;: position_loop = position_loop or mouse.position mouse.position = position_loop # mouse.move(position_loop[0], position_loop[-1]) mouse.press(Button.left) time.sleep(0.2) mouse.release(Button.left) print(f&quot;&#123;datetime.now()&#125; - clicked - &#123;position_loop&#125;.&quot;) time.sleep(0.4) else: print(&quot;输入错误, 程序结束.&quot;) break","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"daily Notes","slug":"dailynotes","date":"2016-07-13T16:00:00.000Z","updated":"2022-06-15T07:32:39.332Z","comments":true,"path":"2016/07/14/dailynotes/","link":"","permalink":"https://ianvzs.github.io/2016/07/14/dailynotes/","excerpt":"","text":"2021年09月26日 测试一下是不是能挂视频呢： 2021年09月09日 今天重新弄了blog,增加了Makefile可以更加无闹化的操作了真是个好东西不过hexo deploy放在里面一直出问题，重新执行一遍又好了不清楚啥原因。。。分不同的make子项试试 同时也换了背景，一会儿打个release去. 缅怀 2018年12月12日 今儿开始，以后信笔记就写在上面了——本来笔记就没顺序，而考虑翻看的时候总是翻页太麻烦，emm 虽说越来越习惯grep但 …有时候还是要看网页的嘛。而新笔记的翻看率总是高过旧笔记，所以就用这个顺序~😄 Eeont size=4&gt;原因： 今天决定每天都写每日的学习总结，以此来激励。否则每天下来总觉得毫无收获，颇有空虚寂寞冷的感觉，也有当天学习的不真实感。此文章做做总概，目录的作用，详细的学习笔记就写在详细的文章下面。 因为，暑假要学习日语，所以日常生活中能用日记就尽量用了。对于培养日语语感和结构的记忆及习惯，很有作用。日语 16-07-14用于比较的句型：より ほど变化、使变化的句式。16-07-16昨天用的Winodos所以没发写了。重新记了初上的18课内容。16-07-18B站上的每晚一句感觉不错。因为是长句嘛，能够更加详细了解句子逻辑和词语使用规律16-07-19復習Pelican 16-07-14换了一个更加清明的主题，能够能好的搜索，并且显示格式也很顺眼。而且能够自动形成Tags等的文章链接。基本上满足我的写作还有以后用来搜索的需求了。而且也很简约漂亮。明天再学习一些嵌入式以及Linux的内容～ 16-07-19 插入图片：图床 评论系统：Disqus 数学公式：latex Linux 16-07-16SSH rsync VNC 等命令的学习和使用。为此，倒是专门安装了一个Ubuntu的Servery版本的虚拟机。16-07-17disk LVM16-07-18复习了一些网络部分。16-07-18Vi &amp;&amp; Vim果然在了解了一些按鍵的作用之後感覺無愧‘於編輯器之神’的稱號。輸入法不小心點成繁體了，懶得改回簡體————或許有‘懶’的比賽我能進三甲。16-07-26這兩三天看了看 嵌入式的ARM系列板開發，當然主要看了看Linux 移植一類。只不過說是教程也不過是流程吧。通篇下來基本上用的最多的語句即使 把這個這樣，那個這樣一下。具體爲什麼全然わかりませんね！ 不過也沒關係，留下來自己回頭再看看就行了。後面再看一下Qt程序的移植就可以完美收官了，在嵌入式的領域。16-08-03看完了——只不過很可惜沒有實驗板，所以不能進行實驗。開學之後在學校吧。當然，學習斷線了一些時候，嗯嗯……16-08-11musicboxNethack ————A Game 還沒玩，或者說還沒看說明手冊先瞎玩一氣。雖說有一塌糊塗，不過我有預感，這確實是一款很好的自由地牢遊戲。Blender ーー建模 動畫軟件 16-08-03重溫一下Blender，在快捷鍵上略做一些記錄，否則每次都忘……:::ideer的上一行不能为空，缩进一下，然后写就可以了。:::ideer的上一行不能为空，缩进一下，然后写就可以了。藝術 16-08-11這幾天在看《藝術概論》《什麼是藝術》《電影理論基礎》，因爲是下到Reader上了，倒也沒有開機來寫總結。之後有什麼總結之類就再另開一個文章專門記錄個人所感所得。16-8-29 终结 往后作为假期学习记录不定时更 17-04-08好东西自然要重新启动，只不过配起来有些麻烦，前些日子的.md文件也丢光了，所以一直懒得再写。实在不应该…… 18-05-15居然在公司工作时间来将博客来更了… emm 也没办法 调试时间太长，一边等结果一边儿就把博客重整了一遍。 但还有一些文章不好意思放上来，之后整理一下放呗.顺便一说，我之前18年其实也重整过一次…不过伴随着我的Ubuntu系统saybye 甚至丢失了我U盘里面保存的一些聊天记录！！！！！！！ 😔故人西辞黄鹤楼白云空载轻悠悠不识人间好颜色江边黄花两对愁 去年17年佳作~~~lul 18-06-21今天又重整了俺封装的MySQL Connecter的python库，完善了之前的查找功能和删除功能。 不过话说之前写的插入功能就是好用hhhh。 嗯~ o(￣▽￣)o 有空干脆再用python去写一个mysql的表设计程序算了~ 就类似powerDesigner在MySQL这边儿的作用，顺便也好想写一个能代替Navicat的小工具… 反正都是大家都是调用sql语句。(⊙﹏⊙) 其实发展发展我这个小库就能做了。有时间再说呗(没时间，)","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"日记","slug":"杂谈/日记","permalink":"https://ianvzs.github.io/categories/%E6%9D%82%E8%B0%88/%E6%97%A5%E8%AE%B0/"}],"tags":[{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"更新说明","slug":"更新说明","permalink":"https://ianvzs.github.io/tags/%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E/"}]},{"title":"Linux","slug":"notes/noteOflinux","date":"2016-04-08T08:58:56.000Z","updated":"2022-06-15T07:32:39.334Z","comments":true,"path":"2016/04/08/notes/noteOflinux/","link":"","permalink":"https://ianvzs.github.io/2016/04/08/notes/noteOflinux/","excerpt":"","text":"dpkg .debInstallsudo dpkg -i file.deb c l r P L s -c列出内容 -l提取包信息 -r移除一个已安装的包 -P完全清除一个已安装包 -L列出安装所有文件清单 -s显示已安装包信息 WSLwsl问题因为后面不太喜欢这种东西了,还是上了物理机. 所以就不粘贴过来了. sudo apt upgrade E: Sub-process /usr/bin/dpkg returned an error code (1) 解决sudu下 备份/var/lib/dpkg/info 新建/var/lib/dpkg/info 重新执行更新 合并/var/lib/dpkg/info 和 备份文件 完 说明非原理性解决方案, 若解决不了, 另寻他法或者需要直击灵魂. 磁盘操作NTFS一般发行版在此中可以使用ntfsfix, 不过刚才看了一圈儿, 好像, 这工具就是来源于下面所介绍的 树莓派因为没有预装ntfsfix, 所以 安装 ntfs-3g 很久远的工具: sudo apt install ntfs-3g (看3g就知道年代久远 😄) 取消挂载, sudo umount /dev/sda&#123;N&#125; 重新挂载, mount –t ntfs /dev/sda&#123;n&#125; /media/pi 就可以有读写权限了. 不然只有读的, 挺不好的. 不过在windows放了缓存在里面的话就没办法挂载为可写了， 方法是取消Win的快速启动功能后关机，不使用休眠. 磁盘查询命令12fdisk -ldf -h LVM概要（がいよう） 自弁の理解： 将零散的集合起来，再进行动态分组。 PV &gt;&gt; VG &gt;&gt; LV じゃあ作成（さくせい）：123456789pvcreat disk1 disk2 di3 ... # 集合pvs|pvdisplayvgcreat 集合name 1 2 3 ... # 集合vgs|vgdisplaylvcreat -n name -L size 集name lvs|lvdisplay 格式化磁盘:1mkfs.ext4 /dev/集name/name # 格式化此（PS：路径为所示） 注: 不过要采用这种方法来给Linux扩容的话需要之前时就选定Linux磁盘管理为LVM，否则主目录在之后不能添加lv组，也就谈不上添加。 LVMの削除（さくじょ）：123LV lvremove /dev/... VG vgremove 集namePV(物理卷) pvremove /dev/... disk LVの追加（ついか）：1234lvexpend -L +1G /dev/集name/name# 增加了空白空间resize2fs /dev/... 更新文件系统 使空白空间得以有身份（文件系统） disk VGの追加123pvcreat /dev/sdd(new)vgexpend 集name /dev/sdd 网络SSH 远程终端控制ssh root(usrname)@192.168.^.^ (IP)输入密码错误之后——就…之前解决过，然而忘了上次怎么解决的了(京东云)反正这次是等着等着突然就能连接了。 以后可得把解决方案记录到这儿ヽ(*。&gt;Д&lt;)o゜ 另外，ssh公钥🔑连接方式可以参考makethingseasy中的描写。 ping 测试连通mtr 测试网络+每个路由信息* + IP VNC 桌面远程Emmmm 当时还写了这个？现在倒是用这个在链接树莓派o(∩∩)o…哈哈(2021-04-22) 壓縮打包 tar -zxvf **.tar.gz: .tar.gz tar -jxvf **.tar.bz2: .tar.bz2tar12tar xvzf fileName.tar.gztar cvzf fileName.tar.gz targerName x: 解压 c : 压缩 Ubuntu 16.04 升级 Ubuntu 18.04___ 经尝试真的不如备份自我资料后重装……因为太…慢…了… 更新还不稳。^_^: 2018年6月5日13点44分 其实还好… 就是更新速度慢了点儿。早不到十点更新到了下午13点38分。不过基于是一键式的所以还是有多点儿好处的。更新命令 1234567sudo do-release-upgrade# 提示是没法找到可用更新…# 所以 之后增加了-c# 还是不行-d # 参数完成更新 但是python被重装了！！！！ 里面的包都没了…🐎a算了，好在软件级别的东西都还在…另外pip也损坏了，apt安装也失败，后面我就用了.py脚本重新安装，所以apt卸载再重装没试，不知道行不行。 收回前面“软件级别的都还在”，其实软件级别的也待测。 设定系统常量在用户目录下profile文件中可通过export 增加(一般来说是增加路径) 12export IAN=/mnt/c/Users/iansourse ~/.profile 之后便可通过cd $IAN 来访问win下的用户目录。当然，这个方法是在添加GoPath时注意到的。 emm 其实在/etc/profile 文件下才是系统王道 ps今年面试还碰到个问这个问题，说什么是变量….. 把我给整蒙了…..结果一番问下才发现他想问的就是放在/etc/profile和~/.profile里有啥区别， 啥是系统,用户,会话级变量.唉.. 有时候突然听到基本问题就觉得对方是不是有什么深意…^_^: 2021年4月22日11点52分 tmux 虚拟多终端类似于vim多窗口编辑一类的东西，emm 或者说图形化ubuntu使用ctrl+alt+t叫出来的东西。这么一对比的话就是无界面化的虚拟终端——那个是界面里的虚拟终端嘛。 用于解决ssh连接远程开启应用，断开后不关闭进程的方案。因为nohup好像并不稳定的样子……不过用起来… 不太了解怎么这就能够持久化了…因为毕竟是虚拟窗口，间makethingseasy中，其实…好像…大概…没什么关系吧。这两者。 最大文件数/单进程最大文件数bump fs.nr_open + fs.max-file to their largest possible values 12cat /proc/sys/fs/file-maxcat /proc/sys/fs/nr_open 今天(2021-04-22)看epoll的时候好奇看了一下,发现我的fs/file-max居然有9223372036854775807震惊一下.","categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"linux","slug":"note/linux","permalink":"https://ianvzs.github.io/categories/note/linux/"},{"name":"learning","slug":"note/linux/learning","permalink":"https://ianvzs.github.io/categories/note/linux/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"Linux","slug":"Linux","permalink":"https://ianvzs.github.io/tags/Linux/"}]}],"categories":[{"name":"note","slug":"note","permalink":"https://ianvzs.github.io/categories/note/"},{"name":"机器学习","slug":"note/机器学习","permalink":"https://ianvzs.github.io/categories/note/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"pip","slug":"note/pip","permalink":"https://ianvzs.github.io/categories/note/pip/"},{"name":"pypi","slug":"note/pip/pypi","permalink":"https://ianvzs.github.io/categories/note/pip/pypi/"},{"name":"tip","slug":"tip","permalink":"https://ianvzs.github.io/categories/tip/"},{"name":"版本兼容","slug":"tip/版本兼容","permalink":"https://ianvzs.github.io/categories/tip/%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9/"},{"name":"pyinstaller","slug":"note/pyinstaller","permalink":"https://ianvzs.github.io/categories/note/pyinstaller/"},{"name":"打包","slug":"note/pyinstaller/打包","permalink":"https://ianvzs.github.io/categories/note/pyinstaller/%E6%89%93%E5%8C%85/"},{"name":"demo_test","slug":"demo-test","permalink":"https://ianvzs.github.io/categories/demo-test/"},{"name":"code","slug":"demo-test/code","permalink":"https://ianvzs.github.io/categories/demo-test/code/"},{"name":"qt","slug":"tip/qt","permalink":"https://ianvzs.github.io/categories/tip/qt/"},{"name":"pyside","slug":"tip/qt/pyside","permalink":"https://ianvzs.github.io/categories/tip/qt/pyside/"},{"name":"install","slug":"tip/install","permalink":"https://ianvzs.github.io/categories/tip/install/"},{"name":"Dgraph","slug":"Dgraph","permalink":"https://ianvzs.github.io/categories/Dgraph/"},{"name":"图数据库","slug":"Dgraph/图数据库","permalink":"https://ianvzs.github.io/categories/Dgraph/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"docker","slug":"note/docker","permalink":"https://ianvzs.github.io/categories/note/docker/"},{"name":"learning","slug":"note/docker/learning","permalink":"https://ianvzs.github.io/categories/note/docker/learning/"},{"name":"problem","slug":"tip/problem","permalink":"https://ianvzs.github.io/categories/tip/problem/"},{"name":"gRpc","slug":"tip/problem/gRpc","permalink":"https://ianvzs.github.io/categories/tip/problem/gRpc/"},{"name":"golang","slug":"note/golang","permalink":"https://ianvzs.github.io/categories/note/golang/"},{"name":"expansion","slug":"note/golang/expansion","permalink":"https://ianvzs.github.io/categories/note/golang/expansion/"},{"name":"数据格式","slug":"note/数据格式","permalink":"https://ianvzs.github.io/categories/note/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"},{"name":"test","slug":"note/数据格式/test","permalink":"https://ianvzs.github.io/categories/note/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/test/"},{"name":"ue4","slug":"note/ue4","permalink":"https://ianvzs.github.io/categories/note/ue4/"},{"name":"learning","slug":"note/ue4/learning","permalink":"https://ianvzs.github.io/categories/note/ue4/learning/"},{"name":"web","slug":"tip/web","permalink":"https://ianvzs.github.io/categories/tip/web/"},{"name":"learning","slug":"tip/web/learning","permalink":"https://ianvzs.github.io/categories/tip/web/learning/"},{"name":"换源","slug":"tip/换源","permalink":"https://ianvzs.github.io/categories/tip/%E6%8D%A2%E6%BA%90/"},{"name":"网络(Net)","slug":"note/网络-Net","permalink":"https://ianvzs.github.io/categories/note/%E7%BD%91%E7%BB%9C-Net/"},{"name":"debug","slug":"tip/debug","permalink":"https://ianvzs.github.io/categories/tip/debug/"},{"name":"learning","slug":"tip/debug/learning","permalink":"https://ianvzs.github.io/categories/tip/debug/learning/"},{"name":"web","slug":"web","permalink":"https://ianvzs.github.io/categories/web/"},{"name":"全栈笔记","slug":"web/全栈笔记","permalink":"https://ianvzs.github.io/categories/web/%E5%85%A8%E6%A0%88%E7%AC%94%E8%AE%B0/"},{"name":"java","slug":"note/java","permalink":"https://ianvzs.github.io/categories/note/java/"},{"name":"learning","slug":"note/java/learning","permalink":"https://ianvzs.github.io/categories/note/java/learning/"},{"name":"learning","slug":"note/golang/learning","permalink":"https://ianvzs.github.io/categories/note/golang/learning/"},{"name":"python","slug":"note/python","permalink":"https://ianvzs.github.io/categories/note/python/"},{"name":"learning","slug":"note/python/learning","permalink":"https://ianvzs.github.io/categories/note/python/learning/"},{"name":"markdown","slug":"tip/markdown","permalink":"https://ianvzs.github.io/categories/tip/markdown/"},{"name":"learning","slug":"tip/markdown/learning","permalink":"https://ianvzs.github.io/categories/tip/markdown/learning/"},{"name":"vim","slug":"tip/vim","permalink":"https://ianvzs.github.io/categories/tip/vim/"},{"name":"learning","slug":"tip/vim/learning","permalink":"https://ianvzs.github.io/categories/tip/vim/learning/"},{"name":"db","slug":"note/db","permalink":"https://ianvzs.github.io/categories/note/db/"},{"name":"learning","slug":"note/db/learning","permalink":"https://ianvzs.github.io/categories/note/db/learning/"},{"name":"new Things","slug":"new-Things","permalink":"https://ianvzs.github.io/categories/new-Things/"},{"name":"手机","slug":"new-Things/手机","permalink":"https://ianvzs.github.io/categories/new-Things/%E6%89%8B%E6%9C%BA/"},{"name":"learning","slug":"note/learning","permalink":"https://ianvzs.github.io/categories/note/learning/"},{"name":"Gui","slug":"note/Gui","permalink":"https://ianvzs.github.io/categories/note/Gui/"},{"name":"learning","slug":"note/Gui/learning","permalink":"https://ianvzs.github.io/categories/note/Gui/learning/"},{"name":"language","slug":"note/language","permalink":"https://ianvzs.github.io/categories/note/language/"},{"name":"learning","slug":"note/language/learning","permalink":"https://ianvzs.github.io/categories/note/language/learning/"},{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"Something","slug":"note/Something","permalink":"https://ianvzs.github.io/categories/note/Something/"},{"name":"日记","slug":"杂谈/日记","permalink":"https://ianvzs.github.io/categories/%E6%9D%82%E8%B0%88/%E6%97%A5%E8%AE%B0/"},{"name":"linux","slug":"note/linux","permalink":"https://ianvzs.github.io/categories/note/linux/"},{"name":"learning","slug":"note/linux/learning","permalink":"https://ianvzs.github.io/categories/note/linux/learning/"}],"tags":[{"name":"Paddle","slug":"Paddle","permalink":"https://ianvzs.github.io/tags/Paddle/"},{"name":"demo_test","slug":"demo-test","permalink":"https://ianvzs.github.io/tags/demo-test/"},{"name":"install","slug":"install","permalink":"https://ianvzs.github.io/tags/install/"},{"name":"npm","slug":"npm","permalink":"https://ianvzs.github.io/tags/npm/"},{"name":"nodejs","slug":"nodejs","permalink":"https://ianvzs.github.io/tags/nodejs/"},{"name":"learning","slug":"learning","permalink":"https://ianvzs.github.io/tags/learning/"},{"name":"docker","slug":"docker","permalink":"https://ianvzs.github.io/tags/docker/"},{"name":"win","slug":"win","permalink":"https://ianvzs.github.io/tags/win/"},{"name":"rpc","slug":"rpc","permalink":"https://ianvzs.github.io/tags/rpc/"},{"name":"git","slug":"git","permalink":"https://ianvzs.github.io/tags/git/"},{"name":"golang","slug":"golang","permalink":"https://ianvzs.github.io/tags/golang/"},{"name":"expansion","slug":"expansion","permalink":"https://ianvzs.github.io/tags/expansion/"},{"name":"数据格式","slug":"数据格式","permalink":"https://ianvzs.github.io/tags/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/"},{"name":"ue4","slug":"ue4","permalink":"https://ianvzs.github.io/tags/ue4/"},{"name":"nginx","slug":"nginx","permalink":"https://ianvzs.github.io/tags/nginx/"},{"name":"keepalived","slug":"keepalived","permalink":"https://ianvzs.github.io/tags/keepalived/"},{"name":"debuger","slug":"debuger","permalink":"https://ianvzs.github.io/tags/debuger/"},{"name":"pdb","slug":"pdb","permalink":"https://ianvzs.github.io/tags/pdb/"},{"name":"gdb","slug":"gdb","permalink":"https://ianvzs.github.io/tags/gdb/"},{"name":"django","slug":"django","permalink":"https://ianvzs.github.io/tags/django/"},{"name":"missjava","slug":"missjava","permalink":"https://ianvzs.github.io/tags/missjava/"},{"name":"vue","slug":"vue","permalink":"https://ianvzs.github.io/tags/vue/"},{"name":"apache","slug":"apache","permalink":"https://ianvzs.github.io/tags/apache/"},{"name":"ajax","slug":"ajax","permalink":"https://ianvzs.github.io/tags/ajax/"},{"name":"java, springboot, mybatis, maven, learning","slug":"java-springboot-mybatis-maven-learning","permalink":"https://ianvzs.github.io/tags/java-springboot-mybatis-maven-learning/"},{"name":"Vn.Py","slug":"Vn-Py","permalink":"https://ianvzs.github.io/tags/Vn-Py/"},{"name":"gui","slug":"gui","permalink":"https://ianvzs.github.io/tags/gui/"},{"name":"socket","slug":"socket","permalink":"https://ianvzs.github.io/tags/socket/"},{"name":"markdown","slug":"markdown","permalink":"https://ianvzs.github.io/tags/markdown/"},{"name":"vim","slug":"vim","permalink":"https://ianvzs.github.io/tags/vim/"},{"name":"more","slug":"more","permalink":"https://ianvzs.github.io/tags/more/"},{"name":"less","slug":"less","permalink":"https://ianvzs.github.io/tags/less/"},{"name":"mongo","slug":"mongo","permalink":"https://ianvzs.github.io/tags/mongo/"},{"name":"mysql","slug":"mysql","permalink":"https://ianvzs.github.io/tags/mysql/"},{"name":"Sony XZ1 Compact","slug":"Sony-XZ1-Compact","permalink":"https://ianvzs.github.io/tags/Sony-XZ1-Compact/"},{"name":"python","slug":"python","permalink":"https://ianvzs.github.io/tags/python/"},{"name":"ml","slug":"ml","permalink":"https://ianvzs.github.io/tags/ml/"},{"name":"pyqt","slug":"pyqt","permalink":"https://ianvzs.github.io/tags/pyqt/"},{"name":"Gui","slug":"Gui","permalink":"https://ianvzs.github.io/tags/Gui/"},{"name":"Japanese","slug":"Japanese","permalink":"https://ianvzs.github.io/tags/Japanese/"},{"name":"杂谈","slug":"杂谈","permalink":"https://ianvzs.github.io/tags/%E6%9D%82%E8%B0%88/"},{"name":"经验笔记","slug":"经验笔记","permalink":"https://ianvzs.github.io/tags/%E7%BB%8F%E9%AA%8C%E7%AC%94%E8%AE%B0/"},{"name":"更新说明","slug":"更新说明","permalink":"https://ianvzs.github.io/tags/%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E/"},{"name":"Linux","slug":"Linux","permalink":"https://ianvzs.github.io/tags/Linux/"}]}