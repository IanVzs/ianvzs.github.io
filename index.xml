<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Ian's Blog</title><link>http://example.org/</link><description>Recent content in Introduction on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 09 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml"/><item><title>With ToC</title><link>http://example.org/docs/example/table-of-contents/with-toc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/table-of-contents/with-toc/</guid><description>Caput vino delphine in tamen vias # Cognita laeva illo fracta # Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.
Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit Natus quaerere # Pectora et sine mulcere, coniuge dum tincta incurvae.</description></item><item><title>Without ToC</title><link>http://example.org/docs/example/table-of-contents/without-toc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/table-of-contents/without-toc/</guid><description>At me ipso nepotibus nunc celebratior genus # Tanto oblite # Lorem markdownum pectora novis patenti igne sua opus aurae feras materiaque illic demersit imago et aristas questaque posset. Vomit quoque suo inhaesuro clara. Esse cumque, per referri triste. Ut exponit solisque communis in tendens vincetis agisque iamque huic bene ante vetat omina Thebae rates. Aeacus servat admonitu concidit, ad resimas vultus et rugas vultu dignamque Siphnon.
Quam iugulum regia simulacra, plus meruit humo pecorumque haesit, ab discedunt dixit: ritu pharetramque.</description></item><item><title>AI画图</title><link>http://example.org/docs/programmer/ml/stable-diffusion/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/ml/stable-diffusion/</guid><description>起手式 # 正 # best quality, (mature:1.3),perfect face, beautiful face,western, sharp focus, solo,beautiful woman,sexy,shiny skin,Navy blouse, beige shorts, soft light,cinematic lighting, sunny, dusk, outdoor,depth of field,shidudou,red_dress, 反 # (worst quality, low quality:2), NSFW, monochrome, zombie, overexposure, watermark, text, bad anatomy, bad hand,((extra hands)),extra fingers, too many fingers, fused fingers, bad arm, distorted arm, extra arms, fused arms, extra legs, missing leg,disembodied leg,extra nipples, detached arm, liquid hand, inverted hand, disembodied limb, oversized head, extra body, extra navel, (hair between eyes),sketch, duplicate, ugly, huge eyes, text, logo, worst face, (bad and mutated hands:1.</description></item><item><title>Japanese Learning</title><link>http://example.org/posts/japanese/</link><pubDate>Tue, 08 Nov 2016 00:00:00 +0000</pubDate><guid>http://example.org/posts/japanese/</guid><description>より、ほど # 2月は　1月より　ずっど　寒いです。 1がつは　2月ほど　さむくないです（寒くない）。 ーーーー比较 前，肯定，后否定。 1月より　2月ほうが　寒いです。 家族で誰が　一番歌が上手ですか。 ーーーより被比者　ほが选定者、更加者 ーーーで：划分范围　いちばん：最高 1月と　2月と　とどちらが　寒いですか。 ...2月のほうが寒いです。 ーー二选一句型。...と..と　答句：のほうがーー更～冷。 ほうが　いいです　一类形/二类形 ほうが　いいです いる：犬がいる　有狗 N-&amp;gt;N 窗那儿有的人 # 变化 # いー＞く　+なる（なります)　だー＞に　+する（します） 成为…变成… 使成/变为… # 前者，无主观后者有主观要变 二类形/名 に　なります　&amp;hellip;に　します 变成某种N ーーー性质状态发生变化 后者因主语意志、动作引起　電気を消し（けし）で、暗（くら）くします。　もう春になったから、暖かくなる。　（あたたかい）　夜（よる）に　なりました。部屋が暗くなりました。　名词に　します。要什么 息子は　医者に　なります。　話を　簡単（かんたん）に　します。 今年（ことし）七歳に　なりました。 欲しい　なりました</description></item><item><title>杂笔记</title><link>http://example.org/posts/some-notes-can-make-things-easier-and-more-enjoyable/</link><pubDate>Sat, 29 Oct 2016 00:00:00 +0000</pubDate><guid>http://example.org/posts/some-notes-can-make-things-easier-and-more-enjoyable/</guid><description>Swift： # [Swift教程] # &amp;gt;https://github.com/ipader/SwiftGuide; Swift 开源项目精选: # &amp;gt;https://github.com/ipader/SwiftGuide/blob/master/Featured.md SwiftGuide: # &amp;gt;https://github.com/ipader/SwiftGuide/blob/master/Featured-Articles.md Swift，以上。
Pelican： # 高亮显示Markdown: # void main() { printf(&amp;quot;高亮？&amp;quot;); // 另起一行 首行缩进，书写即可 } 标题： # 在编辑文字的时候，在前面加上“#”号，可以将之后一行文字作为标题大字体显示，编辑中瞎按，手误敲出来的字符，结果却很有用呢。或许其他字符也有作用，不过这已经满足日常编辑所需，不做过多探究了。充实内容，往往是首要的。
利用Disqus添加评论系统： # 在此网站注册一个帐号，在设置中找见shortname，应该为自己设置。 然后在Pelicanconf.py这个配置文件中添加
:::iidentifier
DISQUS_SITENAME = “yours shortname”
贴图片： # 在国内找了一个Z4A图床，感觉不错。 注册完毕，上传好图片应用链接自动生成，直接诶复制粘贴即可。HTML、BBCode、Markdown的，另外分为完整图片，中等图片，缩略图三种不同尺寸的链接。感觉良心。另外，点击图片后跳转图床，可以查看原图片文件，更是舒心赏心悦目～ 免费使用，极力推荐。只不过图片不能加入缩进后的“代码栏”。
数学公式： $ $e^{i\pi} + 1 = 0$ $ $之间无空格
$$e^{i\pi} + 1 = 0$$
失败……插入插件失败。之后有需要时再查找原因。 (不过这个图床已经废了。……默哀)
Linux 嵌入式C編程 # Git 协助开发提交代码之类 参考流程（复制于 &amp;gt;https://github.com/numbbbbb/the-swift-programming-language-in-chinese） 有些朋友可能不太清楚如何帮忙翻译，我这里写一个简单的流程，大家可以参考一下： 首先fork我的项目 把fork过去的项目也就是你的项目clone到你的本地 在命令行运行git branch develop来创建一个新分支 运行git checkout develop来切换到新分支 运行git remote add upstream https://github.</description></item><item><title>Make things easy and enjoy</title><link>http://example.org/posts/make-things-easy-and-enjoyable/</link><pubDate>Sat, 08 Oct 2016 16:58:56 +0000</pubDate><guid>http://example.org/posts/make-things-easy-and-enjoyable/</guid><description>命令行的简便生活 💦🤣 # 后传: [[小命令]]
VirtualBox: linux 没有权限访问共享文件夹的问题 # 错误原因及解决办法
这个自动mount的文件夹linux_share的所有者为root，所属的组是vboxsf，并且只有这两个用户有访问权限。Virtualbox的共享文件夹一般都挂载在/media下面，用ll查看会发现文件夹的所有者是root，所有组是vboxsf，所以文件管理去无法访问是正常的，解决方法是把你自己加入到vboxsf组里面。
# 把自己添加到这个vboxsf组里面: sudo usermod -a -G vboxsf {USERNAME} 需要重启机器才能生效
Delete Git Submodule # 逆初始化模块，其中{MOD_NAME}为模块目录，执行后可发现模块目录被清空 git submodule deinit {MOD_NAME} 删除.gitmodules中记录的模块信息（&amp;ndash;cached选项清除.git/modules中的缓存） git rm --cached {MOD_NAME} apt 安装前查看库里版本 # sudo apt-cache madison kdenlive 4K显示器软件不适配导致的字太小问题 # 在路径: /usr/share/applications下 将对应的.desktop文件使用文本编辑器打开,将Exec修改为:
Exec=env QT_DEVICE_PIXEL_RATIO=2 /opt/resolve/bin/resolve 主要是增加env QT_DEVICE_PIXEL_RATIO=2, 上述例中所示为达芬奇的配置. (不过很可惜它并不能和我的AMD 5700g+Ubuntu22.04+不知哪儿来的驱动一起工作. 虽然确实变好了.)
切换用户默认终端程序 # 赢在起跑线: useradd -s /bin/bash ian 力挽狂澜: usermod -s /bin/bash ian 奋起反抗: chsh + 按提示操作 Github Personal access tokens # github 干掉了https账号密码pull push 之后 https pull push 专用 url</description></item><item><title>Daily Notes</title><link>http://example.org/posts/daily-notes/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>http://example.org/posts/daily-notes/</guid><description>2021年09月26日 测试一下是不是能挂视频呢：
2021年09月09日 今天重新弄了blog,增加了Makefile可以更加无闹化的操作了 真是个好东西 不过hexo deploy放在里面一直出问题，重新执行一遍又好了不清楚啥原因。。。分不同的make子项试试
同时也换了背景，一会儿打个release去.
缅怀
2018年12月12日 今儿开始，以后信笔记就写在上面了——本来笔记就没顺序，而考虑翻看的时候总是翻页太麻烦，emm 虽说越来越习惯grep但 …有时候还是要看网页的嘛。而新笔记的翻看率总是高过旧笔记，所以就用这个顺序~😄
Eeont size=4&amp;gt;原因：
今天决定每天都写每日的学习总结，以此来激励。否则每天下来总觉得毫无收获，颇有空虚寂寞冷的感觉，也有当天学习的不真实感。此文章做做总概，目录的作用，详细的学习笔记就写在详细的文章下面。
因为，暑假要学习日语，所以日常生活中能用日记就尽量用了。对于培养日语语感和结构的记忆及习惯，很有作用。 日语
16-07-14 用于比较的句型：より　ほど 变化、使变化的句式。 16-07-16 昨天用的Winodos所以没发写了。 重新记了初上的18课内容。 16-07-18 B站上的每晚一句感觉不错。因为是长句嘛，能够更加详细了解句子逻辑和词语使用规律 16-07-19 復習 Pelican
16-07-14 换了一个更加清明的主题，能够能好的搜索，并且显示格式也很顺眼。而且能够自动形成Tags等的文章链接。基本上满足我的写作还有以后用来搜索的需求了。而且也很简约漂亮。 明天再学习一些嵌入式以及Linux的内容～ 16-07-19 插入图片：图床 评论系统：Disqus 数学公式：latex
Linux
16-07-16 SSH rsync VNC 等命令的学习和使用。为此，倒是专门安装了一个Ubuntu的Servery版本的虚拟机。 16-07-17 disk LVM 16-07-18 复习了一些网络部分。 16-07-18 Vi &amp;amp;&amp;amp; Vim 果然在了解了一些按鍵的作用之後感覺無愧‘於編輯器之神’的稱號。輸入法不小心點成繁體了，懶得改回簡體————或許有‘懶’的比賽我能進三甲。 16-07-26 這兩三天看了看 嵌入式的ARM系列板開發，當然主要看了看Linux 移植一類。只不過說是教程也不過是流程吧。通篇下來基本上用的最多的語句即使 把這個這樣，那個這樣一下。具體爲什麼全然わかりませんね！ 不過也沒關係，留下來自己回頭再看看就行了。後面再看一下Qt程序的移植就可以完美收官了，在嵌入式的領域。 16-08-03 看完了——只不過很可惜沒有實驗板，所以不能進行實驗。開學之後在學校吧。當然，學習斷線了一些時候，嗯嗯…… 16-08-11 musicbox Nethack ————A Game
還沒玩，或者說還沒看說明手冊先瞎玩一氣。雖說有一塌糊塗，不過我有預感，這確實是一款很好的自由地牢遊戲。 Blender ーー建模 動畫軟件</description></item><item><title>文本三剑客</title><link>http://example.org/docs/programmer/basetc/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2/</guid><description>grep # 一、或和过滤 # grep &amp;#34;abc\|123&amp;#34; test.log` | grep -v &amp;#34;xyz&amp;#34; 二、排除某(些)文件(夹) # 1. 排除文件: # --exclude=
2. 排除文件类型: # grep &amp;#34;get_wx_mapping&amp;#34; . -r --exclude=*.{log,} {}中貌似必须有,， 也就是说必须传入为列表， 不然不生效， 倒和Python的tuple类型有些相像。
3. 排除文件夹: # --exclude-dir=
个: grep &amp;#34;get_wx_mapping&amp;#34; . -r --exclude-dir=log 些: grep &amp;#34;get_wx_mapping&amp;#34; . -r --exclude-dir={log,__pycache__} sed # awk # 只能使用 单引号 双引号不行的呦( &amp;quot;{print $1}&amp;quot; ✗ )
awk &amp;#39;{print $1}&amp;#39; # 第一列 一、awk算数 # [[小命令#18. awk算数]]
grep 400586 sched.log.2024-05-28 | grep 条 | awk &amp;#39;{print $8}&amp;#39; | awk -F&amp;#39;条,&amp;#39; &amp;#39;{sum += $1} END {print sum}&amp;#39; awk -F'条,' '{sum += $1} END {print sum}' 用条进行分割取$1第一个进行sum求和计算 awk '{print $8}' 这里注意使用单引号 250</description></item><item><title>Tmux使用笔记</title><link>http://example.org/docs/programmer/basetc/tmux/</link><pubDate>Mon, 08 Jul 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/tmux/</guid><description>tmux # 从posts中迁移来
丰富纯文字终端窗口，可以创建终端副本(反正也是我取得名字)—&amp;ndash;类似于win的多桌面。也可以分割终端(界面类似vim分割)l&amp;ndash;这便是类似于win的多窗口了。 (官方翻译: &amp;lsquo;窗格&amp;rsquo;？)
进入: tmux 退出: exit 类似于vim命令模式： ctrl+b以下简写为CL_B。 创建多桌面: CL_B + c 查看全部窗口，类似win+Tab: CL_B + s 使用窗口号切换桌面: CL_B + NUM 关闭当前窗口: CL_B + &amp;amp;,emm直接exit&amp;hellip; 创建多窗口: CL_B + &amp;quot; (垂直上下)、CL_B + % (水平左右) 调整窗口位置、大小 CL_B + space (默认布局轮换) 显示窗口编号: CL_B + q 暂时最大化当前窗格: CL_B + z 切换到下一个窗格: CL_B + o 对换窗格位置: CL_B + CL_O(ctrl + o) 设置 # 启用鼠标触控板 # set -g mouse on 复制终端展示内容 # 复制 # set-window-option -g mode-keys vi #可以设置为vi或emacs set-window-option -g utf8 on #开启窗口的UTF-8支持 CL_B + [ Space空格开始选择(可使用?</description></item><item><title>Podman</title><link>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-podman/</link><pubDate>Thu, 27 Jun 2024 21:37:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-podman/</guid><description> Podman # 命令用法 # 命令几乎和docker一致, alias docker=podman完全可以无感知
不同点 # pull路径需要完整 podman pull docker.io/library/mysql:5.7 迁移镜像存储路径 # 切换到
lazydocker # [[Note of Docker#lazydocker 可视化]]
export DOCKER_HOST=unix:///run/user/1000/podman/podman.sock lazydocker VSCode # Dev Containers # https://code.visualstudio.com/remote/advancedcontainers/docker-options
在插件设置中, 将Docker Path里docker修改为podman即可
网络 # slirp4netns问题 # podman network connect example-network example-container会报错 podman 网络连接未针对 slirp4netns 实现 #19577</description></item><item><title>爬虫</title><link>http://example.org/docs/programmer/ml/%E7%88%AC%E8%99%AB/</link><pubDate>Wed, 26 Jun 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/ml/%E7%88%AC%E8%99%AB/</guid><description>https://github.com/SeleniumHQ/seleniumhq.github.io/blob/trunk/examples/python/tests/getting_started/first_script.py#L4
Selenium # chromedriver地址 # https://googlechromelabs.github.io/chrome-for-testing/#stable
geckodriver(firefox)地址 # https://github.com/mozilla/geckodriver/releases
Firefox headlees运行需要的依赖 # apt-get install -y wget bzip2 libxtst6 libgtk-3-0 libx11-xcb-dev libdbus-glib-1-2 libxt6 libpci-dev libasound2</description></item><item><title>安卓玩机</title><link>http://example.org/posts/android%E7%8E%A9%E6%9C%BA/</link><pubDate>Tue, 18 Jun 2024 23:03:41 +0000</pubDate><guid>http://example.org/posts/android%E7%8E%A9%E6%9C%BA/</guid><description> shizuku # 启动命令:
adb shell sh /storage/emulated/0/Android/data/moe.shizuku.privileged.api/start.sh 自动任务 # 自动化任务
Scene # 查看安卓进程管理
App Ops # App权限监测
ADB # 设置http代理 # adb shell settings put global http_proxy 192.168.105.230:8080 adb shell settings put global https_proxy 192.168.105.230:8080 # 删除代理 adb shell settings delete global http_proxy Deleted 1 rows adb shell settings delete global https_proxy Deleted 1 rows adb shell settings delete global global_http_proxy_host Deleted 1 rows adb shell settings delete global global_https_proxy_host Deleted 0 rows adb shell settings delete global global_http_proxy_port Deleted 1 rows adb shell settings delete global global_https_proxy_port Deleted 0 rows # 需要冲起生效 - 有的机器可能不用 adb reboot</description></item><item><title>Ubuntu</title><link>http://example.org/docs/programmer/platforms/ubuntu/</link><pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/platforms/ubuntu/</guid><description>Snap # 如果Ubuntu有问题,那么很有可能是因为Snap
Firefox # 在升级Ubuntu 24.04后内存占用极为不正常, 多次排查无果, 增加了交换空间还是没有治本, 几经排查终于发现是firefox的问题, 且是Snap的firefox的问题,所以手动下载别的版本后修改如下:
修改/usr/bin/firefox中的最一开始的监测安装和运行为自行下载软件路径 添加gnome favorite-apps 1. 添加Firefox到Favorites（喜爱应用） # 打开终端（Ctrl + Alt + T）。 输入以下命令来查看当前的喜爱应用列表： gsettings get org.gnome.shell favorite-apps 这会输出当前的喜爱应用列表 3. 如果没有看到 firefox.desktop 在列表中，可以使用以下命令将它添加进去,这个命令会将 firefox.desktop 添加到喜爱应用列表的末尾。：
gsettings set org.gnome.shell favorite-apps &amp;#34;$(gsettings get org.gnome.shell favorite-apps | sed &amp;#34;s/]/, &amp;#39;firefox.desktop&amp;#39;]/&amp;#34;)&amp;#34; 2. 检查.desktop文件是否正确 # 确保 firefox.desktop 文件存在并且正确配置。通常，它应该位于 /usr/share/applications/ 目录或者在Snap安装中可能位于 /var/lib/snapd/desktop/applications/ 目录。你可以使用 ls 命令检查这些位置是否有相关的 .desktop 文件：
ls /usr/share/applications/firefox.desktop ls /var/lib/snapd/desktop/applications/firefox_firefox.desktop # 如果是通过Snap安装的Firefox` 3. 更新缓存和重启(可选) - 我用的 [[#^bef1ba]] # 如果以上步骤没有解决问题，尝试更新GNOME的缓存并重新启动GNOME Shell：</description></item><item><title>Python Redis 客户端</title><link>http://example.org/docs/programmer/cloudnative/redis/python-redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/redis/python-redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>异步调用时自动关闭 # 当事件循环正在运行时，会创建一个任务来关闭 redis 连接，而不会阻塞事件循环。如果事件循环没有运行，就可以像之前一样调用 run_until_complete。
async def close_redis(self): if self.redis: await self.redis.close() def __del__(self): loop = asyncio.get_event_loop() if loop.is_running(): asyncio.create_task(self.close_redis()) else: loop.run_until_complete(self.close_redis()) 数据迁移(hash数据) # 脚本 # import os import json import redis import argparse from loguru import logger home_path = os.environ.get(&amp;#39;HOME&amp;#39;) parser = argparse.ArgumentParser(description=&amp;#39;Copy Reten Config&amp;#39;) parser.add_argument(&amp;#39;--mode&amp;#39;, help=&amp;#39;Pull or Push data from Redis&amp;#39;) parser.add_argument(&amp;#39;-ds&amp;#39;, &amp;#39;--datasource&amp;#39;, help=&amp;#39;retens or events config data from Redis&amp;#39;) args = parser.parse_args() source_redis = redis.StrictRedis(host=&amp;#39;redis-product.com&amp;#39;, port=6379, db=0) def scan_keys_with_pattern(pattern): # 初始游标 cursor = &amp;#39;0&amp;#39; count_group = 0 while True: # 使用 SCAN 命令进行迭代 cursor, keys = source_redis.</description></item><item><title>阿里云使用</title><link>http://example.org/docs/programmer/platforms/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/platforms/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BD%BF%E7%94%A8/</guid><description>oss 对象存储 # Python SDK # pip install oss2 export OSS_ACCESS_KEY_ID=SIHDoisdhuasuiUGDS export OSS_ACCESS_KEY_SECRET=asdih213asHSIDH2e1 一、Auth # import oss2 from oss2.credentials import EnvironmentVariableCredentialsProvider from itertools import islice auth = oss2.ProviderAuth(EnvironmentVariableCredentialsProvider()) 二、Bucket # bucket_info 字段说明 # 字段 type 注释 {bucket_info.name} Bucket的名称 {bucket_info.storage_class} Bucket的存储类型 {bucket_info.creation_date} Bucket的创建时间 {bucket_info.intranet_endpoint} Bucket的内网Endpoint {bucket_info.extranet_endpoint} Bucket的外网Endpoint {bucket_info.owner.id} Bucket的拥有者ID {bucket_info.acl.grant} Bucket的ACL授权 {bucket_info.data_redundancy_type} Bucket的数据冗余类型 {bucket_info.access_monitor} Bucket的访问跟踪状态 代码示例 # # 查看Bucket service = oss2.Service(auth, &amp;#39;oss-ap-xiaomengmai-1.aliyuncs.com&amp;#39;) for b in oss2.BucketIterator(service): print(b.name) # bucket信息 bucket = oss2.</description></item><item><title>大key、热key问题</title><link>http://example.org/docs/programmer/cloudnative/redis/bigkey-and-hotkey/</link><pubDate>Mon, 27 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/redis/bigkey-and-hotkey/</guid><description>如何找出优化大Key与热Key,产生的原因和问题_云数据库 Redis 版(Redis)-阿里云帮助中心 # 在使用Redis的过程中，如果未能及时发现并处理Big keys（下文称为“大Key”）与Hotkeys（下文称为“热Key”），可能会导致服务性能下降、用户体验变差，甚至引发大面积故障。本文将介绍大Key与热Key产生的原因、其可能引发的问题及如何快速找出大Key与热Key并将其优化的方案。
名词 解释 大Key 通常以Key的大小和Key中成员的数量来综合判定，例如：- Key本身的数据量过大：一个String类型的Key，它的值为5 MB。- Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。- Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。 热Key 通常以其接收到的Key被请求频率来判定，例如：- QPS集中在特定的Key：Redis实例的总QPS（每秒查询率）为10,000，而其中一个Key的每秒访问量达到了7,000。- 带宽使用率集中在特定的Key：对一个拥有上千个成员且总大小为1 MB的HASH Key每秒发送大量的HGETALL操作请求。- CPU使用时间占比集中在特定的Key：对一个拥有数万个成员的Key（ZSET类型）每秒发送大量的ZRANGE操作请求。 说明
上述例子中的具体数值仅供参考，在实际业务中，您需要根据Redis的实际业务场景进行综合判断。
大Key和热Key引发的问题 # 类别 说明 大Key - 客户端执行命令的时长变慢。- Redis内存达到maxmemory参数定义的上限引发操作阻塞或重要的Key被逐出，甚至引发内存溢出（Out Of Memory）。- 集群架构下，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡。- 对大Key执行读请求，会使Redis实例的带宽使用率被占满，导致自身服务变慢，同时易波及相关的服务。- 对大Key执行删除操作，易造成主库较长时间的阻塞，进而可能引发同步中断或主从切换。 热Key - 占用大量的CPU资源，影响其他请求并导致整体性能降低。- 集群架构下，产生访问倾斜，即某个数据分片被大量访问，而其他数据分片处于空闲状态，可能引起该数据分片的连接数被耗尽，新的连接建立请求被拒绝等问题。- 在抢购或秒杀场景下，可能因商品对应库存Key的请求量过大，超出Redis处理能力造成超卖。- 热Key的请求压力数量超出Redis的承受能力易造成缓存击穿，即大量请求将被直接指向后端的存储层，导致存储访问量激增甚至宕机，从而影响其他业务。 大Key和热Key产生的原因 # 未正确使用Redis、业务规划不足、无效数据的堆积、访问量突增等都会产生大Key与热Key，如：
大key 在不适用的场景下使用Redis，易造成Key的value过大，如使用String类型的Key存放大体积二进制文件型数据； 业务上线前规划设计不足，没有对Key中的成员进行合理的拆分，造成个别Key中的成员数量过多； 未定期清理无效数据，造成如HASH类型Key中的成员持续不断地增加； 使用LIST类型Key的业务消费侧发生代码故障，造成对应Key的成员只增不减。 热key 预期外的访问量陡增，如突然出现的爆款商品、访问量暴涨的热点新闻、直播间某主播搞活动带来的大量刷屏点赞、游戏中某区域发生多个工会之间的战斗涉及大量玩家等。 快速找出大Key和热Key # Redis提供多种方案帮助您轻松找出大Key与热Key。
方法 优缺点 说明 实时Top Key统计（推荐） - 优点：准确性高、对性能几乎无影响。- 缺点：展示的Key数量有一定限制，但能满足常规场景下的需求。 可实时展示实例中的大Key和热Key信息，同时支持查看4天内大Key和热Key的历史信息。该功能可帮助您掌握Key在内存中的占用、Key的访问频次等信息，溯源分析问题，为您的优化操作提供数据支持。 离线全量Key分析 - 优点：可对历史备份数据进行分析，对线上服务无影响。- 缺点：时效性差，RDB文件较大时耗时较长。 对Redis的RDB备份文件进行定制化的分析，帮助您发现实例中的大Key，掌握Key在内存中的占用和分布、Key过期时间等信息，为您的优化操作提供数据支持，帮助您避免因Key倾斜引发的内存不足、性能下降等问题。 通过redis-cli的bigkeys和hotkeys参数查找大Key和热Key - 优点：方便、快速、安全。- 缺点：分析结果不可定制化，准确性与时效性差。 Redis提供了bigkeys参数能够使redis-cli以遍历的方式分析Redis实例中的所有Key，并返回Key的整体统计信息与每个数据类型中Top1的大Key，bigkeys仅能分析并输入六种数据类型（STRING、LIST、HASH、SET、ZSET、STREAM），命令示例为redis-cli -h r-***************.</description></item><item><title>WPS for Linux</title><link>http://example.org/docs/programmer/platforms/wps-for-linux/</link><pubDate>Wed, 22 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/platforms/wps-for-linux/</guid><description> wps 在linux上打开提示字体缺失 # wps 在linux上打开提示字体缺失 # git clone https://github.com/dv-anomaly/ttf-wps-fonts cd ttf-wps-fonts &amp;amp;&amp;amp; sudo ./install.sh</description></item><item><title>SqlAlchemy - 数据库Orm</title><link>http://example.org/docs/programmer/langs/python/sqlalchemy/</link><pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/sqlalchemy/</guid><description>Sqlalchemy异步操作不完全指北 - 米洛丶 - 博客园 # cnblogs.com
异步SQLAlchemy # SQLAlchemy作为一款通用的Python Orm工具，在最近的版本也支持了异步操作。但网上很多资料都不是很齐全，API也不是很好查询的情况下，我便有了整理一份基础文档的想法。文章主要会以CRUD为入口，解决大家最基本的需求。
engine的区别 # 在普通的SQLAlchemy中，建立engine对象，我们会采用下面的方式:
from sqlalchemy import create_engine engine = create_engine(SQLALCHEMY_DATABASE_URI, pool_recycle=1500) 而异步的方式如下:
from sqlalchemy.ext.asyncio import create_async_engine async_engine = create_async_engine(ASYNC_SQLALCHEMY_URI, pool_recycle=1500) session的区别 # 我们一般用sessionmaker来建立session，不过异步的有点区别:
from sqlalchemy.ext.asyncio import AsyncSession from sqlalchemy.orm import sessionmaker # 同步session Session = sessionmaker(engine) # 异步session 区别在于需要指定对应的class_ async_session = sessionmaker(async_engine, class_=AsyncSession) 建立会话 # 我们还是以代码的形式展示:
# 同步 with Session() as session: # 里面是具体的sql操作 pass # 异步 async with Session() as session: # 里面是异步的操作，区别就是从with变成了async with 也就意味着方法必须是async修饰的 pass 以上是关于建立连接，处理会话的一些区别，接着我们讲对应的CRUD操作。</description></item><item><title>AppsFlyer-外网移动归因营销分析平台</title><link>http://example.org/docs/programmer/platforms/appsflyer/</link><pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/platforms/appsflyer/</guid><description> AppsFlyer # SDK集成 # Gradle、dependency 添加Android Install Referrer 到App 通过app权限准确化归因 应用内事件 # 注册 购买 广告点击 分享 邀请 唤醒 跳转 # OpenLink平台归因 跳转 深度链接</description></item><item><title>Obsidian思维导图插件</title><link>http://example.org/docs/programmer/basetc/obsidian%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/obsidian%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E6%8F%92%E4%BB%B6/</guid><description> Enhancing Mind map # Links # https://github.com/MarkMindLtd/obsidian-enhancing-mindmap GitHub Related # coc-markmap gatsby-remark-markmap Features # links inline text styles multiline text inline code Katex - $x = {-b \pm \sqrt{b^2-4ac} \over 2a}$ 注意这里 # 该插件支持如上以及无序列表等有限的markdown格式，无法支持其他格式，一定要注意这点，否则可能会丢失数据，切记。
Short cuts # 新建脑图 Ctrl/Cmd+P 新增子节点 Tab 新增兄弟节点 enter 删除节点 Delete 编辑节点 Space/dblclick node 后退 Ctrl/Cmd+Z 前进 Ctrl/Cmd+Y 取消编辑节点 Tab 展开节点 Ctrl/Cmd + / 收缩节点 Ctrl/Cmd + / 拖动节点 Drag and drop node 切换节点 Up/down/left/right 放大、缩小 Ctrl/Cmd + 滚轮 居中 Ctrl/Cmd + E 功能 # 编辑节点 拖动节点至某节点 前进/后退 在markdown和思维导图视图之间切换 数据同步</description></item><item><title>网络编程</title><link>http://example.org/docs/programmer/net/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/net/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>网络分层图 # ![[net_layer.png]]
TCP是传输层的协议，而基于TCP造出来的HTTP和各类RPC协议，它们都只是定义了不同消息格式的应用层协议而已。 HTTP协议（Hyper Text Transfer Protocol），又叫做超文本传输协议。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是HTTP协议。 RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。虽然大部分RPC协议底层使用TCP，但实际上它们不一定非得使用TCP，改用UDP或者HTTP，其实也可以做到类似的功能。 RPC # vs HTTP # HTTP: ![[http.png]] RPC: ![[rpc.png]]
服务发现 [x] # 首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道IP地址和端口。这个找到服务对应的IP端口的过程，其实就是服务发现。
在HTTP中，你知道服务的域名，就可以通过DNS服务去解析得到它背后的IP地址，默认80端口。
而RPC的话，就有些区别，一般会有专门的中间服务去保存服务名和IP信息，比如consul或者etcd，甚至是redis。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如CoreDNS。
底层连接形式 [x] # 以主流的HTTP1.1协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（keep alive），之后的请求和响应都会复用这条连接。
而RPC协议，也跟HTTP类似，也是通过建立TCP长链接进行数据交互，但不同的地方在于，RPC协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。
由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给HTTP加个连接池，比如go就是这么干的。
可以看出这一块两者也没太大区别，所以也不是关键。
传输的内容 # 基于TCP传输的消息，说到底，无非都是消息头header和消息体body。
header是用于标记一些特殊信息，其中最重要的是消息体长度。
body则是放我们真正需要传输的内容，而这些内容只能是二进制01串，毕竟计算机只认识这玩意。所以TCP传字符串和数字都问题不大，因为字符串可以转成编码再变成01串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制01串，这样的方案现在也有很多现成的，比如json，protobuf。
这个将结构体转为二进制数组的过程就叫序列化，反过来将二进制数组复原成结构体的过程叫反序列化。 ![[tobytes.png]]
序列化和反序列化
对于主流的HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但HTTP设计初是用于做网页文本展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用json来序列化结构体数据。
我们可以随便截个图直观看下。 ![[tobetes_details.png]] HTTP报文
可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像header里的那些信息，其实如果我们约定好头部的第几位是content-type，就不需要每次都真的把&amp;quot;content-type&amp;quot;这个字段都传过来，类似的情况其实在body的json结构里也特别明显。
而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。
当然上面说的HTTP，其实特指的是现在主流使用的HTTP1.1，HTTP2在前者的基础上做了很多改进，所以性能可能比很多RPC协议还要好，甚至连gRPC底层都直接用的HTTP2。
结论 # 纯裸TCP是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP和各类RPC协议就是在TCP之上定义的应用层协议。 RPC本质上不算是协议，而是一种调用方式，而像gRPC和thrift这样的具体实现，才是协议，它们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，不一定非得基于TCP协议。 从发展历史来说，**HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合。**很多软件同时支持多端，所以对外一般用HTTP协议，而内部集群的微服务之间则采用RPC协议进行通讯。 RPC其实比HTTP出现的要早，且比目前主流的HTTP1.1性能要更好，所以大部分公司内部都还在使用RPC。 HTTP2.0在HTTP1.1的基础上做了优化，性能可能比很多RPC协议都要好，但由于是这几年才出来的，所以也不太可能取代掉RPC。 TCP # 八股文常背，TCP是有三个特点，面向连接、可靠、基于字节流。
粘包问题 # 因为： ![[tcp_is_dataflow.png]] 所以： ![[nianbaowenti.png]] 无法区分上述两种情况。 得出： 纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些自定义的规则，用于区分消息边界。
于是我们会把每条要发送的数据都包装一下，比如加入消息头，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的消息体。</description></item><item><title>Redis基础</title><link>http://example.org/docs/programmer/cloudnative/redis/the-basics-of-redis/</link><pubDate>Sun, 05 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/redis/the-basics-of-redis/</guid><description>基础理论 # 概况 # Redis (Remote Dictionary Server) 是一个开源的、支持网络、基于内存、可选持久性的键值对数据库。它支持多种类型的数据结构，如字符串（strings）、列表（lists）、集合（sets）、有序集合（sorted sets）以及散列（hashes）、位图（bitmaps）、超日志（hyperloglogs）和地理空间（geospatial）索引半径查询。
特点包括：
高性能：因为数据主要在内存中进行操作，读写速度非常快。 丰富的数据类型：提供多种数据结构来满足不同场景下的需求。 原子性：所有操作都是原子性的，支持事务（通过MULTI/EXEC命令）。 丰富的功能：支持发布订阅、Lua脚本、事务等。 数据结构 # Redis提供的数据结构包括： Redis 支持多种数据类型，以下是一些常用的数据类型以及它们的简要描述和使用场景：
数据类型 描述 使用场景 String 二进制安全字符串，最大可以存储 512MB 存储文本或二进制数据，如缓存用户个人信息等 List 有序集合，按插入顺序排序 消息队列、时间线、最新消息列表 Set 无序集合，元素不重复 标签、社交网络中的朋友关系等 Sorted Set 有序集合，元素不重复，并且每个元素都会关联一个浮点数分数 排行榜、带权重的集合 Hash 键值对集合，适用于存储对象 存储、访问和修改对象属性 Bitmaps 通过位来表示数据的数据类型，适合做计数统计 在线状态、特性标志、统计等 HyperLogLog 近似去重计数的数据结构 大数据量的计数，如统计独立 IP 访问数量 Geospatial 存储地理位置信息，并进行相关地理操作 储存经纬度，查询附近的地点 Streams Redis 5.0 新增的数据类型，是一个可持久化的日志数据结构 实现消息队列，发布/订阅模式，日志记录 Redis 之所以快速，主要原因有以下几点： # 内存存储：Redis 将所有数据存储在内存中，内存的读写速度远高于硬盘。 数据结构简单：Redis 的数据结构设计简单直观，易于高效操作。 非阻塞 IO：Redis 使用非阻塞 IO 和多路复用技术，可以处理多个并发连接。 单线程模型：Redis 大部分操作是单线程执行，避免了多线程的上下文切换开销。 Redis高性能IO模型 # Redis的IO模型使用的是非阻塞IO复用技术，主要是epoll作为IO多路复用技术的实现方式。它通过单线程事件循环来处理所有客户端请求，确保绝大部分请求都是非阻塞的，并且使用异步编程模式来提高性能。</description></item><item><title>Redis进阶</title><link>http://example.org/docs/programmer/cloudnative/redis/advanced-knowledge-of-redis/</link><pubDate>Sun, 05 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/redis/advanced-knowledge-of-redis/</guid><description>主从架构-主从同步 # 在Redis中，主从同步是一种常用的数据复制方式，它允许一个或多个从服务器（slave）获得与主服务器（master）相同的数据副本。这种架构提供了数据的冗余和读取扩展性。
全量复制：当一个从服务器第一次连接到主服务器时，或是由于某些原因需要重新同步时，会进行全量复制。在这个过程中，主服务器会生成一个当前所有数据的快照，并将这个快照发送至请求同步的从服务器。从服务器接收到数据后，加载到自己的数据空间内。
部分复制：一旦完成了全量复制，如果从服务器断开连接又重新连接，且中断时间不长，主服务器可以只发送这段时间内发生变化的数据给从服务器，而不是再次进行全量复制。这依赖于主服务器的复制积压缓冲区来存储最近的写命令。
同步策略：为了保证数据的一致性，从服务器在初始同步完成之前不会对外提供服务。在日常运行时，主服务器会将写命令同时发送给所有的从服务器，以此来保证数据的实时一致性。
主从同步使得从服务器可以承担读操作，减轻主服务器的负载，同时也可以在主服务器遇到故障时，进行故障转移。
主从哨兵架构 # Redis哨兵（Sentinel）系统是用于管理多个Redis服务器的系统。该体系结构具有以下特点：
监控：哨兵会监控主从服务器是否正常运作。 自动故障转移：如果主服务器出现故障，哨兵可以自动选举新的主服务器，并让原来的从服务器指向新的主服务器。 配置提供者：哨兵还会将当前的主服务器地址提供给客户端，确保客户端总是连接到正确的主服务器。 哨兵机制通过这些功能增加了Redis环境的高可用性和稳定性。
切片集群-Redis Cluster # Redis Cluster是Redis的分布式解决方案。它支持数据的水平分片，以下是其关键特性：
自动分片：��动将数据分布在不同的节点上，每个节点只保存整个数据集的一部分。 高可用性：采用主从复制模型，即使在多个节点失败的情况下也能保证服务的可用性。 无中心设计：没有中心节点，每个节点都保存着整个集群状态的一部分，节点之间通过Gossip协议交换信息。 Redis Cluster通过对键进行CRC16计算并对16384取余数来决定将键分配到哪个槽位，每个节点负责一部分槽位，从而实现负载均衡。
Redis Cluster 通信开销 # 由于Redis Cluster节点间需要频繁地交换消息以维护集群状态，因此会产生额外的通信开销：
Gossip通信：节点间通过Gossip协议定期交换信息，包括数据迁移、故障检测等。 重定向操作：客户端可能会尝试向不包含数据所在槽的节点发起请求，这时节点会返回一个重定向信息 切片集群-Codis
Redis 分布式锁是一种用于多个计算节点之间同步访问共享资源的机制。在分布式系统中，当多个进程需要同时访问某些数据或执行某些任务时，为了避免竞态条件（race conditions）和数据不一致，通常需要使用分布式锁来保证在同一时间只有一个进程能够执行特定的操作。
Redis 分布式锁实现 # 一个常见的Redis分布式锁实现是使用 Redis 的 SETNX 命令（Set if not exists）。这个命令只在键不存在的情况下设置键的值，并且返回是否成功设置。由于 SETNX 是原子操作，因此可以用来实现锁的功能。
另一个更加推荐的方式是使用 Redis 2.6.12 版本引入的 SET 命令结合选项 NX（表示只有键不存在时才进行设置）和 PX（给键设置过期时间，单位为毫秒），这可以保证即使在客户端崩溃的情况下，锁也会在一定时间后自动释放，防止死锁。
使用 Redis 分布式锁的步骤： # 尝试获取锁
使用 SET key value NX PX milliseconds 进行设置。 如果返回 OK，则获取锁成功。 如果返回 nil，则获取锁失败。 执行业务逻辑</description></item><item><title>Redis常用命令</title><link>http://example.org/docs/programmer/cloudnative/redis/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/redis/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description> scan 替代 keys # SCAN 0 MATCH key* COUNT 100 查看类型type # type # 使用了 GET 命令，这个命令通常用于获取字符串类型的值。如果key_hi 这个键在 Redis 中存储的不是字符串类型的值，而是其他类型（如列表、集合、哈希等），那么执行 GET 命令就会返回错误:
(error) WRONGTYPE Operation against a key holding the wrong kind of value
要解决这个问题，首先需要确定 key_hi 键存储的值的类型。你可以使用 TYPE 命令来检查键的类型：
TYPE mmp:cfgs:com.easypeso:retens 查看list # 查看 List 长度： LLEN mylist 0 -1 查看 List 数据内容： LRANGE mylist 0 -1</description></item><item><title>小命令</title><link>http://example.org/posts/%E5%B0%8F%E5%91%BD%E4%BB%A4/</link><pubDate>Sun, 24 Sep 2023 23:03:41 +0000</pubDate><guid>http://example.org/posts/%E5%B0%8F%E5%91%BD%E4%BB%A4/</guid><description>前传: [[Make things easy and enjoyable]]
1. 递归删除某些文件 # 如以.py.bak 为结尾的文件: find . -name &amp;quot;*.py.bak&amp;quot; -exec rm {} \;
2. 批量杀死进程 # - pkill -f uwsgi
- ps aux | grep 关键字 | awk &amp;lsquo;{print $2}&amp;rsquo; | xargs kill
批量删除pod - xargs 的使用 # kubectl get pod -n argo | grep workflow-template | awk &amp;#39;{print $1}&amp;#39; | xargs kubectl -n argo delete pod 3. MySQL NOW # 指定东八：update scanner_device set update_time = CONVERT_TZ(NOW(), @@session.</description></item><item><title>elk在k8s上的部署使用示例</title><link>http://example.org/docs/programmer/cloudnative/k8s/elk%E5%9C%A8k8s%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</link><pubDate>Sun, 24 Sep 2023 23:01:41 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/elk%E5%9C%A8k8s%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</guid><description>示例Yaml # --- apiVersion: v1 kind: ConfigMap metadata: name: filebeat-config namespace: ops labels: k8s-app: filebeat data: filebeat.yml: |- filebeat.config: inputs: # Mounted `filebeat-inputs` configmap: path: ${path.config}/inputs.d/*.yml # Reload inputs configs as they change: reload.enabled: false modules: path: ${path.config}/modules.d/*.yml # Reload module configs as they change: reload.enabled: false output.elasticsearch: hosts: [&amp;#39;49.65.125.91:9200&amp;#39;] --- apiVersion: v1 kind: ConfigMap metadata: name: filebeat-inputs namespace: ops labels: k8s-app: filebeat data: kubernetes.yml: |- - type: docker containers.</description></item><item><title>Nginx实用配置</title><link>http://example.org/docs/programmer/cloudnative/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 24 Sep 2023 23:01:41 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/</guid><description>from: 这里
location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } location /test_vul_id_1000003 { alias /home/test_vul_id_1000003; autoindex on; } location /test_vul_id_1000003 { root /home; autoindex on; } 非以上配置访问404原因 # location /test_vul_id_1000003 { root /home/test_vul_id_1000003; autoindex on; } 如以上配置, nginx 配置文件会将 root 加上 以上的 localtion , 导致访问时实际定位是 /home/test_vul_id_1000003/test_vul_id_1000003 所以就 404 了
生效命令 # nginx -t nginx -s reload service nginx restart</description></item><item><title>Nginx实用配置</title><link>http://example.org/docs/programmer/net/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 24 Sep 2023 23:01:41 +0000</pubDate><guid>http://example.org/docs/programmer/net/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/</guid><description>from: 这里
location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } location /test_vul_id_1000003 { alias /home/test_vul_id_1000003; autoindex on; } location /test_vul_id_1000003 { root /home; autoindex on; } 非以上配置访问404原因 # location /test_vul_id_1000003 { root /home/test_vul_id_1000003; autoindex on; } 如以上配置, nginx 配置文件会将 root 加上 以上的 localtion , 导致访问时实际定位是 /home/test_vul_id_1000003/test_vul_id_1000003 所以就 404 了
生效命令 # nginx -t nginx -s reload service nginx restart</description></item><item><title>k8s 配套说明</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E9%85%8D%E5%A5%97%E8%AF%B4%E6%98%8E/</link><pubDate>Thu, 07 Sep 2023 20:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E9%85%8D%E5%A5%97%E8%AF%B4%E6%98%8E/</guid><description>ctr # 如果定义了 -n 应该是namesplace 那么每个命令都得跟上
load镜像 # sudo ctr -n=k8s.io images import ${imageTarFile}
保存文件 # sudo ctr -n k8s.io images export &amp;ndash;platform=linux/amd64 hi.tar 101.32.1.4:30002/web-docker/worker:2121
切换tag # sudo ctr -n k8s.io images tag &amp;ndash;force repos.x.com/web-docker/worker:2121 101.32.1.4:30002/web-docker/worker:2121
推送镜像 # sudo ctr -n k8s.io images push -k -u admin:fat213asfdFS2W &amp;ndash;plain-http 101.32.1.4:30002/web-docker/worker:2121
拉取 # sudo ctr -n k8s.io images pull -k -u admin:fat1239ASD124W &amp;ndash;plain-http 101.32.1.4:30002/web-docker/worker:2121
Docker # [[Note of Docker]] 好像并没有整理docker命令&amp;hellip; 后续补吧</description></item><item><title>k8s技术分享</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</link><pubDate>Thu, 07 Sep 2023 20:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</guid><description>k8s技术分享 # 工作负载资源 # 一、pod # 1. 概要 # 可创建管理、最小的可部署计算单元，是可以在主机上运行的容器的集合 我们的服务都在其中运行。如我们的服务是nginx，则最内层是我们的服务 nginx，运行在 container 容器当中。container (容器) 的本质是进程，而 pod 是管理这一组进程的资源 所以pod可视为一个极为轻量化、没插网线的电脑，如果所需任务无需交互，那么用pod就很合适。例如给它挂载一个文件来训练模型、生成报表，可以根据场景使用 Job 或者 CronJob 或者其它 图示关系如下 # ![[k8s-pod-insert.png]]
2. pod网络 # 当然，pod 可以管理多个 container，又因为container (容器) 的本质是进程，如果有本地网络通信需求(使用 localhost 或者 Socket 文件进行本地通信)，在这些场景中使用 pod 管理多个 container 就非常的推荐。
如下图展示了Pod网络所依赖的3个网络设备
1. eth0是节点主机上的网卡，支持该节点流量出入的设备、也是支持集群节点间IP寻址和互通的设备；
2. docker0是一个虚拟网桥，可以简单理解为一个虚拟交换机，支持该节点上的Pod之间进行IP寻址和互通的设备；
3. veth0则是Pod1的虚拟网卡，支持该Pod内容器互通和对外访问的虚拟设备；
4. docker0网桥和veth0网卡，都是linux支持和创建的虚拟网络设备；
5. pause属于特殊容器，其运行的唯一目的是为Pod建立共享的veth0网络接口
![[k8s-nginx-pod.png]]
二、deployment、StatefulSet # 1. 概要 # Deployment 使得 Pod 和 ReplicaSet 能够进行声明式更新
StatefulSet 表示一组具有一致身份的 Pod：
1. 身份定义为：</description></item><item><title>uwsgi 处理记录</title><link>http://example.org/docs/programmer/cloudnative/uwsgi-%E5%A4%84%E7%90%86%E8%AE%B0%E5%BD%95/</link><pubDate>Tue, 01 Aug 2023 10:30:41 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/uwsgi-%E5%A4%84%E7%90%86%E8%AE%B0%E5%BD%95/</guid><description>日志输出到终端 # uwsgi.ini文件中配置
log-master = true ; logto=/var/log/uwsgi.log 同时这行不能有 启动命令: uwsgi /opt/disk2/var/www/scancenter/3rd/conf/uwsgi-docker/uwsgi.ini --log-master
隔一段时间卡死,重启不能 # 当作为纯后端API使用时, 使用 http-socket 不使用 http
使用supervisor管理uwsgi # #daemonize=/var/log/uwsgi8011.log # 守护进程一定要注释掉(关键)
查看性能数据 # 安装 uwsgitop 查看 uwsgi stats写入位置 查看 pip install uwsgitop cat /opt/trunk/textcheck/3rd/uwsgi/config.ini | grep stats # &amp;gt; stats=/var/run/uwsgi/uwsgi.status uwsgitop /var/run/uwsgi/uwsgi.status # &amp;gt; uwsgi-2.0.19.1 - Wed Oct 18 18:13:48 2023 - req: 113 - RPS: 0 - lq: 0 - tx: 75.1K node: app-58d8477f4-26fzb - cwd: /app - uid: 0 - gid: 0 - masterpid: 8 WID % PID REQ RPS EXC SIG STATUS AVG RSS VSZ TX ReSpwn HC RunT LastSpwn 1 28.</description></item><item><title>k8s学习-常用命令和配置文件</title><link>http://example.org/docs/programmer/cloudnative/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 27 Mar 2023 10:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</guid><description>k8s学习 # 常用命令 # kubectl apply -f rcm_log_monut_k8s_pod.yaml kubectl get pod -A kubectl get pod -all-namespaces kubectl get node kubectl get deploy 持久卷 - PersistentVolume kubectl get persistentvolume kubectl describe persistentvolume example-pv kubectl **delete** persistentvolume example-pv 从kubectl cp -n &amp;lt;命名空间&amp;gt; -c :xxx.json xxx.json configmap / secret 存储文件内容 # sftpkey 为名称
新建 # kubectl create secret generic sftpkey --from-file=/etc/id_rsa # kubectl create -n {NAMESPACE} secret generic sftpkey --from-file=/etc/id_rsa 删除 # kubectl delete secret sftpkey</description></item><item><title>My First Post</title><link>http://example.org/posts/my-first-post/</link><pubDate>Mon, 24 Oct 2022 01:47:22 +0000</pubDate><guid>http://example.org/posts/my-first-post/</guid><description>Hello World # Hello, World</description></item><item><title>CMake 使用Tips</title><link>http://example.org/docs/programmer/langs/cmake/</link><pubDate>Tue, 30 Aug 2022 12:00:56 +0000</pubDate><guid>http://example.org/docs/programmer/langs/cmake/</guid><description> 在编译时将编译产物放在build # 据网友所知，cmake文档中没有记录，仅出于兼容性原因或内部使用而保留：
-B和-H标志 # cmake -Hpath/to/source -Bpath/to/build 甚至从源目录 -B # 重要：-B后没有空格
该命令会自动创建build目录 之后cd到build下去make即可 cmake . -Bbuild 样例记录 # OpenCV # CMakeLists.txt 文件tree -L 1 |-- CMakeLists.txt |-- DisplayImage.cpp |-- DisplayImage.out |-- cmake_install.cmake |-- CMakeCache.txt |-- CMakeFiles |-- Makefile cmake_minimum_required(VERSION 2.8) project( DisplayImageExample ) find_package( OpenCV REQUIRED ) include_directories( ${OpenCV_INCLUDE_DIRS} ) add_executable( DisplayImage.out DisplayImage.cpp ) target_link_libraries( DisplayImage.out ${OpenCV_LIBS} ) Qt #</description></item><item><title>GPT技术分享</title><link>http://example.org/posts/gpt_share/</link><pubDate>Sun, 12 Jun 2022 00:00:00 +0000</pubDate><guid>http://example.org/posts/gpt_share/</guid><description>GPT技术分享 # 先介绍几个名词 # GPT 和 ChatGPT # Generative Pre-Training Transformer 是一种基于Transformer架构的预训练语言模型.
我们所接触到的chatgpt是针对gpt3.5模型的一种应用实例, 如今chatgpt已经为会员用户切换为gpt4.0模型. 未来短期时间内应该不会开放给免费用户使用.
GPT模型本质是续写模型, 它根据输入的文本生成相应的续写文本, 从而实现对话、文章等自然语言文本的生成. 所以其并不具备实际的创新能力, 只能对以往的“经验”做出梳理.
LLMs # Large language models (LLMs)大语言模型, 包括GPT和GLM等, 是一个统称. 以下是这个统称下的不同模型架构：
主流预训练模型架构 # autoregressive自回归模型（AR模型）：代表作GPT. 本质上是一个left-to-right的语言模型. 通常用于生成式任务, 在长文本生成方面取得了巨大的成功, 比如自然语言生成（NLG）领域的任务：摘要、翻译或抽象问答. 当扩展到十亿级别参数时, 表现出了少样本学习能力. 缺点是单向注意力机制, 在NLU任务中, 无法完全捕捉上下文的依赖关系.
autoencoding自编码模型（AE模型）：代表作BERT. 是通过某个降噪目标（比如MLM）训练的双向文本编码器. 编码器会产出适用于NLU任务的上下文表示, 擅长领域主要是自然语言处理领域, 例如文本分类、命名实体识别、情感分析、问答系统等. 但无法直接用于文本生成.
encoder-decoder（Seq2seq模型）：代表作T5. 采用双向注意力机制, 通常用于条件生成任务, 比如文本摘要、机器翻译等.
GLM模型基于autoregressive blank infilling方法, 结合了上述三种预训练模型的思想, 代表有清华大学的ChatGLM
LoRA和Prompt # Prompt 提示词, 是一种用于指导模型生成输出的文本片段, Prompt通常包含一些关键词或短语, 用于提示模型生成特定类型的文本. Prompt的使用可以提高模型的生成效果和准确性, 特别是在处理特定领域的文本时. 通过使用Prompt, 模型可以更好地理解输入文本的含义和上下文信息, 从而生成更加符合要求的输出文本. LoRA英文全称Low-Rank Adaptation of Large Language Models, 直译为大语言模型的低阶适应, 是一种PEFT（参数高效性微调方法）, 这是微软的研究人员为了解决大语言模型微调而开发的一项技术.</description></item><item><title>GPT技术分享</title><link>http://example.org/posts/gpt%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</link><pubDate>Sun, 12 Jun 2022 00:00:00 +0000</pubDate><guid>http://example.org/posts/gpt%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</guid><description>GPT技术分享 # 先介绍几个名词 # GPT 和 ChatGPT # Generative Pre-Training Transformer 是一种基于Transformer架构的预训练语言模型.
我们所接触到的chatgpt是针对gpt3.5模型的一种应用实例, 如今chatgpt已经为会员用户切换为gpt4.0模型. 未来短期时间内应该不会开放给免费用户使用.
GPT模型本质是续写模型, 它根据输入的文本生成相应的续写文本, 从而实现对话、文章等自然语言文本的生成. 所以其并不具备实际的创新能力, 只能对以往的“经验”做出梳理.
LLMs # Large language models (LLMs)大语言模型, 包括GPT和GLM等, 是一个统称. 以下是这个统称下的不同模型架构：
主流预训练模型架构 # autoregressive自回归模型（AR模型）：代表作GPT. 本质上是一个left-to-right的语言模型. 通常用于生成式任务, 在长文本生成方面取得了巨大的成功, 比如自然语言生成（NLG）领域的任务：摘要、翻译或抽象问答. 当扩展到十亿级别参数时, 表现出了少样本学习能力. 缺点是单向注意力机制, 在NLU任务中, 无法完全捕捉上下文的依赖关系.
autoencoding自编码模型（AE模型）：代表作BERT. 是通过某个降噪目标（比如MLM）训练的双向文本编码器. 编码器会产出适用于NLU任务的上下文表示, 擅长领域主要是自然语言处理领域, 例如文本分类、命名实体识别、情感分析、问答系统等. 但无法直接用于文本生成.
encoder-decoder（Seq2seq模型）：代表作T5. 采用双向注意力机制, 通常用于条件生成任务, 比如文本摘要、机器翻译等.
GLM模型基于autoregressive blank infilling方法, 结合了上述三种预训练模型的思想, 代表有清华大学的ChatGLM
LoRA和Prompt # Prompt 提示词, 是一种用于指导模型生成输出的文本片段, Prompt通常包含一些关键词或短语, 用于提示模型生成特定类型的文本. Prompt的使用可以提高模型的生成效果和准确性, 特别是在处理特定领域的文本时. 通过使用Prompt, 模型可以更好地理解输入文本的含义和上下文信息, 从而生成更加符合要求的输出文本. LoRA英文全称Low-Rank Adaptation of Large Language Models, 直译为大语言模型的低阶适应, 是一种PEFT（参数高效性微调方法）, 这是微软的研究人员为了解决大语言模型微调而开发的一项技术.</description></item><item><title>Paddle</title><link>http://example.org/docs/programmer/ml/paddle/</link><pubDate>Wed, 08 Jun 2022 18:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/ml/paddle/</guid><description>slug: Paddle的坑 # 资源占用 # 命令示例(yml中修改了train,test样本地址,使用--gpus这里只用了一个GPU,可方便修改为多卡0,1,2,3)
python -m paddle.distributed.launch --gpus &amp;#39;1&amp;#39; tools/train.py -c configs/rec/PP-OCRv3/en_PP-OCRv3_rec.yml -o Global.pretrained_model=./pretrain_models/en_PP-OCRv3_rec_train/best_accuracy.pdparams en_PP-OCRv3_rec默认性能配置在, 单卡V100上: +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+ | 1 Tesla V100-SXM2&amp;hellip; On | 00000000:00:09.0 Off | 0 | | N/A 53C P0 223W / 300W | 23065MiB / 32510MiB | 100% Default | | | | N/A | +&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-+
Paddle 多卡训练 # You may need to install &amp;rsquo;nccl2&amp;rsquo; from NVIDIA official website
Traceback: 这种问题可以参看Github Issues
写在坑前头 # 经测试，下面预训练模型下载地址和检测训练效果的脚本之所以报错是因为PaddleOCR项目主页的readme中链接的子readme是develop分支的。且这个分支是落后于当前release/2.5的，所以出现了以下不匹配的情况. 切换了分支之后, 匹配度还可以接受.</description></item><item><title>Blender</title><link>http://example.org/docs/3dgame/blender/</link><pubDate>Thu, 31 Mar 2022 15:15:14 +0000</pubDate><guid>http://example.org/docs/3dgame/blender/</guid><description> 快捷键 # 切换为四视图 | Ctrl+Alt+q 复制并移动(进入Grab模式) ｜ Shift+d(+x|y|x 选择移动轴) 线/面挤出 ｜ e(+x|y|x 选择挤出方向轴) 上一步的操作应用到当前选择 ｜ Shift+r 打开模型右侧的小工具栏(位置插件功能等调整) ｜ n 填充(两点连成线,线圈填成面) ｜ n 备忘 # 合并物体时,谁被最后选择&amp;ndash;是Active状态,将作为母体合并</description></item><item><title>PyPi使用说明</title><link>http://example.org/docs/programmer/langs/python/pypi/</link><pubDate>Thu, 31 Mar 2022 15:15:14 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/pypi/</guid><description>Pypi包管理 # 示例项目 # py-muti-scrcpy
配置文件 # pyproject
工具介绍 # poetry
增加安装包 # 直接修改pyproject.toml文件并不能生效, 因为还依赖于poetry.lock
可使用poetry add {xxx}进行添加
注意事项 # 需要链接外网 # HTTPSConnectionPool(host=&amp;#39;files.pythonhosted.org&amp;#39;, port=443): Max retries exceeded with url: /packages/17/61/32c3ab8951142e061587d957226b5683d1387fb22d95b4f69186d92616d1/typing_extensions-4.0.0-py3-none-any.whl (Caused by ProxyError(&amp;#39;Cannot connect to proxy.&amp;#39;, ConnectionResetError(54, &amp;#39;Connection reset by peer&amp;#39;))) HTTPSConnectionPool(host=&amp;#39;pypi.org&amp;#39;, port=443): Max retries exceeded with url: /pypi/colorama/0.4.4/json (Caused by ProxyError(&amp;#39;Cannot connect to proxy.&amp;#39;, ConnectionResetError(54, &amp;#39;Connection reset by peer&amp;#39;))) 需要安装ssl # SSLError HTTPSConnectionPool(host=&amp;#39;pypi.org&amp;#39;, port=443): Max retries exceeded with url: /pypi/importlib-metadata/4.</description></item><item><title>Tensorflow</title><link>http://example.org/docs/programmer/ml/tensorflow/</link><pubDate>Wed, 30 Mar 2022 17:23:23 +0000</pubDate><guid>http://example.org/docs/programmer/ml/tensorflow/</guid><description>
v2兼容v1 API # import tensorflow.compat.v1 as tf tf.disable_v2_behavior()</description></item><item><title>python打包</title><link>http://example.org/docs/programmer/gui/pyinstaller-python%E6%89%93%E5%8C%85/</link><pubDate>Fri, 18 Mar 2022 18:15:14 +0000</pubDate><guid>http://example.org/docs/programmer/gui/pyinstaller-python%E6%89%93%E5%8C%85/</guid><description> 打包 # pyinstaller
pip install pyinstaller pyinstaller /path/to/yourscript.py pyinstaller -key yourpasswd -F /path/to/yourscript.py 解包 # 解包工具 # pyinstxtractor.py
hex编辑器 # 010Editor 下载地址
步骤 # 将pyinstxtractor.py与exe放置在一个文件夹内，打开cmd，输入下列指令生成一个文件夹
python pyinstxtractor.py xxx.exe 使用010Editor打开文件夹中的main和struct，将struct中E3前面的字节复制粘贴到010Editor的E3前 修改main文件后缀为main.pyc 使用在线工具https://tool.lu/pyc/ 将main.pyc反编译为py文件
应对增加key之后的解包 # 暂无
安装程序 # 先将程序打包exe(以多文件模式, 但文件运行起来每次都需要解压再运行很慢，大文件的话多次运行还会挤压C盘空间) 将打包好的目录压缩打包zip 编写本质为mv lnk的脚本 把脚本打包成exe 执行脚本exe 具体代码可以看这里</description></item><item><title>Qt/PySide</title><link>http://example.org/docs/programmer/gui/qt/</link><pubDate>Tue, 18 Jan 2022 14:15:23 +0000</pubDate><guid>http://example.org/docs/programmer/gui/qt/</guid><description>绘制界面和使用 # 安装Qt本体后可以使用Design绘制图形化界面.而后保存为xxx.ui文件.
转换为py # 注意版本 pyside6-uic xxx.ui -o ui_xxx.py 不过信号槽就不要在Design中去标了, 放在py中手动创建和管理目前看来更为直观方便.</description></item><item><title>安装问题</title><link>http://example.org/docs/programmer/os/install_some/</link><pubDate>Sat, 15 Jan 2022 16:24:41 +0000</pubDate><guid>http://example.org/docs/programmer/os/install_some/</guid><description>记录一些安装问题 # Debian 使用 apt-add-repository(ppa) # sudo apt update sudo apt install software-properties-common FreeBSD桌面 # 换源 pkg install xorg xfce echo &amp;lsquo;dbus_enable=&amp;ldquo;YES&amp;rdquo;&amp;rsquo; &amp;raquo; /etc/rc.conf echo &amp;ldquo;/usr/local/etc/xdg/xfce4/xinitrc&amp;rdquo; &amp;gt; ~/.xinitrc startx 登录界面 # pkg install slim slim-themes echo &amp;lsquo;slim_enable=&amp;ldquo;YES&amp;rdquo;&amp;rsquo; &amp;raquo; /etc/rc.conf vbox(没测试) # pkg install virtualbox-ose-additions 向/etc/rc.conf写入 vboxguest_enable=&amp;#34;YES&amp;#34; vboxservice_enable=&amp;#34;YES&amp;#34; 仅供参考看这里 因为vbox显卡太弱安装了vmware后就一直没用回过vbox,我还没测试过
vmware # pkg install open-vm-tools xf86-video-vmware xf86-input-vmmouse 继续向/etc/rc.conf中写入 hald_enable=&amp;#34;YES&amp;#34; moused_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmblock_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmhgfs_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmmemctl_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmxnet_enable=&amp;#34;YES&amp;#34; # vmware_guest_enable=&amp;#34;YES&amp;#34; 下面注释掉的是因为在测试中如果打开的话会有各种问题&amp;hellip;.</description></item><item><title>Dgraph使用小记</title><link>http://example.org/docs/programmer/database/dgraph-graph-db/</link><pubDate>Mon, 10 Jan 2022 17:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/database/dgraph-graph-db/</guid><description>概念 # 以下参考自: 这里 Console # Mutate: 突变, 结构/数据变化的时候用 Query: 查询, Emmmm查询的时候用 所以看来没有getset了???? Schema # 管理字段(Predicate, Type, list,lang,index等)
问题 # 在新手村的时候使用dgraph/standalone 但此时(2021-12-8 18:30:23)文档使用的版本为dgraph/standalone:v21.03.2但是这个版本的Ratel UI不工作&amp;hellip;. 导致hello 不了 world很是难受
结果换了dgraph/standalone:v20.11.3好了诶.
sudo docker run --rm -it -p &amp;#34;8080:8080&amp;#34; -p &amp;#34;9080:9080&amp;#34; -p &amp;#34;8000:8000&amp;#34; -v ~/dgraph:/dgraph &amp;#34;dgraph/standalone:v20.11.3&amp;#34; http://127.0.0.1:8000 突变 # set # 内容较多, 下面单独罗列
delete # 根据UID 删除指定predicate_name
{ delete { &amp;lt;UID&amp;gt; &amp;lt;predicate_name&amp;gt; * . } } set # 创建 # 直接json给出结构和数据,即可完成创建.只不过如果有用到@lang时就需要去Schema里更新一下字段 - 类型 ?</description></item><item><title>Docker</title><link>http://example.org/docs/programmer/cloudnative/note-of-docker/</link><pubDate>Thu, 16 Dec 2021 16:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/note-of-docker/</guid><description>Docker # 教程手册 # 好用的使用教程
Install # 略过~ 😁
打镜像和跑 # docker build -t server:v0 . -f server.dockerfile 跑 # docker run -p 9080:80 --name server server:v0 指定启动命令 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;echo hello&amp;#34; 加入自定义网络 # --network {{network name}} 详见：[[#Network]]
跑出问题-进入容器排查 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;bash&amp;#34; 使用-it进入容器手动执行命令进行调试
启动全部容器 # docker ps -a | grep &amp;#34;Exited&amp;#34; | awk &amp;#39;{print $1}&amp;#39; | xargs docker start Network # docker run时容器加入方法-redis为例 后期加入方式 创建一个新网 检测 init_redis: docker run -p 6379:6379 \\ --network websafe-network \\ --name redislatest redis:latest --requirepass 3b21d032a7fd8eb51fa7bd8a2e812b78b7b3a36f join_network: docker network connect websafe-network mysql56 docker network connect websafe-network daemon-xxx init_network: docker network create websafe-network check_network: docker network inspect websafe-network docker network inspect websafe-network | findStr IPv4Address 删除 # 可视化 # go install github.</description></item><item><title>Docker</title><link>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-docker/</link><pubDate>Thu, 16 Dec 2021 16:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-docker/</guid><description>Docker # 教程手册 # 好用的使用教程
Install # 略过~ 😁
基础命令 # 打镜像和跑 # 打 # docker build -t server:v0 . -f server.dockerfile dockerignore # 如果您想在 Dockerfile 中将当前目录中的所有文件都复制到 Docker 镜像中，可以使用 Dockerfile 中的 COPY 指令。具体的语法如下：
COPY . /目标路径/ 其中. 表示当前目录，/目标路径/ 表示目标路径，这里可以是绝对路径或相对路径。 这将会将当前目录中的所有文件复制到镜像中的 /app/ 目录下。请注意，在这种情况下，所有文件和文件夹都会被复制到镜像中，包括隐藏文件和文件夹。如果您不想复制某些文件或文件夹，可以在运行 COPY 指令之前通过 .dockerignore 文件来指定忽略的文件和文件夹。
跑 # docker run -p 9080:80 --name server server:v0 指定启动命令 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;echo hello&amp;#34; 加入自定义网络 # --network {{network name}} 详见：[[#Network]]</description></item><item><title>Django的建站的(｡･･)ﾉﾞ</title><link>http://example.org/docs/programmer/cloudnative/fastapi/</link><pubDate>Mon, 07 Jun 2021 16:30:18 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/fastapi/</guid><description> 多一层目录时 # # Dir Tree just like: # . # ├── app # │ ├── __init__.py # │ └── main.py # ├── Dockerfile # └── requirements.txt 如果在app同级目录，而非app下运行时：
uvicorn app.main:app --reload</description></item><item><title>gRpc使用小记</title><link>http://example.org/docs/programmer/net/tips-of-grpc/</link><pubDate>Mon, 24 May 2021 10:30:41 +0000</pubDate><guid>http://example.org/docs/programmer/net/tips-of-grpc/</guid><description>
gRpc HelloWorld # helloWorld # quickstart
protoc --go_out=. --go_opt=paths=source_relative \ --go-grpc_out=. --go-grpc_opt=paths=source_relative \ helloworld/helloworld.proto MacOS下问题 # 原本protobuf中没有mac的gen-go和gen-go-grpc,所以需要额外运行安装. 除了使用brew用go get应该也是可以的,就是有路径问题,所以还是使用brew吧 brew install protobuf brew install protoc-gen-go brew install protoc-gen-go-grpc</description></item><item><title>Golang进阶笔记</title><link>http://example.org/docs/programmer/langs/golang/advanced-knowledge-of-golang/</link><pubDate>Wed, 19 May 2021 19:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/advanced-knowledge-of-golang/</guid><description>Golang进阶笔记 # 路径问题 # test_test.go # package main import &amp;#34;testing&amp;#34; func TestHelloWorld(t *testing.T) { // t.Fatal(&amp;#34;not implemented&amp;#34;) path := getCurrentPath() t.Log(&amp;#34;getCurrentPath: &amp;#34;, path) } test.go # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;strings&amp;#34; ) func main() { fmt.Println(&amp;#34;getTmpDir（当前系统临时目录） = &amp;#34;, getTmpDir()) fmt.Println(&amp;#34;getCurrentAbPathByExecutable（仅支持go build） = &amp;#34;, getCurrentAbPathByExecutable()) fmt.Println(&amp;#34;getCurrentAbPathByCaller（仅支持go run） = &amp;#34;, getCurrentAbPathByCaller()) fmt.Println(&amp;#34;getCurrentAbPath（最终方案-全兼容） = &amp;#34;, getCurrentAbPath()) fmt.Println(&amp;#34;getCurrentPath（runtime.Caller1） = &amp;#34;, getCurrentPath()) } // 最终方案-全兼容 func getCurrentAbPath() string { dir := getCurrentAbPathByExecutable() if strings.</description></item><item><title>Golang进阶笔记</title><link>http://example.org/docs/programmer/langs/golang/noteofgoexp/</link><pubDate>Wed, 19 May 2021 19:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/noteofgoexp/</guid><description>Golang进阶笔记 # 路径问题 # test_test.go # package main import &amp;#34;testing&amp;#34; func TestHelloWorld(t *testing.T) { // t.Fatal(&amp;#34;not implemented&amp;#34;) path := getCurrentPath() t.Log(&amp;#34;getCurrentPath: &amp;#34;, path) } test.go # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;strings&amp;#34; ) func main() { fmt.Println(&amp;#34;getTmpDir（当前系统临时目录） = &amp;#34;, getTmpDir()) fmt.Println(&amp;#34;getCurrentAbPathByExecutable（仅支持go build） = &amp;#34;, getCurrentAbPathByExecutable()) fmt.Println(&amp;#34;getCurrentAbPathByCaller（仅支持go run） = &amp;#34;, getCurrentAbPathByCaller()) fmt.Println(&amp;#34;getCurrentAbPath（最终方案-全兼容） = &amp;#34;, getCurrentAbPath()) fmt.Println(&amp;#34;getCurrentPath（runtime.Caller1） = &amp;#34;, getCurrentPath()) } // 最终方案-全兼容 func getCurrentAbPath() string { dir := getCurrentAbPathByExecutable() if strings.</description></item><item><title>PyTest</title><link>http://example.org/docs/programmer/langs/python/pytest/</link><pubDate>Mon, 10 May 2021 12:13:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/pytest/</guid><description>命令 # Django 整合进 pytest测试 # pip install pytest-django pytest -s -vv .\tests\test_step2.py --rootdir X:\Code\workflows\ --ds project.settings rootdir 指定项目根目录 ds 指向django setting.py 文件 一、为什么需要pytest # helps you write better programs
提高阅读理解代码效率 提高debug效率 提高开发效率 保证交付代码质量 简单例子 # 入门例子:
了解使用test文件命名格式: test_前缀 了解断言assert 了解测试输出 # content of test_sample.py def inc(x): return x + 1 def test_answer(): assert inc(3) == 5 输出
$ pytest =========================== test session starts ============================ platform linux -- Python 3.</description></item><item><title>UE4 笔记</title><link>http://example.org/docs/3dgame/noteofue4/</link><pubDate>Mon, 10 May 2021 12:13:26 +0000</pubDate><guid>http://example.org/docs/3dgame/noteofue4/</guid><description> UE4 笔记 # 手机 # 路径必须不能用汉字, 一律全英文(神奇&amp;hellip;以前习惯就是全英,以为这问题是上世纪的了,测试时不知怎么就把顺手的英文换成中文了,结果就莫名中枪了) java8 (ue4.26.2, 之前4.25也是, 反正就找个稳定版java一直使吧, 这语言太amazing了.) 虽然对java版本有一定要求, 不过按照我这次的测试和使用, 觉得折腾那么久完全是汉字项目名不支持&amp;hellip;所以java版本要求应该不是很严重 动画 # 事件图表&amp;amp;动画图表 # 事件图表: 收集动画-&amp;gt;存储在变量中 动画图表: 驱动所有动作 事件图表 # isValid # 蓝图不知道被哪个实例持有(通用)
朝向 # 主角本地坐标X轴正方向表正前方
GetVelocity
RotationFromXVector
GetControlRotaion
2,3求Delta.
输出 # 速度 方向 总步骤 # 向量长度获取Speed 向量方向-控制器方向获取Direction 以上2保存为变量, 交由动画图表 动画图表 # Params-Blend-Result:
获取速度,方向(看情况可多可少) 将1输入动画混合空间 输出姿势 State Machine # 在以上一组动作中加入状态细分
State Machine - State1-(rule)-State2&amp;hellip;StateN State - (Params-Blend-Result) 生效 # 角色 网格体(骨骼网格体) 动画-动画类-动画蓝图</description></item><item><title>Nginx高可用</title><link>http://example.org/docs/programmer/cloudnative/nginx-%E9%AB%98%E5%8F%AF%E7%94%A8/</link><pubDate>Sun, 09 May 2021 09:56:41 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/nginx-%E9%AB%98%E5%8F%AF%E7%94%A8/</guid><description>Keepalived+Nginx实现高可用 # Nginx 关键字 # IO多路复用epoll(IO复用) 轻量,插件: Nginx仅保留了HTTP CPU亲和: 每个worker进程固定在一个CPU Nginx配置 # 代理 # 动静分离 # 动态页面和静态页面交给不同的服务器来解析
负载均衡 # upstream balanceServer { server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345; } server { server_name fe.server.com; listen 80; location /api { proxy_pass http://balanceServer; } } 机制 # 默认: 轮询, 单机卡顿, 影响分配在这台服务器下的用户 默认: 权重轮询, 宕机Nginx会自动剔除出队列, ip_hash-来源IP分配分配给同个服务器 fair: 根据相应时间均衡分配, 默认不支持. 需安装upstream_fair, url_hash类ip_hash同样需要安装Nginx的hash软件包. Keepalived 配置 # 粘贴自: 这里
概览 # VIP IP 主机名 Nginx端口 默认主从 192.</description></item><item><title>OpenCV</title><link>http://example.org/docs/programmer/ml/opencv/</link><pubDate>Thu, 22 Apr 2021 17:23:23 +0000</pubDate><guid>http://example.org/docs/programmer/ml/opencv/</guid><description>
问题(libSM.so.6 缺失) # 运行opencv的代码时，报以下错误： # Traceback (most recent call last): File &amp;#34;data_generator.py&amp;#34;, line 24, in &amp;lt;module&amp;gt; import cv2 File &amp;#34;/usr/local/lib/python3.5/dist-packages/cv2/__init__.py&amp;#34;, line 3, in &amp;lt;module&amp;gt; from .cv2 import * ImportError: libSM.so.6: cannot open shared object file: No such file or directory 解决 # 原因是缺少共享文件库，解决办法如下：
安装apt-file $ apt-get update $ apt-get install apt-file $ apt-file update
寻找依赖库 $ apt-file search libSM.so.6
libsm6: /usr/lib/x86_64-linux-gnu/libSM.so.6 libsm6: /usr/lib/x86_64-linux-gnu/libSM.so.6.0.1
根据提示，安装合适的依赖库 $ apt-get install libsm6
其余文件缺失类似, 即可解决问题。</description></item><item><title>各个软件换源</title><link>http://example.org/docs/programmer/basetc/for_china/</link><pubDate>Thu, 22 Apr 2021 17:04:15 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/for_china/</guid><description>在国内用原源都会很慢, 所以总结一下各个软件(?吧)换源方法.
Qt # 使用Maintain管理kit时，可以在Settings中设置Repositories，设置地址可从Qt Downloads页面查询.
apt # 可解决版本升级时的问题,即使用了国内源,最后一个文件不知道为什么还是从国外拉取&amp;hellip;
# sudo touch /etc/apt/apt.conf sudo vim /etc/apt/apt.conf -&amp;gt; Acquire::http::Proxy &amp;ldquo;http://127.0.0.1:8001&amp;rdquo;;
FreeBSD # mkdir -p /usr/local/etc/pkg/repos vim /usr/local/etc/pkg/repos/bjtu.conf
bjtu: { url: &amp;#34;pkg+http://mirror.bjtu.edu.cn/reverse/freebsd-pkg/${ABI}/quarterly&amp;#34;, mirror_type: &amp;#34;srv&amp;#34;, signature_type: &amp;#34;none&amp;#34;, fingerprints: &amp;#34;/usr/share/keys/pkg&amp;#34;, enabled: yes } FreeBSD: { enabled: no } pkg update
Qt # 源 # 中国科学技术大学：http://mirrors.ustc.edu.cn/qtproject/ 清华大学：https://mirrors.tuna.tsinghua.edu.cn/qt/ 北京理工大学：http://mirror.bit.edu.cn/qtproject/ 中国互联网络信息中心：https://mirrors.cnnic.cn/qt/ Python Pip # pip install --index https://pypi.mirrors.ustc.edu.cn/simple/ dlib(numpy等包名) 源 # 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.</description></item><item><title>Epoll实现</title><link>http://example.org/docs/programmer/net/epoll%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 22 Apr 2021 15:15:14 +0000</pubDate><guid>http://example.org/docs/programmer/net/epoll%E5%AE%9E%E7%8E%B0/</guid><description>C++ &amp;amp; Epoll # 代码可见这里
也没啥高级就是:
create_socket epoll_create1 epoll_ctl(1. &amp;amp; 2.) struct epoll_event events[MAX_EPOLL_EVENTS] = {0}; while1: epoll_wait(2, &amp;amp; 4.) eventfd == sockfd accept else =&amp;gt; connfd read 所以就是:
epoll_event -&amp;gt; 内核空间 epitem -&amp;gt; 红黑 设备事件就绪 - callback (epitem -&amp;gt; rdlist链表) emmmm&amp;hellip;有需要再继续整理吧 和select-poll区别为: 一个遍历, 一个触发式的.</description></item><item><title>Tips of debuggers</title><link>http://example.org/docs/programmer/langs/tips-of-debugers/</link><pubDate>Thu, 10 Jan 2019 12:21:12 +0000</pubDate><guid>http://example.org/docs/programmer/langs/tips-of-debugers/</guid><description>Clang &amp;amp;&amp;amp; lldb # 听说clang+lldb &amp;gt;= gcc + gdb, 所以一试:
lldb基本命令 # 与GDB相同
break (b) - 设置断点，也就是程序暂停的地方 run (r) - 启动目标程序，如果遇到断点则暂停 step (s) - 进入下一条指令中的函数内部 backtrace (bt) - 显示当前的有效函数 frame (f) - 默认显示当前栈的内容，可以通过 frame arg 进入特定的 frame（用作输出本地变量） next (n) - 运行当前箭头指向行 continue (c) - 继续运行程序直到遇到断点。 clang hello.c -g -o hello lldb hello # lldb b main run n p str 还有颜色 😂 可视效果确实提高了不少 而且这四个工具可以混用,也蛮好.
GDB # First and foremost, you will need to compile your program with the flag &amp;ldquo;-g&amp;rdquo; (for debug) to run it via GDB.</description></item><item><title>Django的建站的(｡･･)ﾉﾞ</title><link>http://example.org/docs/programmer/cloudnative/notesdjango/</link><pubDate>Thu, 07 Jun 2018 16:30:18 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/notesdjango/</guid><description>author: Ian
Django 的一些东西 # 一些问题 # 使用字体 zh-cn时如果报错: # OSError: No translation files found for default language zh-cn.
LANGUAGE_CODE = &amp;#39;zh-Hans&amp;#39; TIME_ZONE = &amp;#39;Asia/Shanghai&amp;#39; # zh-Hans是简体中文 zh-Hant是繁体中文 # 如果数据库有UTC的时间，那么可以设置： # USE_TZ = True 改为 USE_TZ = False 时区问题 # python3.8/site-packages/django/db/models/fields/init.py:1416: RuntimeWarning: DateTimeField {DATABASEMODEL}.update_time received a naive datetime (2023-09-14 21:55:56) while time zone support is active. warnings.warn(&amp;ldquo;DateTimeField %s received a naive datetime (%s)&amp;rdquo;
这个警告是由于在使用带有时区支持的DateTimeField字段时，传入了一个没有时区信息的datetime对象。要修复这个警告，你可以将传入DateTimeField字段的datetime对象转换为带有时区信息的datetime对象。
有两种方法可以解决这个问题：
使用带有时区信息的datetime对象：确保在创建datetime对象时，使用正确的时区信息。你可以使用pytz库来设置时区信息，例如： from datetime import datetime import pytz # 创建带有时区信息的datetime对象 naive_datetime = datetime(2023, 9, 14, 21, 55, 56) timezone = pytz.</description></item><item><title>Golang笔记</title><link>http://example.org/docs/programmer/langs/golang/note-of-golang/</link><pubDate>Tue, 15 May 2018 10:18:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/note-of-golang/</guid><description>Golang笔记 # 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html
垃圾回收 # 常见的回收算法 # 引用计数 优点：对象可以被很快回收 缺点：不太好处理循环引用 标记-清除 优点：解决了引用计数的缺点 缺点：需要 STW(Stop The World),暂时停止程序运行 分代收集(按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，段的放入新生代，不同代有不同的回收算法和回收频率) 优点：回收性能好 缺点：算法复杂 三色标记法(初始状态：白色、从根节点开始遍历，遍历到的变成灰色，遍历灰色，将灰色引用的标记灰色，遍历过的灰色对象变为黑色。循环遍历灰色对象。通过写屏障检测对象的变化，重复。收集所有白色对象(垃圾)) GPM调度和CSP模型 # CSP 模型？ # CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通 过共享内存来通信。用于描述两个独立的并发实体通过共享的通 讯 channel (管道)进行通信的并发模型。
GPM 分别是什么、分别有多少数量？ # • G（Goroutine）： 即Go协程，每个go关键字都会创建一个协 程。 • M（Machine）：工作线程，在Go中称为Machine，数量对应真 实的CPU数（真正干活的对象）。 • P（Processor）： 处理器（Go中定义的一个摡念，非CPU）， 包含运行Go代码的必要资源，用来调度 G 和 M 之间的关联关 系，其数量可通过 GOMAXPROCS() 来设置，默认为核心数。 M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队 列，P可以调度G交由M执行。
Goroutine调度策略 # • 队列轮转：P 会周期性的将G调度到M中执行，执行一段时间 后，保存上下文，将G放到队列尾部，然后从队列中再取出一个 G进行调度。除此之外，P还会周期性的查看全局队列是否有G等 待调度到M中执行。 • 系统调用：当G0即将进入系统调用时，M0将释放P，进而某个空 闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是 M的缓存池，也可能是新建的。 当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执 行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。 然后M0将进入缓存池睡眠。 !</description></item><item><title>Golang笔记</title><link>http://example.org/docs/programmer/langs/golang/noteofgolang/</link><pubDate>Tue, 15 May 2018 10:18:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/noteofgolang/</guid><description>Golang笔记 # 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html
并发 Channel # 使用关键字go开启goroutine 轻量级线程
go fun_name(paras_list) # eg: go f(x, y, z) 代码
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func say(s string) { for i := 0; i &amp;lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;#34;world&amp;#34;) say(&amp;#34;hello&amp;#34;) } Channel # 用于传递数据的数据结构 可用于两个goroutine之间传递指定类型值，同步和通讯 &amp;lt;- 指定通道方向(发送or接受)，未指定则双向通道
声明通道 # 使用chan关键字, 在使用之前，需先创建.
ch := make(chan int) 示例
package main import &amp;#34;fmt&amp;#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c &amp;lt;- sum // 把 sum 发送到通道 c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &amp;lt;-c, &amp;lt;-c // 从通道 c 中接收 fmt.</description></item><item><title>Vn.Py学习笔记（Python交易平台框架）</title><link>http://example.org/docs/programmer/gui/vn.py%E7%AC%94%E8%AE%B0-%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Tue, 15 May 2018 10:13:48 +0000</pubDate><guid>http://example.org/docs/programmer/gui/vn.py%E7%AC%94%E8%AE%B0-%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>author: Ian
Vn.Py笔记 ✏📔 # # 一个开源Python交易软件，主使用CTP协议。当然，还有其他协议了其源项目在http://www.vnpy.org/ 初期笔记 # 报单交易过程中， CTP使用BrokerID 从业务层面完全隔离不同经纪公司的交易、风控及结算用户的接入。 BrokerID具体取值咨询开户的经纪公司。 CTP中 UserID为操作员代码，InversterID为投资者代码； 投资者自己下单两者同为投资者代码
CTP-API中，OrderRef和OrderAction 前者为CTP后台提供给客户端标识一笔报 单的字段，从客户端可通过（FrontID、SessionID、OrderRef）唯一确定一笔报 单；；；后者与OrderRef功能相似，提供给客户端来标识一笔撤单。 前者的数据类型为字符数组，必须为阿拉伯数字字符。 OrderRef（OrderActionRef）取值必须保证在同一会话内发送的报单 OrderRef（OrderActionRef）值大于之前的最大值，开发多线程客户端尤为需要 注意。 CTP-API库：
error.dtd\error.xml 错误定义文件 ---- ThostFrfcMdApi.h 交易接口类定义文件 ——— ThostFtfcUserApiDataType.h 类型定义文件 ------ thostmduserapi.lib,thostmduserpi.dll 行情接口库文件 ----- thosttraderapi.lib,thosttraderapi.dll交易接口库文件 ----- 交易和行情接口类定义文件都包含API 和 SPI类定义，客户端使用API向CTP后台 发送请求，CTP后台则使用SPI向客户端回传响应及回报 行情Demo开发： 1.将API文件复制到工程目录；并将所有的头文件和静态、动态库连链接库 并将文件导入到项目工程中。 先继承行情接口类CThostFtdcMdspi，并实现需要实现的虚函数。 OnFrontConnectde、OnFrontDisconnected、OnPspUserLogin、 OnRspSubMarketDAta /API工作流程***/
API压缩包——API含常量对应字符、类型定义、操作系统编译定义、回调函数（MdSpi）（柜台向用户端发送信息后被系统自动调用的函数）、主动函数（MdApi）（向柜台发送各种请求和指令）
API工作流程： 创建MdSpi对象（回掉函数），调用MdApi类，以Create开头的静态方法，创建MdApi对象（主动函数），注册MdSpi对象指针，行情柜台前置机地址，调用MdApi对象Init方法初始化连接前置机，连接成功会通过OnFrontConnected回调通知用户，用户获得连接成功通知后，调MdApi的ReqUserLogin登陆，登陆后MdSpi的OnRsqUserLogin通知用户 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-到此登陆完成&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
MdApi：（行情相关） 使用MdApi对象的SubscribeMarketData方法，传入参数为想要订阅的“合约 代码”，订阅成功当合约有新行情通过MdApi的OnRtnDepthMarketData回调通知 用户 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-至此订阅完成&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 当用户的某次请求发生错误时，会通过OnRspError通知用户 MdApi也含有退订合约、登出功能。 而一般退出程序则直接杀进程（不太安全便是）
TraderApi：（交易相关） 不同于以上的有 注册TraderSpi对象的指针后需要调用TraderApi对象的 SubscribePrivateTopic和SubscribePublicTopic方法去选择公开和私有数据流的重 传方法 对于期货柜台，每一日第一次登陆需要先查询前一日的结算单，等待查询 结果返回，确认，才可进行后续操作（CTP、恒生UFT），证券（LTS）无此要求 上一步完成后，用户可以调用ReqQryInstrument的方法查询柜台上所有可 以交易的合约信息（包括代码、中文名、涨跌停、最小价位变动、合约乘数等大 量细节），一般是在这里获得合约信息列表后，再去MdApi中订阅合约；经常有 人问为什么在MdApi中找不到查询可供订阅的合约代码的函数，这里尤其要注 意，必须通过TraderApi来获取 当用户报单、成交状态发生变化时，TraderApi会自动通过OnRtnOrder、 OnRtnTrade通知，无需额外订阅 /封装API****/ 封装后API的动作： 主动函数： 调用封装API主动函数，传入Python变量作为参数—&amp;gt;封装API将Python变量转换成C++变量—&amp;gt;API调用原生API主动函数传入C++变量作为参数 回掉函数： 交易柜台通过原生API传入参数为C++变量-&amp;gt;封装API将C++变量转换为Python变量-&amp;gt;封装API调用封装后的回调函数想Python程序中推送数</description></item><item><title>Tips of MarkDown</title><link>http://example.org/docs/programmer/langs/tips-of-markdown/</link><pubDate>Tue, 15 May 2018 10:00:47 +0000</pubDate><guid>http://example.org/docs/programmer/langs/tips-of-markdown/</guid><description>Markdown Notes 📪 # 对勾和叉叉(叉号) # #对勾 #叉号
- &amp;amp;#9744; x &amp;amp;cross; - &amp;amp;#9745; &amp;amp;#10004; &amp;amp;check; ☐ x ✗ ☑ ✔ ✓ HTML锚点 - 页面内点击跳转 # 可以使用 HTML 锚点来实现点击内容跳转当前页面某标题。 具体实现方法如下：
首先，在需要跳转到的标题前插入一个 HTML 锚点，例如： ### &amp;lt;a name=&amp;#34;section1&amp;#34;&amp;gt;Section 1&amp;lt;/a&amp;gt; 这个锚点的名称为 &amp;#34;section1&amp;#34;，可以根据需要自定义。 在需要点击跳转的内容处，使用 Markdown 的链接语法，将链接地址设置为锚点名称加上 # 符号，例如： [跳转到 Section 1](#section1) 这样，点击这个链接就会跳转到页面中的 &amp;#34;Section 1&amp;#34; 标题处。 注意事项： # 锚点名称必须是唯一的，否则链接可能会跳转到错误的位置。 如果需要跳转到其他页面的锚点，链接地址应该包括页面路径和锚点名称，例如：/path/to/page.html#section1。
## Test 二级标题
Now I will test the Markdown&amp;rsquo;s hobiy 二级 # Maybe is a nice way to impove my blog.</description></item><item><title>tip Of vim</title><link>http://example.org/docs/programmer/basetc/tipsofvim/</link><pubDate>Tue, 15 May 2018 09:56:41 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/tipsofvim/</guid><description>Vim 使用 # 除去“简便生活”里的几条配置，在纠结是否添加到别的地方，果然还是单独给vim一个使用手册比较好……
注释 # # 注释 1， 12s/^/#/g --- # 取消注释 1， 12s/^#//g 其实 是vim中的 :s替换命令… 下方解释
或者，使用列编辑的模式:
v、选择区域、ctrl q置行首、I插入#、Esc应用到全列 ctrl v、I、#、Esc 因为有的ctrl q或者ctrl v 不能用…… 取消，即使用上述方法选中行首，删除第一个字节即可了 替换 # :s/oldWords/newWords/g g : 代表当前光标所在行。
由此可知: # ^表行首标识符。 /^/表示行首的空字符。 而取消注释中的/^#/即表示行首的#，被//空字符所替换。
查找高亮 # set hlsearch set nohlsearch 分屏 # 实现 # 在外部使用-o or -O参数 内部split or vsplit 操作 # 移动光标 Ctrl + w hjkl 移动分区Ctrl + w HJKL 统一高度Ctrl + w = 改变高度Ctrl + w +- more and less # 阅读器~~~ 因为经常读大文件发现了这两个的无敌好处——快。</description></item><item><title>安卓</title><link>http://example.org/docs/programmer/os/android/</link><pubDate>Tue, 15 May 2018 09:56:41 +0000</pubDate><guid>http://example.org/docs/programmer/os/android/</guid><description>将安卓手机用于开发 # Termux # 类似于WIN端的Subsystem——其实更像Ubuntu下的虚拟终端。 不过这东西功能强大，除了将安卓里的Linux发挥出来。还有Termux API来调用手机的底层接口。
XFCE4 # 步骤：
安装Termux 执行pkg update 执行pkg install git &amp;amp;&amp;amp; git clone https://github.com/Yisus7u7/termux-desktop-xfce.git 执行cd termux-desktop-xfce &amp;amp;&amp;amp; bash boostrap.sh 当然，3&amp;amp;4步可以合并为一句curl -sLf https://raw.githubusercontent.com/Yisus7u7/termux-desktop-xfce/main/boostrap.sh | bash
VNC # 默认VNC只能通过localhost:1来连接，局域网不能访问。想用大屏来看就不是很方便。
# 先执行`vncserver`使用本机的`VNC Viewer`看看效果，主要是需要先设置一下密码 vncserver # 现在还无法通过局域网连接 # 去设置 cd ~/.vnc/ vim config # 打开最后一行注释 # 重新运行 vncserver -kill :1 vncserver 配置文件一览 # 将config文件最后一行的注释打开，即可
## Supported server options to pass to vncserver upon invocation can be listed ## in this file.</description></item><item><title>数据库-MongoDB篇</title><link>http://example.org/docs/programmer/database/note-of-db-data-mongodb/</link><pubDate>Tue, 15 May 2018 09:51:09 +0000</pubDate><guid>http://example.org/docs/programmer/database/note-of-db-data-mongodb/</guid><description>DB数据库 🖥 📊🖥 # MongoDB笔记 # 学习网站：http://www.runoob.com/mongodb/mongodb-tutorial.html (其学习教程还挺可观，很多，不过还不清楚好不好)
安装 # Docker 安装 4.4.12版本 # pull: docker pull mongo:4.4.13 run: docker run -itd --name mongo --restart=always \ -v /mongodb/datadb:/data/db \ -p 27017:27017 \ --network websafe-network \ --privileged=true mongo:4.4.12 进入容器docker exec -it mongo bash后:
mongo use admin # db.createUser({user: &amp;#34;admin&amp;#34;, pwd: &amp;#34;admin&amp;#34;, roles: [{role: &amp;#34;root&amp;#34;, db: &amp;#34;admin&amp;#34;}]}) # db.createUser({user: &amp;#34;admin&amp;#34;, pwd: &amp;#34;admin&amp;#34;, roles: [{role: &amp;#34;userAdminAnyDatabase&amp;#34;, db: &amp;#34;admin&amp;#34;}]}) # 如果能auth就不用createUser了 db.auth(&amp;#34;admin&amp;#34;, &amp;#34;admin&amp;#34;) 网上传的将 MONGO_INITDB_ROOT_PASSWORD 和 MONGO_INITDB_ROOT_USERNAME传入环境变量的方式，在mongo4.</description></item><item><title>数据库-MySQL篇</title><link>http://example.org/docs/programmer/database/note-of-db-data-mysql/</link><pubDate>Tue, 15 May 2018 09:51:09 +0000</pubDate><guid>http://example.org/docs/programmer/database/note-of-db-data-mysql/</guid><description>MySQL数据库 🖥 📊🖥 # 连接 # 使用MySQL命令行工具连接MySQL时，你可以使用以下命令来：
启用压缩传输 # mysql --compress -u username -p 完整命令如：
mysql --compress -u{username} -p{passwd} --host {host} {db name} 2024-05-27: 但是很可惜，很多第三方连接库都不支持这个参数。
MySQL 8.0 # 因为在更新8.0 之后更改了用户密码加密形式所以在使用客户端连接的时候会出现错误，所以需要
ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; #修改加密规则 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; #更新用户的密码 FLUSH PRIVILEGES; #刷新权限 经此步骤，就可以将密码加密形式改为图形化客户端支持的加密形式，也或者更待客户端跟着服务端同步更新。
另外，配置之初，windows 中配置步骤如下：
添加系统环境变量path 为MySQL/bin 初始化 mysqld --initialize --user=mysql --console 根据初始化随机生成密码登陆 修改密码 emm 这里说的是在外部，当然也可以在修改加密形式的时候一并修改 😄 mysqladmin -u root -p password 添加系统服务 mysqld -install 启动服务 net start mysql 另外在图像化里面注意密码格式呦，还有使用navicat的话需要最新版本，否则无法设置加密格式，还得用命令行去修改……果然还是命令行永远最好用</description></item><item><title>FreeBSD</title><link>http://example.org/docs/programmer/os/freebsd/</link><pubDate>Tue, 08 Nov 2016 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/os/freebsd/</guid><description>FreeBSD # 桌面 # 换源 pkg install xorg xfce echo &amp;lsquo;dbus_enable=&amp;ldquo;YES&amp;rdquo;&amp;rsquo; &amp;raquo; /etc/rc.conf echo &amp;ldquo;/usr/local/etc/xdg/xfce4/xinitrc&amp;rdquo; &amp;gt; ~/.xinitrc startx 登录界面 # pkg install slim slim-themes echo &amp;lsquo;slim_enable=&amp;ldquo;YES&amp;rdquo;&amp;rsquo; &amp;raquo; /etc/rc.conf vbox(没测试) # pkg install virtualbox-ose-additions 向/etc/rc.conf写入 vboxguest_enable=&amp;#34;YES&amp;#34; vboxservice_enable=&amp;#34;YES&amp;#34; 仅供参考看这里 因为vbox显卡太弱安装了vmware后就一直没用回过vbox,我还没测试过
vmware # pkg install open-vm-tools xf86-video-vmware xf86-input-vmmouse 继续向/etc/rc.conf中写入 hald_enable=&amp;#34;YES&amp;#34; moused_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmblock_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmhgfs_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmmemctl_enable=&amp;#34;YES&amp;#34; # vmware_guest_vmxnet_enable=&amp;#34;YES&amp;#34; # vmware_guest_enable=&amp;#34;YES&amp;#34; 下面注释掉的是因为在测试中如果打开的话会有各种问题&amp;hellip;.尤其鼠标 其他可见这里参考 =&amp;gt; 该Blog仅供参考, 这里面的东西很多都是有问题的.
换源 # mkdir -p /usr/local/etc/pkg/repos vim /usr/local/etc/pkg/repos/bjtu.</description></item><item><title>编辑器使用</title><link>http://example.org/docs/programmer/basetc/editer/</link><pubDate>Sat, 29 Oct 2016 16:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/editer/</guid><description>Jupyter-Note # 局域网访问 # 方法1: 使用jupyter notebook --generate-config生成配置文件 修改配置文件中c.NotebookApp.allow_root(因为安卓用的Termux跑的,所以伪root),c.NotebookApp.ip这样就能通过局域网和Token访问了 如果想要使用密码(长期使用局域网的话),可以使用from notebook.auth import passwd;passwd()生成加密密码,配置到c.NotebookApp.password 方法2: 如果只是临时的,那传入运行命令肯定最好了,如下可以使用如下格式: jupyter-notebook --allow-root --ip=0.0.0.0 自动补全 # 安装插件: pip install jupyter_contrib_nbextensions -i https://pypi.tuna.tsinghua.edu.cn/simple(此命令包含代理) 到Nbextensions中将Disable改为Enable 开始 Vim # vim 查看日志中文乱码(2021) # .bash_profile # export LC_ALL=en_US.utf-8 .vimrc # set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936 set termencoding=utf-8 set encoding=utf-8 双管齐下, 一个解决系统配置, 一个解决vim配置
中文乱码问题(2018) # 在.bash_profile中增加
export LANG=zh_CN.utf8 export LC_ALL=zh_CN.utf8 即可增加中文支持。 不过，还是
export LANG=en_US.utf8 export LC_ALL=en_US.utf8 比较香，因为中文字体很难看… ^_^: 2019年5月5日19点46分
vscode vs code # venv # Python # Command Palette.</description></item><item><title>Linux 笔记</title><link>http://example.org/docs/programmer/os/note-of-linux/</link><pubDate>Fri, 08 Apr 2016 16:58:56 +0000</pubDate><guid>http://example.org/docs/programmer/os/note-of-linux/</guid><description>git fetch &amp;ndash;all git reset &amp;ndash;hard origin/master git pull 交换分区 # 大小推荐 # 物理内存 交换分区（SWAP） &amp;lt;= 4G 至少4G 4~16G 至少8G 16G~64G 至少16G 64G~256G 至少32G 调节操作 # # 查看命令相关 sudo swapo swapoff swapon # 关闭现有的交换分区 sudo swapoff /swapfile # 查看效果 htop # 预支出一块儿空地 sudo fallocate -l 16G /swapfile du -sh /swapfile # 设置权限 防止误操作 sudo chmod 600 /swapfile # 整上 sudo mkswap /swapfile mkswap: /swapfile：警告，将擦除旧的 swap 签名。 正在设置交换空间版本 1，大小 = 16 GiB (17179865088 个字节) 无标签， UUID=6de8b5e1-bdc3-4e7b-98c9-6801126fcb0b # 开!</description></item><item><title/><link>http://example.org/docs/example/hidden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/hidden/</guid><description>This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem.</description></item><item><title/><link>http://example.org/docs/example/shortcodes/buttons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/buttons/</guid><description> Buttons # Buttons are styled links that can lead to local page or external link.
Example # {{&amp;lt; button relref=&amp;#34;/&amp;#34; [class=&amp;#34;...&amp;#34;] &amp;gt;}}Get Home{{&amp;lt; /button &amp;gt;}} {{&amp;lt; button href=&amp;#34;https://github.com/alex-shpak/hugo-book&amp;#34; &amp;gt;}}Contribute{{&amp;lt; /button &amp;gt;}} Get Home Contribute</description></item><item><title/><link>http://example.org/docs/example/shortcodes/columns/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/columns/</guid><description>Columns # Columns help organize shorter pieces of content horizontally for readability.
{{&amp;lt; columns &amp;gt;}} &amp;lt;!-- begin columns block --&amp;gt; # Left Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Mid Content Lorem markdownum insigne... &amp;lt;---&amp;gt; &amp;lt;!-- magic separator, between columns --&amp;gt; # Right Content Lorem markdownum insigne... {{&amp;lt; /columns &amp;gt;}} Example # Left Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!</description></item><item><title/><link>http://example.org/docs/example/shortcodes/details/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/details/</guid><description>Details # Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.
Example # {{&amp;lt; details &amp;#34;Title&amp;#34; [open] &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} {{&amp;lt; details title=&amp;#34;Title&amp;#34; open=true &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /details &amp;gt;}} Title Markdown content # Lorem markdownum insigne&amp;hellip;</description></item><item><title/><link>http://example.org/docs/example/shortcodes/expand/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/expand/</guid><description>Expand # Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.
Example # Default # {{&amp;lt; expand &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Expand ↕ Markdown content # Lorem markdownum insigne&amp;hellip;
With Custom Label # {{&amp;lt; expand &amp;#34;Custom Label&amp;#34; &amp;#34;...&amp;#34; &amp;gt;}} ## Markdown content Lorem markdownum insigne... {{&amp;lt; /expand &amp;gt;}} Custom Label ... Markdown content # Lorem markdownum insigne.</description></item><item><title/><link>http://example.org/docs/example/shortcodes/hints/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/hints/</guid><description>Hints # Hint shortcode can be used as hint/alerts/notification block.
There are 3 colors to choose: info, warning and danger.
{{&amp;lt; hint [info|warning|danger] &amp;gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{&amp;lt; /hint &amp;gt;}} Example # Markdown content
Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content</description></item><item><title/><link>http://example.org/docs/example/shortcodes/section/first-page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/section/first-page/</guid><description>First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description></item><item><title/><link>http://example.org/docs/example/shortcodes/section/second-page/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/section/second-page/</guid><description>Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</description></item><item><title/><link>http://example.org/docs/example/shortcodes/tabs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/example/shortcodes/tabs/</guid><description>Tabs # Tabs let you organize content by context, for example installation instructions for each supported platform.
{{&amp;lt; tabs &amp;#34;uniqueid&amp;#34; &amp;gt;}} {{&amp;lt; tab &amp;#34;MacOS&amp;#34; &amp;gt;}} # MacOS Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Linux&amp;#34; &amp;gt;}} # Linux Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; tab &amp;#34;Windows&amp;#34; &amp;gt;}} # Windows Content {{&amp;lt; /tab &amp;gt;}} {{&amp;lt; /tabs &amp;gt;}} Example # MacOS MacOS # This is tab MacOS content.
Lorem markdownum insigne. Olympo signis Delphis!</description></item><item><title/><link>http://example.org/docs/programmer/basetc/bash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/bash/</guid><description>Bash # Auther: Ian
自动补全 # linux中使用bash_completion工具进行自动不全，在某些发行版或者版本中make或者git没有Tab自动补全，这时在Github上找一个bash_completion文件放在相应位置就可以了。
sudo cp bash_completion /usr/share/bash-completion/bash_completion source /usr/share/bash-completion/bash_completion Powershell # 命令历史存储在: C:\Users\{USERNAME}\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine下 ConsoleHost_history.txt文件</description></item><item><title/><link>http://example.org/docs/programmer/basetc/gitbook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/gitbook/</guid><description>Gitbook # Author: Ian
安装 # 官方文档 Github Gitbook 打造的 Gitbook 说明文档 使用npm进行安装, 安装npm (v4.0.0 and above is recommended) npm install gitbook-cli -g 需要sudo权限 实际在执行gitbook -V后才算是安装完成 问题 # TypeError: cb.apply is not a function # npm 安装软件不出点儿问题貌似都不是很合适, 该问题代码级问题是因为在适配某些可能本机上并没有安装的npm版本时写了bug，导致执行出错.
所以注释掉相关代码即可，或者直接删除。删除的好处是不会因为编辑器的原因触发npm的某些缩进问题。
62. // fs.stat = statFix(fs.stat) 63. // fs.fstat = statFix(fs.fstat) 64. // fs.lstat = statFix(fs.lstat) 固然可以通过安装相匹配版本进行适配，不过&amp;hellip;Ian怕导致本机上的hexo再出现版本不兼容的问题。 使用 # 功能 示例 个人使用习惯(Ian) 新建book gitbook init gitbook init gitbooks/Architecture 编译和运行服务 gitbook serve 编译 gitbook serve pdf # 参考自 码谱</description></item><item><title/><link>http://example.org/docs/programmer/basetc/vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/vim/</guid><description>&lt;h1 id="vim-使用">
 Vim 使用
 &lt;a class="anchor" href="#vim-%e4%bd%bf%e7%94%a8">#&lt;/a>
&lt;/h1>
&lt;p>Auther: Ian&lt;/p>
&lt;p>&lt;img src="https://www.vim.org/images/vim_header.gif" alt="vim" />&lt;/p>
&lt;h2 id="注释">
 注释
 &lt;a class="anchor" href="#%e6%b3%a8%e9%87%8a">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-vim" data-lang="vim">&lt;span style="display:flex;">&lt;span> # &lt;span style="color:#a6e22e">注释&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>， &lt;span style="color:#ae81ff">12&lt;/span>s&lt;span style="color:#e6db74">/^/&lt;/span>#/&lt;span style="color:#a6e22e">g&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> # &lt;span style="color:#a6e22e">取消注释&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span>， &lt;span style="color:#ae81ff">12&lt;/span>s&lt;span style="color:#e6db74">/^#/&lt;/span>/&lt;span style="color:#a6e22e">g&lt;/span> 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实 是&lt;code>vim&lt;/code>中的 &lt;code>:s&lt;/code>替换命令… 下方解释&lt;/p>
&lt;p>或者，使用列编辑的模式:&lt;/p>
&lt;pre>&lt;code>v、选择区域、ctrl q置行首、I插入#、Esc应用到全列
ctrl v、I、#、Esc
因为有的ctrl q或者ctrl v 不能用……

取消，即使用上述方法选中行首，删除第一个字节即可了
&lt;/code>&lt;/pre>
&lt;h2 id="替换">
 替换
 &lt;a class="anchor" href="#%e6%9b%bf%e6%8d%a2">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-vim" data-lang="vim">&lt;span style="display:flex;">&lt;span> :&lt;span style="color:#a6e22e">s&lt;/span>&lt;span style="color:#e6db74">/oldWords/&lt;/span>&lt;span style="color:#a6e22e">newWords&lt;/span>/&lt;span style="color:#a6e22e">g&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>g : 代表当前光标所在行。&lt;/p>
&lt;h3 id="由此可知">
 由此可知:
 &lt;a class="anchor" href="#%e7%94%b1%e6%ad%a4%e5%8f%af%e7%9f%a5">#&lt;/a>
&lt;/h3>
&lt;p>&lt;code>^&lt;/code>表行首标识符。 &lt;code>/^/&lt;/code>表示行首的空字符。 而取消注释中的&lt;code>/^#/&lt;/code>即表示行首的&lt;code>#&lt;/code>，被&lt;code>//&lt;/code>空字符所替换。&lt;/p>
&lt;hr>
&lt;h2 id="查找高亮">
 查找高亮
 &lt;a class="anchor" href="#%e6%9f%a5%e6%89%be%e9%ab%98%e4%ba%ae">#&lt;/a>
&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-vim" data-lang="vim">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#a6e22e">hlsearch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#a6e22e">nohlsearch&lt;/span> 
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="分屏">
 分屏
 &lt;a class="anchor" href="#%e5%88%86%e5%b1%8f">#&lt;/a>
&lt;/h2>
&lt;h3 id="实现">
 实现
 &lt;a class="anchor" href="#%e5%ae%9e%e7%8e%b0">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>在外部使用&lt;code>-o&lt;/code> or &lt;code>-O&lt;/code>参数&lt;/li>
&lt;li>内部&lt;code>split&lt;/code> or &lt;code>vsplit&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="操作">
 操作
 &lt;a class="anchor" href="#%e6%93%8d%e4%bd%9c">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>移动光标 &lt;code>Ctrl + w&lt;/code> hjkl&lt;/li>
&lt;li>移动分区&lt;code>Ctrl + w&lt;/code> HJKL&lt;/li>
&lt;li>统一高度&lt;code>Ctrl + w&lt;/code> =&lt;/li>
&lt;li>改变高度&lt;code>Ctrl + w&lt;/code> +-&lt;/li>
&lt;/ul>
&lt;h1 id="heading">
 
 &lt;a class="anchor" href="#heading">#&lt;/a>
&lt;/h1></description></item><item><title/><link>http://example.org/docs/programmer/cloudnative/k8s/argo-workflow%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/argo-workflow%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</guid><description>Github: https://github.com/argoproj
一、简介 # Argo Workflow 是一个开源的、基于 Kubernetes 的工作流引擎，用于编排和运行容器化应用的工作流程。它使用 YAML 文件来定义工作流、依赖关系和参数。
Argo Workflow 还支持任务的重试、跳过、并行执行和失败处理等功能。它提供了丰富的工作流控制和监控功能，可以查看工作流的状态、日志和执行历史，并支持自定义的事件触发和通知机制。
目前Argo团队下中有如下几个子项目：
argoproj Common project repo for all Argo Projects gitops-engine Public Democratizing GitOps argo-workflows Workflow engine for Kubernetes argo-cd Declarative continuous deployment for Kubernetes. argo-events Event-driven automation framework argo-rollouts Progressive Delivery for Kubernetes cd和rollouts一个是持续交付工具，一个是渐进式发布工具。 workflows和events一个是基于容器的任务编排工具，一个是事件驱动框架。这两者搭配可以设计出一个由新建任务事件触发从而启动工作流的方案。
流程如下： ![[content/docs/programmer/base/argo_events_workfows.png]] sensor作用 # 使事件转发和处理松耦合 Trigger事件的参数化，比如根据事件内容动态生成 二、Argo Workflow编排示例 # 以下是一个扔硬币和打印结果的示例，借此可以熟悉一下Workflow的编排语法
apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: coinflip-recursive- spec: entrypoint: coinflip templates: - name: coinflip steps: - - name: flip-coin template: flip-coin - - name: heads template: heads when: &amp;#34;{{steps.</description></item><item><title/><link>http://example.org/docs/programmer/cloudnative/k8s/argo-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/k8s/argo-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</guid><description>Github: https://github.com/argoproj
一、简介 # 目前Argo项目中有如下几个子项目：
argoproj Common project repo for all Argo Projects
gitops-engine Public Democratizing GitOps
argo-workflows Workflow engine for Kubernetes
argo-cd Declarative continuous deployment for Kubernetes.
argo-events Event-driven automation framework
argo-rollouts Progressive Delivery for Kubernetes
cd和rollouts一个是持续交付工具，一个是渐进式发布工具，与原子能力关系不大。 workflows和events一个是基于容器的任务编排工具，一个是事件驱动框架。都与本次原子能力相关。
这样，就可以设计出一个由新建扫描任务事件触发，实例化经过编排可实现扫描全流程的方案。
流程如下：![[book_architecture/content/docs/programmer/base/argo_events_workfows.png]]
sensor作用 # 使事件转发和处理松耦合 Trigger事件的参数化，比如根据事件内容动态生成 二、Argo Workflow编排 # name: flip-coin script: image: python:alpine3.6 command: [python] source: | import random result = &amp;ldquo;heads&amp;rdquo; if random.randint(0,1) == 0 else &amp;ldquo;tails&amp;rdquo; print(result)
name: heads container: image: alpine:3.</description></item><item><title/><link>http://example.org/docs/programmer/cloudnative/middleware/kafka-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/middleware/kafka-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</guid><description>常用命令 # 创建topic # sh kafka-console-producer.sh --create --topic scanner_device_log --bootstrap-server localhost:9092 --partitions 0 --replication-factor 1 发送接收测试 # sh kafka-console-producer.sh --broker-list localhost:9092 --topic test sh kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test 单机部署 # 本文链接🔗 Kafka是一个开源的分布式消息引擎/消息中间件，同时Kafka也是一个流处理平台。Kakfa支持以发布/订阅的方式在应用间传递消息，同时并基于消息功能添加了Kafka Connect、Kafka Streams以支持连接其他系统的数据(Elasticsearch、Hadoop等) Kafka在生产环境下使用通常是集群化部署的，同时也要依赖ZooKeeper集群，这对开发测试环境来说比较重，不过我们可以通过Docker便捷Kafka单机的方式，节省部署时间以及机器资源
1、本文主要内容 # 通过Docker手动部署ZooKeeper&amp;amp;Kafka 通过Docker Compose快捷部署ZooKeeper&amp;amp;Kafka Kafka发送、接收消息测试 2、本文环境信息 # 工具 说明 适配 Docker Docker CE 23.0.5 Docker CE Docker Desktop 4.19.0 4.0.x ZooKeeper zookeeper:3.8（Docker Image ） zookeeper:3.x（Docker Image ） Kafka wurstmeister/kafka:2.13-2.8.1（Docker Image） wurstmeister/kafka:2.x（Docker Image） 二、手动部署Kafka # 1、拉取镜像 # 先通过docker pull 命令把镜像拉取下来，方便后续操作</description></item><item><title/><link>http://example.org/docs/programmer/cloudnative/sonar-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/sonar-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/</guid><description>平台地址 需要自建
在平台新建项目，新建token后可以自动生成扫描命令(拉代码, cd进去后在项目代码/路径下执行)：
sonar-scanner \ -Dsonar.projectKey=scancenter \ -Dsonar.sources=. \ -Dsonar.host.url=https://sonar-xa.inone.nsfocus.com \ -Dsonar.login=3e569f7abcfd8a64067d790f038c57a6a6b73207 如果使用的是他人的token，需要给授权。</description></item><item><title/><link>http://example.org/docs/programmer/hardware/raspberrypi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/hardware/raspberrypi/</guid><description>树莓派 # 详细文档 # 参考Cloud Atlas
很详细的罗列了树莓派各个版本的参数以及IO&amp;amp;其他参数的汇总，属于对官方文档的翻译以及补充，基于实践的补充，很有用。</description></item><item><title/><link>http://example.org/docs/programmer/hardware/screen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/hardware/screen/</guid><description>便携屏幕 # 某日入得4K便携屏幕一个, 甚是欢喜。无论手机、NS、PC用之皆爽.然NS 1080P 缩放至 4k 略糊，只可远观。
某日因压了个键盘和书，搬，屏幕裂，屏花之。方知平时屏幕擦灰时，稍加用力就会破碎感不是虚妄，而是确实。可见质量甚是不行，弃。</description></item><item><title/><link>http://example.org/docs/programmer/langs/python/paramiko-%E4%BD%BF%E7%94%A8-sshsftp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/paramiko-%E4%BD%BF%E7%94%A8-sshsftp/</guid><description>没啥好说的, 直接看代码:
import os import gzip import shutil import paramiko import multiprocessing from pathlib import Path from loguru import logger from config import globalconf class SSHConnection(object): def __init__(self, host=None, port=None, username=None, pwd=None, pk_path=None): &amp;#34;&amp;#34;&amp;#34; :param host: 服务器ip :param port: 接口 :param username: 登录名 :param pwd: 密码 &amp;#34;&amp;#34;&amp;#34; self.host = host self.port = port self.username = username self.pwd = pwd self.pk_path = pk_path def __enter__(self): self.connect() return self def __exit__(self, exc_type, exc_val, exc_tb): self.</description></item><item><title/><link>http://example.org/docs/programmer/os/npm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/os/npm/</guid><description>npm # 树莓派 # 官网下载 树莓派4b 选择ARMv8之前的树莓派型号选择ARMv7 配置PATH 向/usr/local/bin/下建立node软链 export PATH=&amp;#34;~/node-v16.14.0-linux-arm64/bin:$PATH&amp;#34; #sudo ln -s ~/node-v16.14.0-linux-arm64/bin/node /usr/bin/node Windows下wsl2 安装 npm &amp;amp;&amp;amp; nodejs # 摘抄自微软说明文档
安装nvm (Node 版本管理器) 国内网可能有问题, 下载下保存直接bash install.sh就可安装. curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash command -v nvm验证是否安装成功,它会自行添加.bashrc需重启bash nvm ls查看Node版本 nvm install --lts即可安装lts版, nvm install node安装最新版 会安装这么多东西 -&amp;gt; v16.13.2 default -&amp;gt; lts/* (-&amp;gt; v16.13.2) iojs -&amp;gt; N/A (default) unstable -&amp;gt; N/A (default) node -&amp;gt; stable (-&amp;gt; v16.13.2) (default) stable -&amp;gt; 16.</description></item><item><title/><link>http://example.org/excalidraw/hello-drawing-2024-04-25-16.45.19/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/excalidraw/hello-drawing-2024-04-25-16.45.19/</guid><description>==⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠==
Text Elements # %%
Drawing # { &amp;#34;type&amp;#34;: &amp;#34;excalidraw&amp;#34;, &amp;#34;version&amp;#34;: 2, &amp;#34;source&amp;#34;: &amp;#34;https://github.com/zsviczian/obsidian-excalidraw-plugin/releases/tag/2.1.8&amp;#34;, &amp;#34;elements&amp;#34;: [ { &amp;#34;type&amp;#34;: &amp;#34;freedraw&amp;#34;, &amp;#34;version&amp;#34;: 12, &amp;#34;versionNonce&amp;#34;: 1701366523, &amp;#34;index&amp;#34;: &amp;#34;a0&amp;#34;, &amp;#34;isDeleted&amp;#34;: false, &amp;#34;id&amp;#34;: &amp;#34;u1jPM8UifU2dBaIDVmGcI&amp;#34;, &amp;#34;fillStyle&amp;#34;: &amp;#34;solid&amp;#34;, &amp;#34;strokeWidth&amp;#34;: 2, &amp;#34;strokeStyle&amp;#34;: &amp;#34;solid&amp;#34;, &amp;#34;roughness&amp;#34;: 1, &amp;#34;opacity&amp;#34;: 100, &amp;#34;angle&amp;#34;: 0, &amp;#34;x&amp;#34;: -697.75, &amp;#34;y&amp;#34;: 691.984375, &amp;#34;strokeColor&amp;#34;: &amp;#34;#1e1e1e&amp;#34;, &amp;#34;backgroundColor&amp;#34;: &amp;#34;transparent&amp;#34;, &amp;#34;width&amp;#34;: 21, &amp;#34;height&amp;#34;: 27, &amp;#34;seed&amp;#34;: 1090511178, &amp;#34;groupIds&amp;#34;: [], &amp;#34;frameId&amp;#34;: null, &amp;#34;roundness&amp;#34;: null, &amp;#34;boundElements&amp;#34;: [], &amp;#34;updated&amp;#34;: 1715692214910, &amp;#34;link&amp;#34;: null, &amp;#34;locked&amp;#34;: false, &amp;#34;points&amp;#34;: [ [ 0, 0 ], [ 0, 0.</description></item><item><title/><link>http://example.org/posts/capital-incasion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/posts/capital-incasion/</guid><description>谈资本入侵 # 资本并非单指金钱，而是包含技术、资金、教育、媒体宣传、价值观念乃至社会架构以及运行体系的综合产物。
资本会流动，会向最有利可图的地方大规模聚集。而它的源头，就是资本过剩地方。
资本涌入当地，使用即已成型的技术建厂，从本源地转来过剩的产品。同时开动政治资本、话语资本(媒体)为招工、销售铺平道路。
它们其实无需在意开出的工资。于是给出极具诱惑的薪酬，并逐步渗入教育、最大化利用当地资源为自己下游产业生产线培养专科人才。
资源资本化 # 当人在一处聚集，有了可观的收入、暴富所产生的消费欲快速膨胀。无论是被动的还是主动的，快消品、奢饰品、追求感官刺激的体验消费，完全颠覆以往生活所形成的认知观念。而这些消费为资本带来第一轮的先期收割外，还将被话语媒体资本的助力下充斥到各处欠资本地区，吸纳更多的人前来。
而我们去了，首先要做对的就是接受管理。他们会告诉我们什么叫做“高效”，“先进”，诸如此类词汇，但无一例外的都是将管理成本向劳动者转嫁。
“进城打工潮”一旦形成，各地为了促进当地发展以及挽留劳动力，不得不实施“亲资本”的政策。从政策面鼓励，以低廉的方式划出工业用地。（由此，城市中土地政策宽松，乡村土地使用政策收紧。资本周边大面积征用农民土地、拆迁问题一定会出现。借贷和税收政策也一定会在两地之间形成差异）&amp;ndash;外来资本完成对当地人力资源、政府资源、土地资源的廉价征用，全部服务于本资本在“买全球、卖全球”的产品制造。
资源捆绑化 # 当资本输入地原住民分批得利消费理念逐步冷静&amp;ndash;当然这并非个体绝对。积蓄开始随时间累积，劳动密集型的产业带来的工伤密集冲击着劳动者身体素质。
时间跨度逐步拉长，原住民对于蓬勃发展的“城市”的长久繁荣的信心也在累积。医疗、教育和住房需求开始浮现。积蓄变得重要，理财也变得重要。
这将是资本的第二轮攻势。凭借“主场优势”，其更易于治疗其所带来的工伤。资本的培养体系也更容易为自己体系内部培养人力资本。借此优势将教育与医疗资源集中，边缘化输入地原有医疗和教育体系，形成越好更好，越差更差的趋向。几乎理所当然的大规模大比例占用社会资金，完成了人力资本培养，人力资本修复的代价向外转嫁，且代价也在为自己提供收益。
摘取果实 # 如果说创造就业是播下了种子，快消、奢侈、体验型消费满足了种子各种各样的幻想。医疗和教育的捆绑无时无刻在滋养着种子成长。那胜利的果实就是房地产和坚固的金融。
自古以来，累积积蓄、购置田产是繁荣社会中必然进行的活动。但在公有制下乡村之中，地是集体的，且在前已经说过：乡村中土地政策是必然收紧的。所以替代物它必须出现，在资本的操纵下，它必然出现在城市。两个一辈子在乡村务农的老农，其儿女生养在乡村，但成婚前必须在城中买房，为什么？
因为城中房自资本兴建的一开始，就绝不是以解决入城人住宿问题而产生的。它自一开始就裹挟着各项资源和特权。当“新增人口永不分地”写入法律，一面是先行者得利，一面是铜墙铁壁。大势所趋。
不是风险厌恶型的资本不是好资本 # 用自己的钱去建房，风险全是自己的&amp;ndash;这肯定不行；拉银行一起，“坏账”风险是银行的&amp;ndash;这稍微进步了一点；再把购房者拉上，先收一波回款&amp;ndash;风险到这儿基本分担完了；但收得是全款，花是慢慢花，那把闲的钱再去撬动更多资金呢？&amp;ndash;这简直绝佳。
银行也是好资本。“坏账”风险一定要转嫁出去&amp;ndash;包装成“金融产品”交由社会上的“闲钱”共力承担。
在这样的体系中，由资本一开始推动的巨轮滚滚向前。资本已经无需再投入，在社会承担所有风险的保证下，在社会的过往劳动（积蓄）、现实劳动、未来劳动（负债）中大口大口获取剩余。而这个社会终将走向无力消费，资本终将再无剩余可以榨取，它们必须奔向向另外一片沃土。而那个地方，在现在或许已经进化成无需是一个现实存在的地方。
逃不走的人怎么办 # 留下的人&amp;ndash;被抛弃的人只剩下两个选项：
想方设法无论如何也要寻求资本的认同，乞求带上他一起玩 承担资本流出后转嫁在自己身上的风险 第一个不讨论，有一个收编流程已经运行了数千年，可惜近代被废了。
那资本撤出一定会导致风险爆发吗？ # 这个问题不对，或者是说反了。在资本已经不限于压榨现有劳动剩余，对人力资源进行过往、未来尽数压榨的机制下，市场已经再无潜力和活力。资本已预料到会有风险爆发，所以才主动撤出，去寻求新的地方。否则新兴资本家必然会反制传统资本家，一如一开始它们涌入此地时所做的那样。当资本所带来的就业行业转入生产过剩，资本带来的核心技术转移或断供。而为资本中间环节培养、而非为当地社会培养人成为无用之才。早期既得利益者也无力完成产业升级，还要忙着第1条线路。
工人下岗，左脚踏右脚一飞冲天的最原始驱动力无力抵抗一环扣一环的风险所带来的阻力。</description></item><item><title>Demo Test项目中的一些东西</title><link>http://example.org/docs/programmer/ml/yolo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/ml/yolo/</guid><description>yolov5 # 使用自己的素材进行目标识别训练
之前使用个位数样本识别Vmon结果败的一塌糊涂 现在用来检测卡片倒是得心应手 9个训练卡片,准确率可以到50多,自我感觉还行 使用方法: 在此</description></item><item><title>Git</title><link>http://example.org/docs/programmer/os/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/os/git/</guid><description>Git # 同步远端放弃本地 # git fetch --all git reset --hard origin/master git pull Windows下问题 # [[Problem of Windows#Windows下Git问题]]</description></item><item><title>Python 多线程多进程</title><link>http://example.org/docs/programmer/langs/python/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</guid><description>一个协程示例： import asyncio async def my_coroutine(): # 这里是协程的代码 await asyncio.sleep(1) print(&amp;#34;Coroutine is done&amp;#34;) async def main(): # 创建一个任务对象 task = asyncio.create_task(my_coroutine()) # 等待任务完成 await task # 运行主协程 asyncio.run(main()) 一个线程示例： import threading # 定义一个函数，用于在线程中执行 def thread_function(name): print(f&amp;#34;Thread {name}: starting&amp;#34;) # 在这里执行一些操作 print(f&amp;#34;Thread {name}: finishing&amp;#34;) # 创建线程的实例 thread = threading.Thread(target=thread_function, args=(1,)) # 启动线程 thread.start() # 等待线程结束 thread.join() print(&amp;#34;Main thread is done&amp;#34;) 一个loop tip： self.loop = asyncio.get_event_loop() self.queue.set_loop(loop=self.loop) await self.af.set_loop(loop=self.loop) await self.adjust.set_loop(loop=self.loop) 为什么这里使用同一个loop ?</description></item><item><title>Python 常用库</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>pydantic # 来自类 # from pydantic import BaseModel class User(BaseModel): name: str age: int class Config: from_attributes = True # 假设我们有一个普通的 Python 对象，它具有与模型字段相同的属性名 class OrdinaryObject: def __init__(self, name, age): self.name = name self.age = age # 创建一个 OrdinaryObject 实例 ordinary_object = OrdinaryObject(name=&amp;#39;Alice&amp;#39;, age=30) # 现在我们可以直接将 ordinary_object 传递给 User 模型的构造函数 user_model = User(ordinary_object) # 输出模型的字段值 print(user_model.dict()) # 输出: {&amp;#39;name&amp;#39;: &amp;#39;Alice&amp;#39;, &amp;#39;age&amp;#39;: 30} 自定义字段 # class User(BaseModel): id: int is_active: bool wx_infos: List[str] = [] class Config: arbitrary_types_allowed = True # 允许任意类型 Tuple定义问题 # from typing import List, Tuple class Task(BaseModel): launch_count_today: int launch_groups: List[Tuple[str, .</description></item><item><title>Python 笔记</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>特殊函数调用 property # 使用字段的方式调用函数
from datetime import datetime from pydantic import BaseModel class InstallCountInfo(BaseModel): count: int total: int @property def done_rate(self): return round(self.count / self.total, 4) class InstallCount(BaseModel): pass_day: int install_day: datetime info: InstallCountInfo 彻底摆脱to_dict和from_dict # 使用 pydantic # BaseModel类型支持:
b = BattleAxiePositionInfo.parse_obj(DICT_DATA) b.json() b.dict() parse_file parse_raw from pydantic import BaseModel class PositionInfo(BaseModel): error: int = -1 # 收集错误 none: int = 0 # 还没开始 clicked: int = 1 # 在client 赋此值 done: int = 2 # 在server 赋此值 xy: List[int] = [0, 0] status: int = 0 # clicked or done or none or error class BattleAxiePositionInfo(BaseModel): our: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] enemy: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] pp = BattleAxiePositionInfo() print(f&amp;#34;pp json: {pp.</description></item><item><title>Py小工具和功能性方法</title><link>http://example.org/docs/programmer/langs/python/py%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/py%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7%E6%96%B9%E6%B3%95/</guid><description>author:Ian
邮件 # 发送邮件时携带附件 中文名称附件
def send_email_week_report(htm, recipients, copys, file_name, file_path): port = 465 # str_today = datetime.now().strftime(&amp;#34;%Y-%m-%d %H:%M:%S&amp;#34;) str_today = datetime.now().strftime(&amp;#34;%Y-%m-%d&amp;#34;) mail_host = &amp;#34;mail.{demo}.com&amp;#34; mail_user = &amp;#34;{user name}&amp;#34; mail_pass = &amp;#34;{passwd}&amp;#34; sender = &amp;#39;{name}@{demo}.com&amp;#39; mail_from = &amp;#34;{name} &amp;lt;{name}@{demo}.com&amp;gt;&amp;#34; msg_Bcc = &amp;#39;{name}@{demo}.com&amp;#39; subject = f&amp;#34;{title}-{str_today}&amp;#34; # 标题 msg = MIMEMultipart() msg.attach(MIMEText(htm, &amp;#39;html&amp;#39;, &amp;#39;utf-8&amp;#39;)) # 这里可以传html内容 也可以传普通文字 # 创建附件 with open(file_path, &amp;#39;rb&amp;#39;) as attachment: part = MIMEBase(&amp;#39;application&amp;#39;, &amp;#39;octet-stream&amp;#39;) part.set_payload(attachment.read()) encoders.encode_base64(part) part.add_header( &amp;#39;Content-Disposition&amp;#39;, &amp;#39;attachment&amp;#39;, filename=(&amp;#34;utf-8&amp;#34;, &amp;#34;&amp;#34;, file_name), ) msg.</description></item><item><title>supervisor</title><link>http://example.org/docs/programmer/basetc/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/</guid><description>supervisord # 安装 # pip install supervisor echo_supervisord_conf echo_supervisord_conf &amp;gt; /etc/supervisord.conf echo -e &amp;#34;[include]\nfiles = /etc/supervisor/conf.d/*.conf&amp;#34; &amp;gt;&amp;gt; /etc/supervisord.conf mkdir -p /var/log/test mkdir -p /etc/supervisor/conf.d/ echo -e &amp;#34;[program:test] command=/data/apps/test/.venv/bin/python test.py directory=/data/apps/test/src/ user=root autostart=true autorestart=true stopasgroup=true stderr_logfile=/var/log/test/test.err.log stderr_logfile_maxbytes=1000MB stderr_logfile_backups=10 stdout_logfile=/var/log/test/test.out.log stdout_logfile_maxbytes=1000MB stdout_logfile_backups=10&amp;#34; &amp;gt; /etc/supervisor/conf.d/test.conf supervisord supervisorctl update 问题 # supervisorctl status http://localhost:9001 refused connection 问题 # 首次安装, 只pip install后直接使用很可能是没有配置文件&amp;hellip; 写入配置后启动supervisord就好了 多安装问题 # 使用pip安装和apt安装的 supervisor 使用的不同路径的配置文件, 然后系统里就会跑两个supervisor, 就容易产生迷惑行为
systemd # 文件路径: /etc/systemd/system/{service_name}.service</description></item><item><title>Windows 爬坑记</title><link>http://example.org/docs/programmer/os/problem-of-windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/os/problem-of-windows/</guid><description> Windows下Git问题 # Linux没啥问题,但在Win下报checkout失败,路径问题 git config core.protectNTFS false</description></item><item><title>图形化界面 （Python Gui）</title><link>http://example.org/docs/programmer/gui/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/gui/notespython/</guid><description>author:Ian
Python GUI 💽 # pynput # 在 pynput 模块中，Win键被称为“特殊键”（Special keys），需要使用特殊的名称来表示。
以下是可以使用的特殊键名称列表：
https://pynput.readthedocs.io/en/latest/keyboard.html?highlight=%3Ccmd%3E#controlling-the-keyboard 因此，如果你想要在热键设置中使用 Win键+空格 这个热键，可以将它们分别替换为 cmd 和 space，如下所示：
from pynput import keyboard def on_activate(): print(&amp;#39;Hotkey activated&amp;#39;) def on_exit(): print(&amp;#39;Hotkey exited&amp;#39;) return False with keyboard.GlobalHotKeys({&amp;#39;&amp;lt;cmd&amp;gt;+&amp;lt;space&amp;gt;&amp;#39;: on_activate}) as h: h.join(on_exit)``` 在这个例子中，我们使用 &amp;lt;cmd&amp;gt;+&amp;lt;space&amp;gt; 来表示 Win键+空格 热键，因为在Mac中，Command键（cmd）可以起到类似于Win键的作用。 ## PyQt ![qt](https://tse4-mm.cn.bing.net/th/id/OIP.J4_Nqrcc0x7slHHUFwKLSQHaI6?pid=ImgDet&amp;amp;rs=1 &amp;#34;tmp&amp;#34;) 官方说明文档：&amp;lt;http://pyqt.sourceforge.net/Docs/PyQt4/index.html&amp;gt; 照例，先贴网址： &amp;lt;http://www.qaulau.com/books/PyQt4_Tutorial/index.html&amp;gt; ## 画界面 #PyQt4使用designer.exe import os for root, dirs, files in os.walk(&amp;#39;.&amp;#39;): for file in files: if file.endswith(&amp;#39;.ui&amp;#39;): os.system(&amp;#39;pyuic4 -o ui_%s.</description></item><item><title>愉快的Java(happy to learn the fuck java)</title><link>http://example.org/docs/programmer/langs/java/notesjava/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/java/notesjava/</guid><description>author: Ian
happy to learn the fuck java 😅 # &amp;lt;微人事&amp;gt; 笔记 -&amp;gt; ψ(._. )&amp;gt; # 先贴官方文档 哦 还有官方项目地址
Java语法 # 爪哇方法定义: # 修饰符 返回值类型 方法名(参数类型 参数名){ 方法体; return 返回值; } # 示个例 public boolean NiHou(int num){ int a = num; return turn; } // `boolean` 处 可为 public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities(){ List&amp;lt;GrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;(); return authorities; } // 表泛型中可以是的`GrantedAuthority`所有子类 爪哇抽象方法(即Python父类中直接pass的函数…) # abstract
包含抽象方法必须得是抽象类 任何子类必须重写父类抽象方法，或者声明自身为抽象类 public abstract class Employee { private String name; private int number; public abstract double computePay(); //其余 } 爪哇接口 # interface, implements</description></item><item><title>数据格式笔记</title><link>http://example.org/docs/programmer/langs/note-for-fmtdata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/note-for-fmtdata/</guid><description>算法图解 # 在线书: https://www.hello-algo.com
单向链表实现和反转 # # 单向链表实现和反转 &amp;#34;&amp;#34;&amp;#34; # 当前值, 下一个值 # 循环 # 将当前值赋值为下一个的值, 下一个节点值为当前节点值 # 当前节点next赋 &amp;#34;&amp;#34;&amp;#34; class A: def __init__(self, v): self.v = v self.next = None class LA: def __init__(self): self.head = None def add(self, v): node = A(v) node.next = self.head self.head = node def print(self): cur = self.head while cur and cur.v != None: print(f&amp;#34;linkdata node v: {cur.v}&amp;#34;) cur = cur.next def revert(self, node: A=None, head=None): if not head: cache = self.</description></item><item><title>机器学习库</title><link>http://example.org/docs/programmer/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid><description>Python 机器学习库 👽 # Plotly # 与matplotlib 都是绘图工具，不过效果炫一些，我也没画过，所以只放链接，不放实例了 Plotly Python Library : https://plot.ly/python/
matplotlib # import matplotlib.pyplot as plt 参数等太多，链接最可靠 # pyplot参数
还是粘一些常用的： marker 属性（下面写在分号里呦） o . v ^ &amp;lt; &amp;gt; 1 2 3 4 8 s p * h H + x D d | _ 之类
画出一些“花儿”
绘图 # plt.plot(x, y) # 在y之后可添加参数，例如常用的label = ‘IamLabel’之类 # 线的样式、颜色 ：b: blue g: green r: red c: cyan m: magenta y: yellow k: black w: white '-' : solid , '--' : dashed, '-.</description></item><item><title>解决问题</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>PiP Not Found Issue # 使用pip安装某包时， 提示让更新， 按提示操作更新没效果没反应再用就提示ModuleNotFoundError: No module named 'pip' (ˉ▽ˉ；)&amp;hellip;
ModuleNotFoundError: No module named &amp;lsquo;pip&amp;rsquo; # 升级PiP时出现问题可由下方命令修复 # python -m ensurepip python -m pip install --upgrade pip SSL校验 # 安装EasyOCR时, reader = easyocr.Reader(['ch_sim','en']) 下载到接近90,结果报错了&amp;hellip;. 估计是SSL问题加入以下两条,不知如何.
import ssl ssl._create_default_https_context = ssl._create_unverified_context from http.client To revert to the previous, unverified, behavior ssl._create_unverified_context() can be passed to the context parameter.
使用国内镜像下载Python # pip install --index https://pypi.mirrors.ustc.edu.cn/simple/ dlib(numpy等包名) # 一键更新pip 包资源(利用管道grep传输查询到的需要更新包名，传输到install命令) pip3 freeze --local | grep -v &amp;#39;^\-e&amp;#39; | cut -d = -f 1 | xargs -n1 pip3 install -U # 权限不够的话就在`pip3 install` 之前加`sudo`反正我不习惯用`root` 安装错误？ # 居然有pip3 install XX的错误…这也是因为有旧版pip3存留。需要</description></item><item><title>解决问题记录笔记</title><link>http://example.org/docs/programmer/os/tips-of-problems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/os/tips-of-problems/</guid><description>各种一键问题解决方案 # Windows下Git问题 # Linux没啥问题,但在Win下报checkout失败,路径问题 git config core.protectNTFS false docker - supervisord 禁用日志文件或使用 logfile=/dev/stdout # from: https://www.coder.work/article/100835 标签 docker supervisord
[supervisord] nodaemon=true logfile=/dev/stdout pidfile=/var/run/supervisord.pid childlogdir=/var/log/supervisor 当我这样做时，这个主管会崩溃，因为它无法在/dev/stdout 中寻找
如何禁用 supervisord 在我的 docker 容器中创建任何日志文件？
最佳答案
对于主主管，nodaemon 将导致日志转到 stdout
[supervisord] nodaemon=true logfile=/dev/null logfile_maxbytes=0 然后将每个托管进程的日志发送到标准输出文件描述符/dev/fd/1
[program:x] command=echo test stdout_logfile=/dev/fd/1 stdout_logfile_maxbytes=0 redirect_stderr=true 或者，如果您希望将 stderr 保留在不同的流上:
[program:x] command=echo test stdout_logfile=/dev/fd/1 stdout_logfile_maxbytes=0 stderr_logfile=/dev/fd/2 stderr_logfile_maxbytes=0 关于docker - supervisord 禁用日志文件或使用 logfile=/dev/stdout，我们在Stack Overflow上找到一个类似的问题： https://stackoverflow.com/questions/45645758/
docker中执行sed报Device or resource busy错误的处理原因及方式 转载 # kuSorZ 博主文章分类：Linux 文章标签: docker | sed 文章分类: Docker 原文出处： https://www.</description></item></channel></rss>