<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Ian's Blog</title><link>http://example.org/docs/programmer/langs/python/</link><description>Recent content in Python on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 28 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/docs/programmer/langs/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python编码规范</title><link>http://example.org/docs/programmer/langs/python/%E8%A7%84%E8%8C%83/</link><pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/%E8%A7%84%E8%8C%83/</guid><description> 函数返回值定义 # 多个返回值 - Tuple # async def function_name(package_name: str) -&amp;gt; Tuple[ParamsPushLvl2Pool, bool]: pass 支持传入多类型 - Union # ex: Union[ExpiryT, None] = None, 迭代 # def _yield_offer_info(_session, from_days_ago: int) -&amp;gt; Iterator[Offer]:</description></item><item><title>SqlAlchemy - 数据库Orm</title><link>http://example.org/docs/programmer/langs/python/sqlalchemy/</link><pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/sqlalchemy/</guid><description>Sqlalchemy异步操作不完全指北 # 不完全抄袭自: 米洛丶 - 博客园 cnblogs.com
异步SQLAlchemy # SQLAlchemy作为一款通用的Python Orm工具，在最近的版本也支持了异步操作。但网上很多资料都不是很齐全，API也不是很好查询的情况下，我便有了整理一份基础文档的想法。文章主要会以CRUD为入口，解决大家最基本的需求。
engine的区别 # 在普通的SQLAlchemy中，建立engine对象，我们会采用下面的方式:
from sqlalchemy import create_engine engine = create_engine(SQLALCHEMY_DATABASE_URI, pool_recycle=1500) 而异步的方式如下:
from sqlalchemy.ext.asyncio import create_async_engine async_engine = create_async_engine(ASYNC_SQLALCHEMY_URI, pool_recycle=1500) 链接参数 # from sqlalchemy.ext.asyncio import create_async_engine async_engine = create_async_engine( SQLALCHEMY_DATABASE_URL, pool_size=10, # 设置最大连接池大小 max_overflow=20, # 设置最大溢出连接数 pool_timeout=30, # 设置获取连接的超时时间（单位：秒） pool_recycle=1500, # 设置连接回收时间（单位：秒） echo=True # 设置为True以便于调试，显示SQL日志 ) session的区别 # 我们一般用sessionmaker来建立session，不过异步的有点区别:
from sqlalchemy.ext.asyncio import AsyncSession from sqlalchemy.orm import sessionmaker # 同步session Session = sessionmaker(engine) # 异步session 区别在于需要指定对应的class_ async_session = sessionmaker(async_engine, class_=AsyncSession) 建立会话 # 我们还是以代码的形式展示:</description></item><item><title>PyPi使用说明</title><link>http://example.org/docs/programmer/langs/python/pypi/</link><pubDate>Thu, 31 Mar 2022 15:15:14 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/pypi/</guid><description>Pypi包管理 # 示例项目 # py-muti-scrcpy
配置文件 # pyproject
工具介绍 # poetry
增加安装包 # 直接修改pyproject.toml文件并不能生效, 因为还依赖于poetry.lock
可使用poetry add {xxx}进行添加
注意事项 # 需要链接外网 # HTTPSConnectionPool(host=&amp;#39;files.pythonhosted.org&amp;#39;, port=443): Max retries exceeded with url: /packages/17/61/32c3ab8951142e061587d957226b5683d1387fb22d95b4f69186d92616d1/typing_extensions-4.0.0-py3-none-any.whl (Caused by ProxyError(&amp;#39;Cannot connect to proxy.&amp;#39;, ConnectionResetError(54, &amp;#39;Connection reset by peer&amp;#39;))) HTTPSConnectionPool(host=&amp;#39;pypi.org&amp;#39;, port=443): Max retries exceeded with url: /pypi/colorama/0.4.4/json (Caused by ProxyError(&amp;#39;Cannot connect to proxy.&amp;#39;, ConnectionResetError(54, &amp;#39;Connection reset by peer&amp;#39;))) 需要安装ssl # SSLError HTTPSConnectionPool(host=&amp;#39;pypi.org&amp;#39;, port=443): Max retries exceeded with url: /pypi/importlib-metadata/4.</description></item><item><title>PyTest</title><link>http://example.org/docs/programmer/langs/python/pytest/</link><pubDate>Mon, 10 May 2021 12:13:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/pytest/</guid><description>一、命令 # 常用参数 # 1. 忽略报警信息 # -p no:warnings 2. pdb调试 # ipdb有的版本可以有的不行
--pdb 3. 指定工作目录 # 有时候需要使用python -m pytest才生效, 直接pytest不生效 总之不如使用sys.path.insert
--rootdir /home/path/ 4. Django使用pytest测试 # pip install pytest-django pytest -s -vv .\tests\test_step2.py --rootdir X:\Code\workflows\ --ds project.settings rootdir 指定项目根目录 ds 指向django setting.py 文件 二、泛论 # 1、为什么需要pytest # helps you write better programs
提高阅读理解代码效率 提高debug效率 提高开发效率 保证交付代码质量 简单例子 # 入门例子:
了解使用test文件命名格式: test_前缀 了解断言assert 了解测试输出 # content of test_sample.py def inc(x): return x + 1 def test_answer(): assert inc(3) == 5 输出</description></item><item><title/><link>http://example.org/docs/programmer/langs/python/paramiko-%E4%BD%BF%E7%94%A8-sshsftp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/paramiko-%E4%BD%BF%E7%94%A8-sshsftp/</guid><description>基础用法-ssh 和 sftp文件传输 # import os import gzip import shutil import paramiko import multiprocessing from pathlib import Path from loguru import logger from config import globalconf class SSHConnection(object): def __init__(self, host=None, port=None, username=None, pwd=None, pk_path=None): &amp;#34;&amp;#34;&amp;#34; :param host: 服务器ip :param port: 接口 :param username: 登录名 :param pwd: 密码 &amp;#34;&amp;#34;&amp;#34; self.host = host self.port = port self.username = username self.pwd = pwd self.pk_path = pk_path def __enter__(self): self.connect() return self def __exit__(self, exc_type, exc_val, exc_tb): self.</description></item><item><title>FastAPI</title><link>http://example.org/docs/programmer/langs/python/fastapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/fastapi/</guid><description>FastAPI 使用笔记 # 上传文件 # pip install python-multipart from fastapi import FastAPI, UploadFile, File import pandas as pd from io import StringIO from pydantic import BaseModel app = FastAPI() # 定义响应模型 class RespAction(BaseModel): status: dict # 解析上传的文件 # 解析上传的文件 async def __parse_file(file: UploadFile): contents = await file.read() # 将字节内容转换为字符串 data = StringIO(contents.decode(&amp;#39;utf-8&amp;#39;)) # 根据文件类型选择解析方式 if file.filename.endswith(&amp;#39;.csv&amp;#39;): df = pd.read_csv(data) elif file.filename.endswith(&amp;#39;.txt&amp;#39;): df = pd.read_csv(data, delimiter=&amp;#39;\t&amp;#39;) # 假设 TXT 文件以制表符分隔 else: raise ValueError(&amp;#34;Unsupported file type.</description></item><item><title>Python 多线程多进程</title><link>http://example.org/docs/programmer/langs/python/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/</guid><description>一个协程示例： import asyncio async def my_coroutine(): # 这里是协程的代码 await asyncio.sleep(1) print(&amp;#34;Coroutine is done&amp;#34;) async def main(): # 创建一个任务对象 task = asyncio.create_task(my_coroutine()) # 等待任务完成 await task # 运行主协程 asyncio.run(main()) 一个线程示例： import threading # 定义一个函数，用于在线程中执行 def thread_function(name): print(f&amp;#34;Thread {name}: starting&amp;#34;) # 在这里执行一些操作 print(f&amp;#34;Thread {name}: finishing&amp;#34;) # 创建线程的实例 thread = threading.Thread(target=thread_function, args=(1,)) # 启动线程 thread.start() # 等待线程结束 thread.join() print(&amp;#34;Main thread is done&amp;#34;) 一个loop tip： self.loop = asyncio.get_event_loop() self.queue.set_loop(loop=self.loop) await self.af.set_loop(loop=self.loop) await self.adjust.set_loop(loop=self.loop) 为什么这里使用同一个loop ?</description></item><item><title>Python 常用库</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>pydantic # 来自类 # from pydantic import BaseModel class User(BaseModel): name: str age: int class Config: from_attributes = True # 假设我们有一个普通的 Python 对象，它具有与模型字段相同的属性名 class OrdinaryObject: def __init__(self, name, age): self.name = name self.age = age # 创建一个 OrdinaryObject 实例 ordinary_object = OrdinaryObject(name=&amp;#39;Alice&amp;#39;, age=30) # 现在我们可以直接将 ordinary_object 传递给 User 模型的构造函数 user_model = User(ordinary_object) # 输出模型的字段值 print(user_model.dict()) # 输出: {&amp;#39;name&amp;#39;: &amp;#39;Alice&amp;#39;, &amp;#39;age&amp;#39;: 30} 自定义字段 # class User(BaseModel): id: int is_active: bool wx_infos: List[str] = [] class Config: arbitrary_types_allowed = True # 允许任意类型 Tuple定义问题 # from typing import List, Tuple class Task(BaseModel): launch_count_today: int launch_groups: List[Tuple[str, .</description></item><item><title>Python 笔记</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>pip cache 目录 # echo $PIP_CACHE_DIR 特殊函数调用 property # 使用字段的方式调用函数
from datetime import datetime from pydantic import BaseModel class InstallCountInfo(BaseModel): count: int total: int @property def done_rate(self): return round(self.count / self.total, 4) class InstallCount(BaseModel): pass_day: int install_day: datetime info: InstallCountInfo 彻底摆脱to_dict和from_dict # 使用 pydantic # BaseModel类型支持:
b = BattleAxiePositionInfo.parse_obj(DICT_DATA) b.json() b.dict() parse_file parse_raw from pydantic import BaseModel class PositionInfo(BaseModel): error: int = -1 # 收集错误 none: int = 0 # 还没开始 clicked: int = 1 # 在client 赋此值 done: int = 2 # 在server 赋此值 xy: List[int] = [0, 0] status: int = 0 # clicked or done or none or error class BattleAxiePositionInfo(BaseModel): our: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] enemy: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] pp = BattleAxiePositionInfo() print(f&amp;#34;pp json: {pp.</description></item><item><title>Py小工具和功能性方法</title><link>http://example.org/docs/programmer/langs/python/py%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/py%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7%E6%96%B9%E6%B3%95/</guid><description>author:Ian
邮件 # 中文附件 # 发送邮件时携带附件 中文名称附件
def send_email_week_report(htm, recipients, copys, file_name, file_path): port = 465 # str_today = datetime.now().strftime(&amp;#34;%Y-%m-%d %H:%M:%S&amp;#34;) str_today = datetime.now().strftime(&amp;#34;%Y-%m-%d&amp;#34;) mail_host = &amp;#34;mail.{demo}.com&amp;#34; mail_user = &amp;#34;{user name}&amp;#34; mail_pass = &amp;#34;{passwd}&amp;#34; sender = &amp;#39;{name}@{demo}.com&amp;#39; mail_from = &amp;#34;{name} &amp;lt;{name}@{demo}.com&amp;gt;&amp;#34; msg_Bcc = &amp;#39;{name}@{demo}.com&amp;#39; subject = f&amp;#34;{title}-{str_today}&amp;#34; # 标题 msg = MIMEMultipart() msg.attach(MIMEText(htm, &amp;#39;html&amp;#39;, &amp;#39;utf-8&amp;#39;)) # 这里可以传html内容 也可以传普通文字 # 创建附件 with open(file_path, &amp;#39;rb&amp;#39;) as attachment: part = MIMEBase(&amp;#39;application&amp;#39;, &amp;#39;octet-stream&amp;#39;) part.set_payload(attachment.read()) encoders.</description></item><item><title>解决问题</title><link>http://example.org/docs/programmer/langs/python/notespython/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/python/notespython/</guid><description>PiP Not Found Issue # 使用pip安装某包时， 提示让更新， 按提示操作更新没效果没反应再用就提示ModuleNotFoundError: No module named 'pip' (ˉ▽ˉ；)&amp;hellip;
ModuleNotFoundError: No module named &amp;lsquo;pip&amp;rsquo; # 升级PiP时出现问题可由下方命令修复 # python -m ensurepip python -m pip install --upgrade pip SSL校验 # 安装EasyOCR时, reader = easyocr.Reader(['ch_sim','en']) 下载到接近90,结果报错了&amp;hellip;. 估计是SSL问题加入以下两条,不知如何.
import ssl ssl._create_default_https_context = ssl._create_unverified_context from http.client To revert to the previous, unverified, behavior ssl._create_unverified_context() can be passed to the context parameter.
使用国内镜像下载Python # pip install --index https://pypi.mirrors.ustc.edu.cn/simple/ dlib(numpy等包名) # 一键更新pip 包资源(利用管道grep传输查询到的需要更新包名，传输到install命令) pip3 freeze --local | grep -v &amp;#39;^\-e&amp;#39; | cut -d = -f 1 | xargs -n1 pip3 install -U # 权限不够的话就在`pip3 install` 之前加`sudo`反正我不习惯用`root` 安装错误？ # 居然有pip3 install XX的错误…这也是因为有旧版pip3存留。需要</description></item></channel></rss>