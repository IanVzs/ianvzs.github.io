<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ian&#39;s Blog</title>
    <link>http://example.org/docs/programmer/langs/</link>
    <description>Recent content on Ian&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 19 May 2021 19:00:00 +0000</lastBuildDate><atom:link href="http://example.org/docs/programmer/langs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang进阶笔记</title>
      <link>http://example.org/docs/programmer/langs/noteofgoexp/</link>
      <pubDate>Wed, 19 May 2021 19:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/programmer/langs/noteofgoexp/</guid>
      <description>Golang进阶笔记 # 路径问题 # test_test.go # package main import &amp;#34;testing&amp;#34; func TestHelloWorld(t *testing.T) { // t.Fatal(&amp;#34;not implemented&amp;#34;) path := getCurrentPath() t.Log(&amp;#34;getCurrentPath: &amp;#34;, path) } test.go # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;strings&amp;#34; ) func main() { fmt.Println(&amp;#34;getTmpDir（当前系统临时目录） = &amp;#34;, getTmpDir()) fmt.Println(&amp;#34;getCurrentAbPathByExecutable（仅支持go build） = &amp;#34;, getCurrentAbPathByExecutable()) fmt.Println(&amp;#34;getCurrentAbPathByCaller（仅支持go run） = &amp;#34;, getCurrentAbPathByCaller()) fmt.Println(&amp;#34;getCurrentAbPath（最终方案-全兼容） = &amp;#34;, getCurrentAbPath()) fmt.Println(&amp;#34;getCurrentPath（runtime.Caller1） = &amp;#34;, getCurrentPath()) } // 最终方案-全兼容 func getCurrentAbPath() string { dir := getCurrentAbPathByExecutable() if strings.</description>
    </item>
    
    <item>
      <title>Golang笔记</title>
      <link>http://example.org/docs/programmer/langs/noteofgolang/</link>
      <pubDate>Tue, 15 May 2018 10:18:26 +0000</pubDate>
      
      <guid>http://example.org/docs/programmer/langs/noteofgolang/</guid>
      <description>Golang笔记 # 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html
并发 Channel # 使用关键字go开启goroutine 轻量级线程
go fun_name(paras_list) # eg: go f(x, y, z) 代码
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func say(s string) { for i := 0; i &amp;lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;#34;world&amp;#34;) say(&amp;#34;hello&amp;#34;) } Channel # 用于传递数据的数据结构 可用于两个goroutine之间传递指定类型值，同步和通讯 &amp;lt;- 指定通道方向(发送or接受)，未指定则双向通道
声明通道 # 使用chan关键字, 在使用之前，需先创建.
ch := make(chan int) 示例
package main import &amp;#34;fmt&amp;#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c &amp;lt;- sum // 把 sum 发送到通道 c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &amp;lt;-c, &amp;lt;-c // 从通道 c 中接收 fmt.</description>
    </item>
    
    <item>
      <title>tips Of markdown</title>
      <link>http://example.org/docs/programmer/langs/tipsofmarkdown/</link>
      <pubDate>Tue, 15 May 2018 10:00:47 +0000</pubDate>
      
      <guid>http://example.org/docs/programmer/langs/tipsofmarkdown/</guid>
      <description>Markdown Notes 📪 # ##Test 二级标题
Now I will test the Markdown&amp;rsquo;s hobiy 二级 # Maybe is a nice way to impove my blog. 三级 # 原来标题 要# 与正文隔开一个空格… ···print “hello Markdown”··· 欸？ 怎么回事？上面的文字 莫非是用Tab能将其放到一个容器里？
新的区块 # 你好，这是我新创建的容器。 ———好吧，只有直接在标题之下的Tab才能创建 no~，在空行下面也是可以的。 address@example.com
Markdown 字体颜色、流程图 # 斜体 # *文字*：前后星号斜体 就像这样？
流程图 # st=&amp;gt;start: Start e=&amp;gt;end: End opl=&amp;gt;operation: My Operation sub1=&amp;gt;subroutine: My subroutine cond=&amp;gt;condition: Yes or No? io=&amp;gt;inputoutput: catch something
呃 流程图我不清楚，不过</description>
    </item>
    
    <item>
      <title>Python笔记(notes of Python)</title>
      <link>http://example.org/docs/programmer/langs/notespython/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/programmer/langs/notespython/</guid>
      <description>author:Ian
彻底摆脱to_dict和from_dict # 使用 pydantic # BaseModel类型支持:
b = BattleAxiePositionInfo.parse_obj(DICT_DATA) b.json() b.dict() parse_file parse_raw from pydantic import BaseModel class PositionInfo(BaseModel): error: int = -1 # 收集错误 none: int = 0 # 还没开始 clicked: int = 1 # 在client 赋此值 done: int = 2 # 在server 赋此值 xy: List[int] = [0, 0] status: int = 0 # clicked or done or none or error class BattleAxiePositionInfo(BaseModel): our: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] enemy: List[PositionInfo] = [PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo(), PositionInfo()] pp = BattleAxiePositionInfo() print(f&amp;#34;pp json: {pp.</description>
    </item>
    
    <item>
      <title>愉快的Java(happy to learn the fuck java)</title>
      <link>http://example.org/docs/programmer/langs/notesjava/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/docs/programmer/langs/notesjava/</guid>
      <description>author: Ian
happy to the fuck java 😅 # &amp;lt;微人事&amp;gt; 笔记 -&amp;gt; ψ(._. )&amp;gt; # 先贴官方文档 哦 还有官方项目地址
爪哇方法定义: # 修饰符 返回值类型 方法名(参数类型 参数名){ 方法体; return 返回值; } # 示个例 public boolean NiHou(int num){ int a = num; return turn; } // `boolean` 处 可为 public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities(){ List&amp;lt;GrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;(); return authorities; } // 表泛型中可以是的`GrantedAuthority`所有子类 爪哇抽象方法(即Python父类中直接pass的函数…) # abstract
包含抽象方法必须得是抽象类 任何子类必须重写父类抽象方法，或者声明自身为抽象类 public abstract class Employee { private String name; private int number; public abstract double computePay(); //其余 } 爪哇接口 # interface, implements</description>
    </item>
    
  </channel>
</rss>
