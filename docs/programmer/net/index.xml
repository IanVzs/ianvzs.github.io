<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ian's Blog</title><link>http://example.org/docs/programmer/net/</link><description>Recent content on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 19 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://example.org/docs/programmer/net/index.xml" rel="self" type="application/rss+xml"/><item><title>ngrok - 一个免费内网穿透api工具</title><link>http://example.org/docs/programmer/net/tools/ngrok/</link><pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/net/tools/ngrok/</guid><description>ngrok - 一个免费内网穿透api工具 # 官网: https://dashboard.ngrok.com/get-started/setup/linux
步骤说明 # 一共三步, 安装、配置、发布就是这么简单:
curl -s https://ngrok-agent.s3.amazonaws.com/ngrok.asc \ | sudo tee /etc/apt/trusted.gpg.d/ngrok.asc &amp;gt;/dev/null \ &amp;amp;&amp;amp; echo &amp;#34;deb https://ngrok-agent.s3.amazonaws.com buster main&amp;#34; \ | sudo tee /etc/apt/sources.list.d/ngrok.list \ &amp;amp;&amp;amp; sudo apt update \ &amp;amp;&amp;amp; sudo apt install ngrok ngrok config add-authtoken {authtoken} &amp;gt; Authtoken saved to configuration file: {home}/.config/ngrok/ngrok.yml # 发布应用 ngrok http http://localhost:8080 成功输出: # ngrok (Ctrl+C to quit) Try our new Traffic Inspector: https://ngrok.</description></item><item><title>mitmproxy</title><link>http://example.org/docs/programmer/net/crawler/mitmproxy/</link><pubDate>Thu, 18 Jul 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/net/crawler/mitmproxy/</guid><description> 安装 # 代码示例 # #!/bin/env python import asyncio import sys from mitmproxy import options from mitmproxy.tools import dump class RequestLogger: def request(self, flow): print(flow.request.url) def response(self, flow): print(f&amp;#34;rsp; {flow.response.headers}&amp;#34;) async def start_proxy(host, port): opts = options.Options(listen_host=host, listen_port=port) master = dump.DumpMaster( opts, with_termlog=False, with_dumper=False, ) master.addons.add(RequestLogger()) await master.run() return master if __name__ == &amp;#39;__main__&amp;#39;: host=sys.argv[1] port=int(sys.argv[2]) asyncio.run(start_proxy(host, port))</description></item><item><title>网络编程</title><link>http://example.org/docs/programmer/net/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Mon, 06 May 2024 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/net/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>网络分层图 # ![[net_layer.png]]
TCP是传输层的协议，而基于TCP造出来的HTTP和各类RPC协议，它们都只是定义了不同消息格式的应用层协议而已。 HTTP协议（Hyper Text Transfer Protocol），又叫做超文本传输协议。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是HTTP协议。 RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。虽然大部分RPC协议底层使用TCP，但实际上它们不一定非得使用TCP，改用UDP或者HTTP，其实也可以做到类似的功能。 RPC # vs HTTP # HTTP: ![[http.png]] RPC: ![[rpc.png]]
服务发现 [x] # 首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道IP地址和端口。这个找到服务对应的IP端口的过程，其实就是服务发现。
在HTTP中，你知道服务的域名，就可以通过DNS服务去解析得到它背后的IP地址，默认80端口。
而RPC的话，就有些区别，一般会有专门的中间服务去保存服务名和IP信息，比如consul或者etcd，甚至是redis。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如CoreDNS。
底层连接形式 [x] # 以主流的HTTP1.1协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（keep alive），之后的请求和响应都会复用这条连接。
而RPC协议，也跟HTTP类似，也是通过建立TCP长链接进行数据交互，但不同的地方在于，RPC协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。
由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给HTTP加个连接池，比如go就是这么干的。
可以看出这一块两者也没太大区别，所以也不是关键。
传输的内容 # 基于TCP传输的消息，说到底，无非都是消息头header和消息体body。
header是用于标记一些特殊信息，其中最重要的是消息体长度。
body则是放我们真正需要传输的内容，而这些内容只能是二进制01串，毕竟计算机只认识这玩意。所以TCP传字符串和数字都问题不大，因为字符串可以转成编码再变成01串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制01串，这样的方案现在也有很多现成的，比如json，protobuf。
这个将结构体转为二进制数组的过程就叫序列化，反过来将二进制数组复原成结构体的过程叫反序列化。 ![[tobytes.png]]
序列化和反序列化
对于主流的HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但HTTP设计初是用于做网页文本展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用json来序列化结构体数据。
我们可以随便截个图直观看下。 ![[tobetes_details.png]] HTTP报文
可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像header里的那些信息，其实如果我们约定好头部的第几位是content-type，就不需要每次都真的把&amp;quot;content-type&amp;quot;这个字段都传过来，类似的情况其实在body的json结构里也特别明显。
而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。
当然上面说的HTTP，其实特指的是现在主流使用的HTTP1.1，HTTP2在前者的基础上做了很多改进，所以性能可能比很多RPC协议还要好，甚至连gRPC底层都直接用的HTTP2。
结论 # 纯裸TCP是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义消息边界。于是就有了各种协议，HTTP和各类RPC协议就是在TCP之上定义的应用层协议。 RPC本质上不算是协议，而是一种调用方式，而像gRPC和thrift这样的具体实现，才是协议，它们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，不一定非得基于TCP协议。 从发展历史来说，**HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合。**很多软件同时支持多端，所以对外一般用HTTP协议，而内部集群的微服务之间则采用RPC协议进行通讯。 RPC其实比HTTP出现的要早，且比目前主流的HTTP1.1性能要更好，所以大部分公司内部都还在使用RPC。 HTTP2.0在HTTP1.1的基础上做了优化，性能可能比很多RPC协议都要好，但由于是这几年才出来的，所以也不太可能取代掉RPC。 TCP # 八股文常背，TCP是有三个特点，面向连接、可靠、基于字节流。
粘包问题 # 因为： ![[tcp_is_dataflow.png]] 所以： ![[nianbaowenti.png]] 无法区分上述两种情况。 得出： 纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些自定义的规则，用于区分消息边界。
于是我们会把每条要发送的数据都包装一下，比如加入消息头，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的消息体。</description></item><item><title>Nginx实用配置</title><link>http://example.org/docs/programmer/net/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 24 Sep 2023 23:01:41 +0000</pubDate><guid>http://example.org/docs/programmer/net/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/</guid><description>from: 这里
location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } location /test_vul_id_1000003 { alias /home/test_vul_id_1000003; autoindex on; } location /test_vul_id_1000003 { root /home; autoindex on; } 非以上配置访问404原因 # location /test_vul_id_1000003 { root /home/test_vul_id_1000003; autoindex on; } 如以上配置, nginx 配置文件会将 root 加上 以上的 localtion , 导致访问时实际定位是 /home/test_vul_id_1000003/test_vul_id_1000003 所以就 404 了
生效命令 # nginx -t nginx -s reload service nginx restart</description></item><item><title>gRpc使用小记</title><link>http://example.org/docs/programmer/net/tips-of-grpc/</link><pubDate>Mon, 24 May 2021 10:30:41 +0000</pubDate><guid>http://example.org/docs/programmer/net/tips-of-grpc/</guid><description>
gRpc HelloWorld # helloWorld # quickstart
protoc --go_out=. --go_opt=paths=source_relative \ --go-grpc_out=. --go-grpc_opt=paths=source_relative \ helloworld/helloworld.proto MacOS下问题 # 原本protobuf中没有mac的gen-go和gen-go-grpc,所以需要额外运行安装. 除了使用brew用go get应该也是可以的,就是有路径问题,所以还是使用brew吧 brew install protobuf brew install protoc-gen-go brew install protoc-gen-go-grpc</description></item><item><title>Epoll实现</title><link>http://example.org/docs/programmer/net/epoll%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 22 Apr 2021 15:15:14 +0000</pubDate><guid>http://example.org/docs/programmer/net/epoll%E5%AE%9E%E7%8E%B0/</guid><description>C++ &amp;amp; Epoll # 代码可见这里
也没啥高级就是:
create_socket epoll_create1 epoll_ctl(1. &amp;amp; 2.) struct epoll_event events[MAX_EPOLL_EVENTS] = {0}; while1: epoll_wait(2, &amp;amp; 4.) eventfd == sockfd accept else =&amp;gt; connfd read 所以就是:
epoll_event -&amp;gt; 内核空间 epitem -&amp;gt; 红黑 设备事件就绪 - callback (epitem -&amp;gt; rdlist链表) emmmm&amp;hellip;有需要再继续整理吧 和select-poll区别为: 一个遍历, 一个触发式的.</description></item></channel></rss>