<!doctype html><html lang=en-us dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="k8s学习 # 常用命令 # kubectl apply -f rcm_log_monut_k8s_pod.yaml kubectl get pod -A kubectl get pod -all-namespaces kubectl get node kubectl get deploy 持久卷 - PersistentVolume kubectl get persistentvolume kubectl describe persistentvolume example-pv kubectl **delete** persistentvolume example-pv 从kubectl cp -n <命名空间> -c :xxx.json xxx.json configmap / secret 存储文件内容 # sftpkey 为名称
新建 # kubectl create secret generic sftpkey --from-file=/etc/id_rsa # kubectl create -n {NAMESPACE} secret generic sftpkey --from-file=/etc/id_rsa 删除 # kubectl delete secret sftpkey"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="k8s学习-常用命令和配置文件"><meta property="og:description" content="k8s学习 # 常用命令 # kubectl apply -f rcm_log_monut_k8s_pod.yaml kubectl get pod -A kubectl get pod -all-namespaces kubectl get node kubectl get deploy 持久卷 - PersistentVolume kubectl get persistentvolume kubectl describe persistentvolume example-pv kubectl **delete** persistentvolume example-pv 从kubectl cp -n <命名空间> -c :xxx.json xxx.json configmap / secret 存储文件内容 # sftpkey 为名称
新建 # kubectl create secret generic sftpkey --from-file=/etc/id_rsa # kubectl create -n {NAMESPACE} secret generic sftpkey --from-file=/etc/id_rsa 删除 # kubectl delete secret sftpkey"><meta property="og:type" content="article"><meta property="og:url" content="http://example.org/docs/programmer/cloudnative/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2023-03-27T10:58:56+00:00"><meta property="article:modified_time" content="2023-03-27T10:58:56+00:00"><title>k8s学习-常用命令和配置文件 | Ian's Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.b1eea312146490caf43a9d10c82eb244ae60fc04078a856f5401b67fdd11034c.js integrity="sha256-se6jEhRkkMr0Op0QyC6yRK5g/AQHioVvVAG2f90RA0w=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Ian's Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li class=book-section-flat><a href=/docs/programmer/>程序员笔记</a><ul><li><input type=checkbox id=section-d5f99046a51e5e750b61f2e037945fcc class=toggle>
<label for=section-d5f99046a51e5e750b61f2e037945fcc class="flex justify-between"><a role=button>基础工具和配置</a></label><ul><li><a href=/docs/programmer/basetc/%E6%96%87%E6%9C%AC%E4%B8%89%E5%89%91%E5%AE%A2/>文本三剑客</a></li><li><a href=/docs/programmer/basetc/tmux/>Tmux使用笔记</a></li><li><a href=/docs/programmer/basetc/obsidian%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E6%8F%92%E4%BB%B6/>Obsidian思维导图插件</a></li><li><a href=/docs/programmer/basetc/for_china/>各个软件换源</a></li><li><a href=/docs/programmer/basetc/tipsofvim/>tip Of vim</a></li><li><a href=/docs/programmer/basetc/editer/>编辑器使用</a></li><li><a href=/docs/programmer/basetc/bash/>Bash</a></li><li><a href=/docs/programmer/basetc/gitbook/>Gitbook</a></li><li><a href=/docs/programmer/basetc/vim/>Vim</a></li><li><a href=/docs/programmer/basetc/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/>supervisor</a></li></ul></li><li><input type=checkbox id=section-8658298e10b544e890095f646916165a class=toggle checked>
<label for=section-8658298e10b544e890095f646916165a class="flex justify-between"><a href=/docs/programmer/cloudnative/>云原生</a></label><ul><li><input type=checkbox id=section-31d3b02fd4a132635e483e7e756058ea class=toggle>
<label for=section-31d3b02fd4a132635e483e7e756058ea class="flex justify-between"><a href=/docs/programmer/cloudnative/redis/>中间件</a></label><ul><li><a href=/docs/programmer/cloudnative/redis/python-redis-%E5%AE%A2%E6%88%B7%E7%AB%AF/>Python Redis 客户端</a></li><li><a href=/docs/programmer/cloudnative/redis/bigkey-and-hotkey/>大key、热key问题</a></li><li><a href=/docs/programmer/cloudnative/redis/the-basics-of-redis/>Redis基础</a></li><li><a href=/docs/programmer/cloudnative/redis/advanced-knowledge-of-redis/>Redis进阶</a></li><li><a href=/docs/programmer/cloudnative/redis/%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/>Redis常用命令</a></li></ul></li><li><input type=checkbox id=section-62d608ed890b3abc76dae78ccfcab912 class=toggle checked>
<label for=section-62d608ed890b3abc76dae78ccfcab912 class="flex justify-between"><a role=button>k8s</a></label><ul><li><a href=/docs/programmer/cloudnative/k8s/elk%E5%9C%A8k8s%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/>elk在k8s上的部署使用示例</a></li><li><a href=/docs/programmer/cloudnative/k8s/k8s-%E9%85%8D%E5%A5%97%E8%AF%B4%E6%98%8E/>k8s 配套说明</a></li><li><a href=/docs/programmer/cloudnative/k8s/k8s-%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/>k8s技术分享</a></li><li><a href=/docs/programmer/cloudnative/k8s/k8s%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/ class=active>k8s学习-常用命令和配置文件</a></li><li><a href=/docs/programmer/cloudnative/k8s/argo-workflow%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/>Argo Workflow性能测试和使用场景分析</a></li><li><a href=/docs/programmer/cloudnative/k8s/argo-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/>Argo 使用记录</a></li></ul></li><li><input type=checkbox id=section-b828bf3d116bc282da9db25a06bf908e class=toggle>
<label for=section-b828bf3d116bc282da9db25a06bf908e class="flex justify-between"><a role=button>中间件</a></label><ul><li><a href=/docs/programmer/cloudnative/middleware/kafka-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/>Kafka 安装和使用</a></li></ul></li><li><a href=/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-podman/>Podman</a></li><li><a href=/docs/programmer/cloudnative/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/>Nginx实用配置</a></li><li><a href=/docs/programmer/cloudnative/uwsgi-%E5%A4%84%E7%90%86%E8%AE%B0%E5%BD%95/>uwsgi 处理记录</a></li><li><a href=/docs/programmer/cloudnative/note-of-docker/>Docker</a></li><li><a href=/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-docker/>Docker</a></li><li><a href=/docs/programmer/cloudnative/fastapi/>Django的建站的(｡･･)ﾉﾞ</a></li><li><a href=/docs/programmer/cloudnative/nginx-%E9%AB%98%E5%8F%AF%E7%94%A8/>Nginx高可用</a></li><li><a href=/docs/programmer/cloudnative/notesdjango/>Django的建站的(｡･･)ﾉﾞ</a></li><li><a href=/docs/programmer/cloudnative/sonar-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/>Sonar 代码静态检查</a></li></ul></li><li><input type=checkbox id=section-883e27361d38e16afb68faff3435ac0b class=toggle>
<label for=section-883e27361d38e16afb68faff3435ac0b class="flex justify-between"><a role=button>机器学习</a></label><ul><li><a href=/docs/programmer/ml/stable-diffusion/>AI画图</a></li><li><a href=/docs/programmer/ml/%E7%88%AC%E8%99%AB/>爬虫</a></li><li><a href=/docs/programmer/ml/paddle/>Paddle</a></li><li><a href=/docs/programmer/ml/tensorflow/>Tensorflow</a></li><li><a href=/docs/programmer/ml/opencv/>OpenCV</a></li><li><a href=/docs/programmer/ml/yolo/>Demo Test项目中的一些东西</a></li><li><a href=/docs/programmer/ml/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E5%BA%93%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/>机器学习库</a></li></ul></li><li><input type=checkbox id=section-0bf4f4329214e20fa67ca3e12c6aad0c class=toggle>
<label for=section-0bf4f4329214e20fa67ca3e12c6aad0c class="flex justify-between"><a role=button>平台</a></label><ul><li><a href=/docs/programmer/platforms/ubuntu/>Ubuntu</a></li><li><a href=/docs/programmer/platforms/%E9%98%BF%E9%87%8C%E4%BA%91%E4%BD%BF%E7%94%A8/>阿里云使用</a></li><li><a href=/docs/programmer/platforms/wps-for-linux/>WPS for Linux</a></li><li><a href=/docs/programmer/platforms/appsflyer/>AppsFlyer-外网移动归因营销分析平台</a></li></ul></li><li><input type=checkbox id=section-bf4e0d6f0b81f7b3ec08ed1fc66b874d class=toggle>
<label for=section-bf4e0d6f0b81f7b3ec08ed1fc66b874d class="flex justify-between"><a href=/docs/programmer/langs/>编程语言</a></label><ul><li><input type=checkbox id=section-771df6c720301e69f1715f7fc174ac3d class=toggle>
<label for=section-771df6c720301e69f1715f7fc174ac3d class="flex justify-between"><a role=button>Python</a></label><ul><li><a href=/docs/programmer/langs/python/sqlalchemy/>SqlAlchemy - 数据库Orm</a></li><li><a href=/docs/programmer/langs/python/pypi/>PyPi使用说明</a></li><li><a href=/docs/programmer/langs/python/pytest/>PyTest</a></li><li><a href=/docs/programmer/langs/python/paramiko-%E4%BD%BF%E7%94%A8-sshsftp/>Paramiko 使用 Ssh&amp;sftp</a></li><li><a href=/docs/programmer/langs/python/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%A4%9A%E8%BF%9B%E7%A8%8B/>Python 多线程多进程</a></li><li><a href=/docs/programmer/langs/python/notespython/>Python 常用库</a></li><li><a href=/docs/programmer/langs/python/notespython/>Python 笔记</a></li><li><a href=/docs/programmer/langs/python/py%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%92%8C%E5%8A%9F%E8%83%BD%E6%80%A7%E6%96%B9%E6%B3%95/>Py小工具和功能性方法</a></li><li><a href=/docs/programmer/langs/python/notespython/>解决问题</a></li></ul></li><li><input type=checkbox id=section-9f8ac8f06e138c7ac13ff61f23b4d497 class=toggle>
<label for=section-9f8ac8f06e138c7ac13ff61f23b4d497 class="flex justify-between"><a role=button>Golang</a></label><ul><li><a href=/docs/programmer/langs/golang/advanced-knowledge-of-golang/>Golang进阶笔记</a></li><li><a href=/docs/programmer/langs/golang/noteofgoexp/>Golang进阶笔记</a></li><li><a href=/docs/programmer/langs/golang/note-of-golang/>Golang笔记</a></li><li><a href=/docs/programmer/langs/golang/noteofgolang/>Golang笔记</a></li></ul></li><li><a href=/docs/programmer/langs/cmake/>CMake 使用Tips</a></li><li><a href=/docs/programmer/langs/tips-of-debugers/>Tips of debuggers</a></li><li><a href=/docs/programmer/langs/tips-of-markdown/>Tips of MarkDown</a></li><li><a href=/docs/programmer/langs/java/notesjava/>愉快的Java(happy to learn the fuck java)</a></li><li><a href=/docs/programmer/langs/note-for-fmtdata/>数据格式笔记</a></li></ul></li><li><input type=checkbox id=section-de7bfad1d124522974cdf8addfbb23f2 class=toggle>
<label for=section-de7bfad1d124522974cdf8addfbb23f2 class="flex justify-between"><a role=button>Net</a></label><ul><li><a href=/docs/programmer/net/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/>网络编程</a></li><li><a href=/docs/programmer/net/nginx%E5%AE%9E%E7%94%A8%E9%85%8D%E7%BD%AE/>Nginx实用配置</a></li><li><a href=/docs/programmer/net/tips-of-grpc/>gRpc使用小记</a></li><li><a href=/docs/programmer/net/epoll%E5%AE%9E%E7%8E%B0/>Epoll实现</a></li></ul></li><li><input type=checkbox id=section-7e5360c5e7954906b897ed79085884b6 class=toggle>
<label for=section-7e5360c5e7954906b897ed79085884b6 class="flex justify-between"><a href=/docs/programmer/gui/>图形用户界面-GUI</a></label><ul><li><a href=/docs/programmer/gui/pyinstaller-python%E6%89%93%E5%8C%85/>python打包</a></li><li><a href=/docs/programmer/gui/qt/>Qt/PySide</a></li><li><a href=/docs/programmer/gui/vn.py%E7%AC%94%E8%AE%B0-%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/>Vn.Py学习笔记（Python交易平台框架）</a></li><li><a href=/docs/programmer/gui/notespython/>图形化界面 （Python Gui）</a></li></ul></li><li><input type=checkbox id=section-ddcbe632dc99a9fb372422dada8ee641 class=toggle>
<label for=section-ddcbe632dc99a9fb372422dada8ee641 class="flex justify-between"><a role=button>OS操作系统问题处理</a></label><ul><li><a href=/docs/programmer/os/install_some/>安装问题</a></li><li><a href=/docs/programmer/os/android/>安卓</a></li><li><a href=/docs/programmer/os/freebsd/>FreeBSD</a></li><li><a href=/docs/programmer/os/note-of-linux/>Linux 笔记</a></li><li><a href=/docs/programmer/os/npm/>Npm</a></li><li><a href=/docs/programmer/os/git/>Git</a></li><li><a href=/docs/programmer/os/problem-of-windows/>Windows 爬坑记</a></li><li><a href=/docs/programmer/os/tips-of-problems/>解决问题记录笔记</a></li></ul></li><li><input type=checkbox id=section-4446dd07527142b855f26d7cc8f0e617 class=toggle>
<label for=section-4446dd07527142b855f26d7cc8f0e617 class="flex justify-between"><a href=/docs/programmer/database/>Database</a></label><ul><li><a href=/docs/programmer/database/dgraph-graph-db/>Dgraph使用小记</a></li><li><a href=/docs/programmer/database/note-of-db-data-mongodb/>数据库-MongoDB篇</a></li><li><a href=/docs/programmer/database/note-of-db-data-mysql/>数据库-MySQL篇</a></li></ul></li><li><input type=checkbox id=section-d325c59fc6513e1b1e05a60b192d4973 class=toggle>
<label for=section-d325c59fc6513e1b1e05a60b192d4973 class="flex justify-between"><a href=/docs/programmer/hardware/>硬件</a></label><ul><li><a href=/docs/programmer/hardware/raspberrypi/>Raspberry Pi</a></li><li><a href=/docs/programmer/hardware/screen/>Screen</a></li></ul></li></ul></li><li class=book-section-flat><span>建模和游戏</span><ul><li><a href=/docs/3dgame/blender/>Blender</a></li><li><a href=/docs/3dgame/noteofue4/>UE4 笔记</a></li></ul></li><li class=book-section-flat><a href=/docs/example/>Hugo特殊Markdown语法说明</a><ul><li><a href=/docs/example/table-of-contents/>Table of Contents</a><ul><li><a href=/docs/example/table-of-contents/with-toc/>With ToC</a></li><li><a href=/docs/example/table-of-contents/without-toc/>Without ToC</a></li></ul></li><li><a href=/docs/example/shortcodes/buttons/>Buttons</a></li><li><a href=/docs/example/shortcodes/columns/>Columns</a></li><li><a href=/docs/example/shortcodes/details/>Details</a></li><li><a href=/docs/example/shortcodes/expand/>Expand</a></li><li><a href=/docs/example/shortcodes/hints/>Hints</a></li><li><a href=/docs/example/shortcodes/tabs/>Tabs</a></li></ul></li></ul><ul><li><a href=/posts/>Blog</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>k8s学习-常用命令和配置文件</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#常用命令>常用命令</a></li><li><a href=#configmap--secret-存储文件内容>configmap / secret 存储文件内容</a><ul><li><a href=#新建>新建</a></li><li><a href=#删除>删除</a></li></ul></li><li><a href=#常用字段>常用字段</a></li><li><a href=#其他>其他</a><ul><li><a href=#annotations>annotations</a></li><li><a href=#ownerreferences-字段>ownerReferences 字段</a></li><li><a href=#ownerreferences-中的name和该pod-name相同有什么作用>ownerReferences 中的name和该pod name相同有什么作用？</a></li><li><a href=#env-环境变量>env 环境变量</a></li><li><a href=#initcontainers>initContainers</a></li><li><a href=#一些杂项>一些杂项</a></li></ul></li><li><a href=#a-name持久卷持久卷---persistentvolumea>持久卷 - PersistentVolume</a></li><li><a href=#知识问答>知识问答</a><ul><li><a href=#1-nodeselector-和-nodeselectorterms-有什么区别>1. nodeSelector 和 nodeSelectorTerms 有什么区别？</a></li></ul></li><li><a href=#常用命令-1>常用命令</a></li><li><a href=#常用字段-1>常用字段</a></li><li><a href=#其他-1>其他</a><ul><li><a href=#annotations-1>annotations</a></li><li><a href=#ownerreferences-字段-1>ownerReferences 字段</a></li><li><a href=#ownerreferences-中的name和该pod-name相同有什么作用-1>ownerReferences 中的name和该pod name相同有什么作用？</a></li><li><a href=#env-环境变量-1>env 环境变量</a></li><li><a href=#initcontainers-1>initContainers</a></li><li><a href=#一些杂项-1>一些杂项</a></li></ul></li><li><a href=#持久卷---persistentvolume>持久卷 - PersistentVolume</a></li></ul><ul><li><ul><li><a href=#k8s-路由解析>k8s 路由解析</a></li><li><a href=#配置一个rabbitmq给大家用>配置一个rabbitmq给大家用</a></li></ul></li><li><a href=#ingress>ingress</a><ul><li><a href=#配置>配置</a></li></ul></li><li><a href=#环境变量在k8s>环境变量在k8s</a></li><li><a href=#configmap>ConfigMap</a></li></ul><ul><li><a href=#docker-限制内存cpu占用>Docker 限制内存/CPU占用</a></li></ul><ul><li><a href=#docker-cmd-和-k8s-command>Docker CMD 和 K8s Command</a></li></ul></nav></aside></header><article class=markdown><p><img src=https://d33wubrfki0l68.cloudfront.net/69e55f968a6f44613384615c6a78b881bfe28bd6/1600c/zh-cn/_common-resources/images/flower.svg alt=k8s></p><h1 id=k8s学习>k8s学习
<a class=anchor href=#k8s%e5%ad%a6%e4%b9%a0>#</a></h1><h2 id=常用命令>常用命令
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4>#</a></h2><ul><li>kubectl apply -f rcm_log_monut_k8s_pod.yaml</li><li>kubectl get pod -A</li><li>kubectl get pod -all-namespaces</li><li>kubectl get node</li><li>kubectl get deploy</li><li><a href=#%e6%8c%81%e4%b9%85%e5%8d%b7>持久卷 - PersistentVolume</a><ul><li>kubectl get persistentvolume</li><li>kubectl describe persistentvolume example-pv</li><li><code>kubectl **delete** persistentvolume example-pv</code></li></ul></li><li>从kubectl cp -n &lt;命名空间> -c :xxx.json xxx.json</li></ul><h2 id=configmap--secret-存储文件内容>configmap / secret 存储文件内容
<a class=anchor href=#configmap--secret-%e5%ad%98%e5%82%a8%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9>#</a></h2><p><code>sftpkey</code> 为名称</p><h3 id=新建>新建
<a class=anchor href=#%e6%96%b0%e5%bb%ba>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create secret generic sftpkey --from-file<span style=color:#f92672>=</span>/etc/id_rsa
</span></span><span style=display:flex><span><span style=color:#75715e># kubectl create -n {NAMESPACE} secret generic sftpkey --from-file=/etc/id_rsa</span>
</span></span></code></pre></div><h3 id=删除>删除
<a class=anchor href=#%e5%88%a0%e9%99%a4>#</a></h3><p>kubectl delete secret sftpkey</p><h2 id=常用字段>常用字段
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e5%ad%97%e6%ae%b5>#</a></h2><p>下面是一些 Kubernetes 中常用的配置字段：</p><pre tabindex=0><code>apiVersion： Kubernetes API 的版本，用于定义资源的 API 版本号。
kind： 资源的类型，比如 Pod、Deployment、Service 等。
metadata： 元数据字段，用于存储 Kubernetes 对象的名称、命名空间、标签等信息。
spec： 对象的规格，用于定义对象的期望状态，如 Pod 的容器、Service 的端口等。
status： 对象的状态，用于记录对象的实际状态，如 Pod 的运行状态、Service 的访问地址等。
</code></pre><p>另外还有一些常用的子字段，如：</p><pre tabindex=0><code>containers： Pod 中的容器定义，包括容器名称、镜像、命令、参数等。
ports： Service 中的端口定义，包括端口名称、协议、端口号、目标端口号等。
selector： Service 中用于选择后端 Pod 的标签选择器。
replicas： Deployment 中期望的副本数。
template： Deployment 中用于创建 Pod 的 PodTemplateSpec 定义。
</code></pre><h2 id=其他>其他
<a class=anchor href=#%e5%85%b6%e4%bb%96>#</a></h2><p>在 Kubernetes 中，annotations 字段是资源对象中的一个元数据字段，用于存储一些非标准化的元数据信息。与 metadata 字段中的标准化信息不同，annotations 字段中存储的信息往往是自定义的、不易归类的数据，比如代码库的提交 ID、配置文件的 MD5 校验值、外部系统的关联信息等等。</p><h3 id=annotations>annotations
<a class=anchor href=#annotations>#</a></h3><p>字段的格式为一个 key-value 对的列表，其中 key 表示注解的名称，value 表示注解的值。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>commit-id</span>: <span style=color:#ae81ff>abc123</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>	- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span></code></pre></div><p>在这个示例中，我们在 Pod 的 metadata 中添加了一个自定义注解 commit-id，并将其值设置为 abc123。这个注解表示当前 Pod 对应的代码库的提交 ID。</p><p>需要注意的是，由于 annotations 字段是用于存储自定义元数据信息的，因此在使用时需要注意避免与其他标准化的字段发生冲突，以免产生意外的后果。同时，由于注解的值可以是任意字符串，因此需要对注解的内容进行适当的验证和转义，以避免安全风险</p><h3 id=ownerreferences-字段>ownerReferences 字段
<a class=anchor href=#ownerreferences-%e5%ad%97%e6%ae%b5>#</a></h3><p>在 Kubernetes 中，ownerReferences 字段是资源对象中的一个元数据字段，用于指定当前对象的所有者（owner）。这个字段可以用来建立资源对象之间的父子关系，便于管理和垃圾回收。在一个资源对象中，可以同时指定多个父对象（owner）。</p><p>ownerReferences 字段的格式为一个包含多个 ownerReference 对象的列表。每个 ownerReference 对象表示一个父对象的引用，其中包含了父对象的 API 版本、资源类型、名称和 UID。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ownerReferences</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-deployment</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>uid</span>: <span style=color:#ae81ff>abc123</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ReplicaSet</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-replicaset</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>uid</span>: <span style=color:#ae81ff>def456</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>这段 YAML 文件描述了一个名为 my-pod 的 Pod 对象，它有两个父对象，分别是一个 Deployment 和一个 ReplicaSet。其中，Deployment 的名称为 my-deployment，UID 为 abc123，ReplicaSet 的名称为 my-replicaset，UID 为 def456。</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>该 Pod 中只包含一个容器，名称为 my-container，使用镜像为 my-image。</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>需要注意的是，这个 Pod 对象的 ownerReferences 字段表示它是 Deployment 和 ReplicaSet 的子对象，当这两个父对象被删除时，该 Pod 对象也会被自动删除。另外，这个 Pod 对象和其父对象都属于同一个命名空间，因为没有在 metadata 中指定 namespace 字段</span>
</span></span></code></pre></div><p>在这个示例中，我们在 Pod 的 metadata 中添加了两个父对象，分别是一个 Deployment 和一个 ReplicaSet。这些信息可以帮助 Kubernetes 更好地管理这些对象之间的依赖关系，便于进行垃圾回收和版本控制。</p><p>需要注意的是，ownerReferences 字段中的对象必须是同一个命名空间中的资源对象，否则会引发错误。另外，在使用 ownerReferences 字段时需要注意避免循环引用的问题，以免产生意外的后果。</p><h3 id=ownerreferences-中的name和该pod-name相同有什么作用>ownerReferences 中的name和该pod name相同有什么作用？
<a class=anchor href=#ownerreferences-%e4%b8%ad%e7%9a%84name%e5%92%8c%e8%af%a5pod-name%e7%9b%b8%e5%90%8c%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8>#</a></h3><p>在 Kubernetes 中，如果一个资源对象的 ownerReferences 中的 name 字段与当前对象的 metadata 中的 name 字段相同，表示当前对象是父对象（owner）自己创建的。这种情况下，父对象的控制器不会对这个对象进行垃圾回收，因为这个对象本身就是父对象的一部分。</p><p>例如，在一个 Deployment 中创建了一个 Pod，并且将 Pod 的 ownerReferences 中的 name 字段设置为 Pod 的名称。这样一来，当 Deployment 被删除时，由于 Pod 依赖于 Deployment，Kubernetes 会先删除 Deployment，然后再删除 Pod。在删除 Pod 时，由于 Pod 的 ownerReferences 中的 name 字段与 Pod 的 metadata 中的 name 字段相同，所以控制器不会对 Pod 进行垃圾回收，而是保留下来作为 Deployment 的一部分。</p><p>通过这种方式，我们可以在 Kubernetes 中建立资源对象之间更加复杂的关系，实现更高级别的控制和管理。例如，可以通过设置 ownerReferences 字段来建立 Deployment 和 Service 的关系，从而实现负载均衡和服务发现。</p><h3 id=env-环境变量>env 环境变量
<a class=anchor href=#env-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>POD_IP_ADDRESS</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>status.podIP</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>POD_OWN_NAME</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>metadata.name</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>POD_OWN_NAMESPACE</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>metadata.namespace</span>
</span></span></code></pre></div><p>这段 YAML 文件描述了一个 Pod 中的三个环境变量。这些环境变量的值是从 Kubernetes 中获取的，而不是直接在 Pod 中指定的。</p><p>其中，POD_IP_ADDRESS 环境变量的值使用了 valueFrom 字段，并指定了一个 fieldRef，用于从当前 Pod 的状态中获取 podIP 字段的值。POD_IP_ADDRESS 环境变量的值就是当前 Pod 的 IP 地址。</p><p>POD_OWN_NAME 和 POD_OWN_NAMESPACE 环境变量的值也使用了 valueFrom 字段，并指定了一个 fieldRef，用于从当前 Pod 的元数据中获取 name 和 namespace 字段的值。POD_OWN_NAME 环境变量的值就是当前 Pod 的名称，POD_OWN_NAMESPACE 环境变量的值就是当前 Pod 所属的命名空间。</p><p>这种方式可以让我们在定义 Pod 时，动态地获取 Pod 自身的元数据和状态信息，并将这些信息作为环境变量传递给 Pod 中的容器。在容器中，我们可以通过读取这些环境变量的值，来获取当前 Pod 的一些重要信息</p><h3 id=initcontainers>initContainers
<a class=anchor href=#initcontainers>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>dnsPolicy</span>: <span style=color:#ae81ff>ClusterFirst</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>enableServiceLinks</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>initContainers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>sh</span>
</span></span><span style=display:flex><span>    - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>until nc -zvw3 hello-redis-svc.hello-prod.svc.cluster.local 6379; do echo Waiting</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>hello-redis; sleep 5; done;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>xxxx.docker.io/hello-docker/busybox:1.28.1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>IfNotPresent</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>init-redis</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>: {}
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePath</span>: <span style=color:#ae81ff>/dev/termination-log</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePolicy</span>: <span style=color:#ae81ff>File</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/run/secrets/kubernetes.io/serviceaccount</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kube-api-access-pp4tg</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>sh</span>
</span></span><span style=display:flex><span>    - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>until nc -zvw3 hello-mongodb-svc.hello.svc.cluster.local 27017; do echo Waiting</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>hello-mongodb; sleep 5; done;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>xxxx.docker.io/hello-docker/busybox:1.28.1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>IfNotPresent</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>init-mongodb</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>: {}
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePath</span>: <span style=color:#ae81ff>/dev/termination-log</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePolicy</span>: <span style=color:#ae81ff>File</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/run/secrets/kubernetes.io/serviceaccount</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kube-api-access-pp4tg</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><ul><li>这段 YAML 配置是关于 Kubernetes 中的初始化容器（initContainers）的。</li><li>初始化容器是在 Pod 中所有容器启动之前运行的容器，用于预处理或准备容器的某些方面。</li><li>在这个 YAML 配置中，定义了两个初始化容器 <code>init-redis</code> 和 <code>init-mongodb</code>，分别检查 hello-redis 和 hello-mongodb 是否准备就绪。具体地，这两个初始化容器在容器内运行了一个 until 循环，每 5 秒尝试连接 hello-redis 或 hello-mongodb 服务，并打印 Waiting hello-redis 或 Waiting hello-mongodb 的日志信息。如果连接成功，则退出循环，容器初始化成功。初始化容器的镜像是 <code>xxxx.docker.io/hello-docker/busybox:1.28.1</code>，使用 IfNotPresent 策略拉取镜像。其中 <code>resources</code> 字段定义了该容器的资源限制和请求，<code>volumeMounts</code> 字段定义了将哪些存储卷挂载到该容器的哪些路径。</li></ul><h3 id=一些杂项>一些杂项
<a class=anchor href=#%e4%b8%80%e4%ba%9b%e6%9d%82%e9%a1%b9>#</a></h3><ul><li>nodeName: Pod所要调度的节点名称。</li><li>nodeSelector: 用于指定Pod所需的标签，使Pod只能被具有特定标签的节点调度。</li><li>preemptionPolicy: Pod优先级抢占策略。如果当前节点资源不足，可以抢占优先级低的Pod来为优先级高的Pod腾出资源。PreemptLowerPriority表示低优先级的Pod可以被抢占。</li><li>priority: Pod的优先级，数值越高表示优先级越高。</li><li>restartPolicy: Pod的重启策略，可以是Always、OnFailure或Never。Always表示Pod一旦终止就会自动重启，OnFailure表示只有在非0退出码时才会重启，Never表示不会自动重启。</li><li>schedulerName: 指定Pod使用的调度器。</li><li>securityContext: Pod的安全上下文。</li><li>serviceAccount: 默认使用的服务账户。</li><li>serviceAccountName: 指定使用的服务账户名称。</li><li>terminationGracePeriodSeconds: Pod终止的优雅期，即Pod终止时等待多长时间后强制终止。默认为30秒</li><li>其余一些状态信息 <code>status</code> : <code>podIPs</code> <code>phase: Running</code> <code>phase</code> <code>initContainerStatuses</code> <code>containerStatuses</code> <code>containerStatuses</code> <code>conditions</code></li></ul><h2 id=a-name持久卷持久卷---persistentvolumea>持久卷 - PersistentVolume
<a class=anchor href=#a-name%e6%8c%81%e4%b9%85%e5%8d%b7%e6%8c%81%e4%b9%85%e5%8d%b7---persistentvolumea>#</a></h2><p>需要注意的是，<code>PersistentVolume</code>
是一个集群级别的资源，不属于任何一个命名空间，但可以通过在 <code>metadata</code>
字段中指定 <code>namespace</code>
字段来将其关联到某个命名空间中。这个关联只是用来方便查找和管理资源，不会对 <code>PersistentVolume</code>
对象本身产生影响。</p><h2 id=知识问答>知识问答
<a class=anchor href=#%e7%9f%a5%e8%af%86%e9%97%ae%e7%ad%94>#</a></h2><h3 id=1-nodeselector-和-nodeselectorterms-有什么区别>1. nodeSelector 和 nodeSelectorTerms 有什么区别？
<a class=anchor href=#1-nodeselector-%e5%92%8c-nodeselectorterms-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab>#</a></h3><blockquote><p>ChatGPT:</p></blockquote><ul><li>在 Kubernetes 中，nodeSelector 和 nodeSelectorTerms 都是用来选择哪些节点可以运行 Pod 的。</li><li>nodeSelector 是 PodSpec 中的一个字段，它用于指定一个键值对，只有运行在具有指定标签的节点上的 Pod 才会被调度到该节点上。例如：</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>nodeSelector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>kubernetes.io/hostname</span>: <span style=color:#ae81ff>node-1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span></code></pre></div><p>在上面的示例中，nodeSelector 字段指定了 Pod 只能调度到具有标签 kubernetes.io/hostname=node-1 的节点上。
而 nodeSelectorTerms 是一个更高级别的机制，它允许在一个 Pod 中指定多个选择条件。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>nodeSelector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchExpressions</span>:
</span></span><span style=display:flex><span>      - {<span style=color:#f92672>key: zone, operator: In, values</span>: [<span style=color:#ae81ff>east, west]}</span>
</span></span><span style=display:flex><span>      - {<span style=color:#f92672>key: region, operator: NotIn, values</span>: [<span style=color:#ae81ff>us-east-1]}</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>environment</span>: <span style=color:#ae81ff>production</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span></code></pre></div><p>在上面的示例中，nodeSelector 字段指定了多个选择条件。其中 matchExpressions 指定了两个表达式，一个是 zone 标签的值必须是 east 或 west，另一个是 region 标签的值不能是 us-east-1。而 matchLabels 指定了 environment 标签的值必须是 production。</p><p>因此，nodeSelector 只能指定一个选择条件，而 nodeSelectorTerms 可以指定多个选择条件。\</p><h2 id=常用命令-1>常用命令
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-1>#</a></h2><ul><li>kubectl apply -f rcm_log_monut_k8s_pod.yaml</li><li><a href="https://www.notion.so/PersistentVolume-2db6a82d152c4f0ba3659d4bfb27b883?pvs=21">持久卷 - PersistentVolume</a><ul><li>kubectl get persistentvolume</li><li>kubectl describe persistentvolume example-pv</li><li><code>kubectl **delete** persistentvolume example-pv</code></li></ul></li></ul><h2 id=常用字段-1>常用字段
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e5%ad%97%e6%ae%b5-1>#</a></h2><p>下面是一些 Kubernetes 中常用的配置字段：</p><pre tabindex=0><code>apiVersion： Kubernetes API 的版本，用于定义资源的 API 版本号。
kind： 资源的类型，比如 Pod、Deployment、Service 等。
metadata： 元数据字段，用于存储 Kubernetes 对象的名称、命名空间、标签等信息。
spec： 对象的规格，用于定义对象的期望状态，如 Pod 的容器、Service 的端口等。
status： 对象的状态，用于记录对象的实际状态，如 Pod 的运行状态、Service 的访问地址等。
</code></pre><p>另外还有一些常用的子字段，如：</p><pre tabindex=0><code>containers： Pod 中的容器定义，包括容器名称、镜像、命令、参数等。
ports： Service 中的端口定义，包括端口名称、协议、端口号、目标端口号等。
selector： Service 中用于选择后端 Pod 的标签选择器。
replicas： Deployment 中期望的副本数。
template： Deployment 中用于创建 Pod 的 PodTemplateSpec 定义。
</code></pre><h2 id=其他-1>其他
<a class=anchor href=#%e5%85%b6%e4%bb%96-1>#</a></h2><p>在 Kubernetes 中，annotations 字段是资源对象中的一个元数据字段，用于存储一些非标准化的元数据信息。与 metadata 字段中的标准化信息不同，annotations 字段中存储的信息往往是自定义的、不易归类的数据，比如代码库的提交 ID、配置文件的 MD5 校验值、外部系统的关联信息等等。</p><h3 id=annotations-1>annotations
<a class=anchor href=#annotations-1>#</a></h3><p>字段的格式为一个 key-value 对的列表，其中 key 表示注解的名称，value 表示注解的值。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span>	<span style=color:#f92672>annotations</span>:
</span></span><span style=display:flex><span>		<span style=color:#f92672>commit-id</span>: <span style=color:#ae81ff>abc123</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>	<span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>	- <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>		<span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span></code></pre></div><p>在这个示例中，我们在 Pod 的 metadata 中添加了一个自定义注解 commit-id，并将其值设置为 abc123。这个注解表示当前 Pod 对应的代码库的提交 ID。</p><p>需要注意的是，由于 annotations 字段是用于存储自定义元数据信息的，因此在使用时需要注意避免与其他标准化的字段发生冲突，以免产生意外的后果。同时，由于注解的值可以是任意字符串，因此需要对注解的内容进行适当的验证和转义，以避免安全风险</p><h3 id=ownerreferences-字段-1>ownerReferences 字段
<a class=anchor href=#ownerreferences-%e5%ad%97%e6%ae%b5-1>#</a></h3><p>在 Kubernetes 中，ownerReferences 字段是资源对象中的一个元数据字段，用于指定当前对象的所有者（owner）。这个字段可以用来建立资源对象之间的父子关系，便于管理和垃圾回收。在一个资源对象中，可以同时指定多个父对象（owner）。</p><p>ownerReferences 字段的格式为一个包含多个 ownerReference 对象的列表。每个 ownerReference 对象表示一个父对象的引用，其中包含了父对象的 API 版本、资源类型、名称和 UID。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-pod</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ownerReferences</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-deployment</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>uid</span>: <span style=color:#ae81ff>abc123</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kind</span>: <span style=color:#ae81ff>ReplicaSet</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-replicaset</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>uid</span>: <span style=color:#ae81ff>def456</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>my-container</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>my-image</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>这段 YAML 文件描述了一个名为 my-pod 的 Pod 对象，它有两个父对象，分别是一个 Deployment 和一个 ReplicaSet。其中，Deployment 的名称为 my-deployment，UID 为 abc123，ReplicaSet 的名称为 my-replicaset，UID 为 def456。</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>该 Pod 中只包含一个容器，名称为 my-container，使用镜像为 my-image。</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>需要注意的是，这个 Pod 对象的 ownerReferences 字段表示它是 Deployment 和 ReplicaSet 的子对象，当这两个父对象被删除时，该 Pod 对象也会被自动删除。另外，这个 Pod 对象和其父对象都属于同一个命名空间，因为没有在 metadata 中指定 namespace 字段</span>
</span></span></code></pre></div><p>在这个示例中，我们在 Pod 的 metadata 中添加了两个父对象，分别是一个 Deployment 和一个 ReplicaSet。这些信息可以帮助 Kubernetes 更好地管理这些对象之间的依赖关系，便于进行垃圾回收和版本控制。</p><p>需要注意的是，ownerReferences 字段中的对象必须是同一个命名空间中的资源对象，否则会引发错误。另外，在使用 ownerReferences 字段时需要注意避免循环引用的问题，以免产生意外的后果。</p><h3 id=ownerreferences-中的name和该pod-name相同有什么作用-1>ownerReferences 中的name和该pod name相同有什么作用？
<a class=anchor href=#ownerreferences-%e4%b8%ad%e7%9a%84name%e5%92%8c%e8%af%a5pod-name%e7%9b%b8%e5%90%8c%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8-1>#</a></h3><p>在 Kubernetes 中，如果一个资源对象的 ownerReferences 中的 name 字段与当前对象的 metadata 中的 name 字段相同，表示当前对象是父对象（owner）自己创建的。这种情况下，父对象的控制器不会对这个对象进行垃圾回收，因为这个对象本身就是父对象的一部分。</p><p>例如，在一个 Deployment 中创建了一个 Pod，并且将 Pod 的 ownerReferences 中的 name 字段设置为 Pod 的名称。这样一来，当 Deployment 被删除时，由于 Pod 依赖于 Deployment，Kubernetes 会先删除 Deployment，然后再删除 Pod。在删除 Pod 时，由于 Pod 的 ownerReferences 中的 name 字段与 Pod 的 metadata 中的 name 字段相同，所以控制器不会对 Pod 进行垃圾回收，而是保留下来作为 Deployment 的一部分。</p><p>通过这种方式，我们可以在 Kubernetes 中建立资源对象之间更加复杂的关系，实现更高级别的控制和管理。例如，可以通过设置 ownerReferences 字段来建立 Deployment 和 Service 的关系，从而实现负载均衡和服务发现。</p><h3 id=env-环境变量-1>env 环境变量
<a class=anchor href=#env-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>env</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>POD_IP_ADDRESS</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>status.podIP</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>POD_OWN_NAME</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>metadata.name</span>
</span></span><span style=display:flex><span>    - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>POD_OWN_NAMESPACE</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>valueFrom</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>fieldRef</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span>          <span style=color:#f92672>fieldPath</span>: <span style=color:#ae81ff>metadata.namespace</span>
</span></span></code></pre></div><p>这段 YAML 文件描述了一个 Pod 中的三个环境变量。这些环境变量的值是从 Kubernetes 中获取的，而不是直接在 Pod 中指定的。</p><p>其中，POD_IP_ADDRESS 环境变量的值使用了 valueFrom 字段，并指定了一个 fieldRef，用于从当前 Pod 的状态中获取 podIP 字段的值。POD_IP_ADDRESS 环境变量的值就是当前 Pod 的 IP 地址。</p><p>POD_OWN_NAME 和 POD_OWN_NAMESPACE 环境变量的值也使用了 valueFrom 字段，并指定了一个 fieldRef，用于从当前 Pod 的元数据中获取 name 和 namespace 字段的值。POD_OWN_NAME 环境变量的值就是当前 Pod 的名称，POD_OWN_NAMESPACE 环境变量的值就是当前 Pod 所属的命名空间。</p><p>这种方式可以让我们在定义 Pod 时，动态地获取 Pod 自身的元数据和状态信息，并将这些信息作为环境变量传递给 Pod 中的容器。在容器中，我们可以通过读取这些环境变量的值，来获取当前 Pod 的一些重要信息</p><h3 id=initcontainers-1>initContainers
<a class=anchor href=#initcontainers-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>dnsPolicy</span>: <span style=color:#ae81ff>ClusterFirst</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>enableServiceLinks</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>initContainers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>sh</span>
</span></span><span style=display:flex><span>    - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>until nc -zvw3 bsa-redis-svc.bsa-prod.svc.cluster.local 6379; do echo Waiting</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>BSA-redis; sleep 5; done;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>repos-wh.inone.nsfocus.com/bsa-3rd-docker/busybox:1.28.1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>IfNotPresent</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>init-redis</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>: {}
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePath</span>: <span style=color:#ae81ff>/dev/termination-log</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePolicy</span>: <span style=color:#ae81ff>File</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/run/secrets/kubernetes.io/serviceaccount</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kube-api-access-pp4tg</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>  - <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>sh</span>
</span></span><span style=display:flex><span>    - -<span style=color:#ae81ff>c</span>
</span></span><span style=display:flex><span>    - <span style=color:#ae81ff>until nc -zvw3 bsa-mongodb-svc.bsa-paas.svc.cluster.local 27017; do echo Waiting</span>
</span></span><span style=display:flex><span>      <span style=color:#ae81ff>BSA-mongodb; sleep 5; done;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>repos-wh.inone.nsfocus.com/bsa-3rd-docker/busybox:1.28.1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>imagePullPolicy</span>: <span style=color:#ae81ff>IfNotPresent</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>init-mongodb</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>resources</span>: {}
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePath</span>: <span style=color:#ae81ff>/dev/termination-log</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>terminationMessagePolicy</span>: <span style=color:#ae81ff>File</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>volumeMounts</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>mountPath</span>: <span style=color:#ae81ff>/var/run/secrets/kubernetes.io/serviceaccount</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>kube-api-access-pp4tg</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>readOnly</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><ul><li>这段 YAML 配置是关于 Kubernetes 中的初始化容器（initContainers）的。</li><li>初始化容器是在 Pod 中所有容器启动之前运行的容器，用于预处理或准备容器的某些方面。</li><li>在这个 YAML 配置中，定义了两个初始化容器 <code>init-redis</code> 和 <code>init-mongodb</code>，分别检查 BSA-redis 和 BSA-mongodb 是否准备就绪。具体地，这两个初始化容器在容器内运行了一个 until 循环，每 5 秒尝试连接 BSA-redis 或 BSA-mongodb 服务，并打印 Waiting BSA-redis 或 Waiting BSA-mongodb 的日志信息。如果连接成功，则退出循环，容器初始化成功。初始化容器的镜像是 <code>repos-wh.inone.nsfocus.com/bsa-3rd-docker/busybox:1.28.1</code>，使用 IfNotPresent 策略拉取镜像。其中 <code>resources</code> 字段定义了该容器的资源限制和请求，<code>volumeMounts</code> 字段定义了将哪些存储卷挂载到该容器的哪些路径。</li></ul><p><a href="https://www.notion.so/71d149949ede4a86a3aa954c7569aa34?pvs=21">scancenter - init项目</a></p><h3 id=一些杂项-1>一些杂项
<a class=anchor href=#%e4%b8%80%e4%ba%9b%e6%9d%82%e9%a1%b9-1>#</a></h3><ul><li>nodeName: Pod所要调度的节点名称。</li><li>nodeSelector: 用于指定Pod所需的标签，使Pod只能被具有特定标签的节点调度。</li><li>preemptionPolicy: Pod优先级抢占策略。如果当前节点资源不足，可以抢占优先级低的Pod来为优先级高的Pod腾出资源。PreemptLowerPriority表示低优先级的Pod可以被抢占。</li><li>priority: Pod的优先级，数值越高表示优先级越高。</li><li>restartPolicy: Pod的重启策略，可以是Always、OnFailure或Never。Always表示Pod一旦终止就会自动重启，OnFailure表示只有在非0退出码时才会重启，Never表示不会自动重启。</li><li>schedulerName: 指定Pod使用的调度器。</li><li>securityContext: Pod的安全上下文。</li><li>serviceAccount: 默认使用的服务账户。</li><li>serviceAccountName: 指定使用的服务账户名称。</li><li>terminationGracePeriodSeconds: Pod终止的优雅期，即Pod终止时等待多长时间后强制终止。默认为30秒</li><li>其余一些状态信息 <code>status</code> : <code>podIPs</code> <code>phase: Running</code> <code>phase</code> <code>initContainerStatuses</code> <code>containerStatuses</code> <code>containerStatuses</code> <code>conditions</code></li></ul><h2 id=持久卷---persistentvolume>持久卷 - PersistentVolume
<a class=anchor href=#%e6%8c%81%e4%b9%85%e5%8d%b7---persistentvolume>#</a></h2><p>需要注意的是，<code>PersistentVolume</code>  是一个集群级别的资源，不属于任何一个命名空间，但可以通过在 <code>metadata</code>  字段中指定 <code>namespace</code>  字段来将其关联到某个命名空间中。这个关联只是用来方便查找和管理资源，不会对 <code>PersistentVolume</code>  对象本身产生影响。</p><h1 id=service>service
<a class=anchor href=#service>#</a></h1><h3 id=k8s-路由解析>k8s 路由解析
<a class=anchor href=#k8s-%e8%b7%af%e7%94%b1%e8%a7%a3%e6%9e%90>#</a></h3><p>&ldquo;host&rdquo;: &ldquo;choi-wan-rabbitmq.nscloud.svc.cluster.local&rdquo; 解释这段k8s配置</p><p>4/24/2023, 5:36:06 PM</p><p>这段 Kubernetes（k8s）配置中的 &ldquo;host&rdquo;: &ldquo;choi-wan-rabbitmq.nscloud.svc.cluster.local&rdquo; 是一个应用程序连接到 RabbitMQ 消息代理服务的主机地址。具体来说，它是一个 Kubernetes 集群内部的服务地址，该服务被命名为 choi-wan-rabbitmq，并位于 nscloud 命名空间的 svc（Service）资源中。</p><p>如果应用程序需要连接到 <a href=http://scan.rabbitmq.ros.nsfocus.com/>scan.rabbitmq.ros.nsfocus.com</a> 上运行的 RabbitMQ 服务，则需要在 Kubernetes 中创建一个外部服务或使用 Kubernetes 的 DNS 解析功能将该主机名映射到 RabbitMQ 服务的 IP 地址。</p><p>4/24/2023, 5:54:22 PM</p><p>svc.cluster.local 分别代表什么？</p><p>4/24/2023, 5:54:40 PM</p><p>在 Kubernetes 中，svc.cluster.local 是一个特殊的域名后缀，用于将服务名称解析为集群内部的 IP 地址。具体来说，svc 代表 Kubernetes 中的 Service 资源类型，cluster.local 是 Kubernetes 集群的默认域名后缀。因此，当应用程序需要连接到 Kubernetes 集群中的服务时，可以使用该服务的名称作为主机名，并在末尾添加 svc.cluster.local 后缀来获得服务的 IP 地址。例如，在上述例子中，choi-wan-rabbitmq.nscloud.svc.cluster.local 是 choi-wan-rabbitmq 服务的完整域名，它将被解析为 RabbitMQ 消息代理服务的 IP 地址，从而使应用程序能够与该服务进行通信。</p><h3 id=配置一个rabbitmq给大家用>配置一个rabbitmq给大家用
<a class=anchor href=#%e9%85%8d%e7%bd%ae%e4%b8%80%e4%b8%aarabbitmq%e7%bb%99%e5%a4%a7%e5%ae%b6%e7%94%a8>#</a></h3><p>在k8s 新建一个公共rabbitmq供所有pod使用应该如何操作？</p><p>4/24/2023, 5:34:27 PM</p><p>在 Kubernetes 中创建一个共享的 RabbitMQ 服务供所有 Pod 使用，需要以下步骤：</p><ol><li>创建 RabbitMQ 镜像：可以使用 Dockerfile 或者从 Docker Hub 下载现成的 RabbitMQ 镜像。</li><li>配置 RabbitMQ：修改 RabbitMQ 的配置文件，包括默认用户名和密码、端口号、虚拟主机等。</li><li>创建 Kubernetes Service：使用 Kubernetes 的 Service 资源类型来创建一个 RabbitMQ 服务，这个服务会为 RabbitMQ 提供一个稳定的 IP 地址和端口。可以选择 ClusterIP、LoadBalancer 或者 NodePort 类型的服务。</li><li>创建 Kubernetes Deployment：创建一个 RabbitMQ 的 Deployment 资源，用于实例化 RabbitMQ 的容器，并且将这个资源归属到刚才创建的 Service 上，确保所有的 Pod 都可以访问到 RabbitMQ 服务。</li><li>验证 RabbitMQ 是否可用：使用 Kubernetes Dashboard 或者 kubectl 命令行工具，连接到 RabbitMQ 服务进行验证，确保它能够正常工作。</li><li>在其他的 Kubernetes Pod 中使用 RabbitMQ：在其他的 Pod 中安装 RabbitMQ 客户端，并使用 Service 的 IP 和端口访问 RabbitMQ 服务，实现 Pod 之间的消息传递。</li></ol><p>总体来说，创建共享的 RabbitMQ 服务需要在 Kubernetes 中创建一个带有自动伸缩功能的 Deployment，并将它绑定到一个稳定的 Service 上，然后在其他的 Pod 中使用 RabbitMQ 客户端来连接该服务。</p><p>4/24/2023, 5:34:49 PM</p><p>请提供一下上述所需的示例yaml文件内容</p><p>4/24/2023, 5:35:52 PM</p><p>以下是创建共享的 RabbitMQ 服务所需的示例 YAML 文件内容：</p><ol><li>RabbitMQ 镜像的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: Pod
metadata:
  name: rabbitmq-pod
spec:
  containers:
  - name: rabbitmq
    image: rabbitmq
    ports:
    - containerPort: 5672
      name: amqp
    - containerPort: 15672
      name: http
</code></pre><p>注意，这里使用的是 Docker Hub 上的默认 RabbitMQ 镜像，也可以根据需要自定义 Dockerfile 来构建。</p><ol><li>RabbitMQ 配置文件的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: ConfigMap
metadata:
  name: rabbitmq-config
data:
  rabbitmq.conf: |
    loopback_users.guest = false
    listeners.tcp.default = 5672
    management.listener.port = 15672
  enabled_plugins: |
    [rabbitmq_management].
</code></pre><p>这里使用 ConfigMap 来存储 RabbitMQ 的配置信息。配置文件中禁用了默认用户 guest，开启了 TCP 监听端口和管理界面端口，并且启用了 RabbitMQ 管理插件。</p><ol><li>RabbitMQ Service 的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: Service
metadata:
  name: rabbitmq-service
spec:
  selector:
    app: rabbitmq
  ports:
  - name: amqp
    port: 5672
    targetPort: amqp
  - name: http
    port: 15672
    targetPort: http
  type: ClusterIP
</code></pre><p>这里创建的是 ClusterIP 类型的 Service，它会为 RabbitMQ 提供一个稳定的 IP 地址和端口。</p><ol><li>RabbitMQ Deployment 的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rabbitmq-deployment
spec:
  selector:
    matchLabels:
      app: rabbitmq
  replicas: 1
  template:
    metadata:
      labels:
        app: rabbitmq
    spec:
      volumes:
      - name: rabbitmq-config-volume
        configMap:
          name: rabbitmq-config
      containers:
      - name: rabbitmq
        image: rabbitmq
        ports:
        - containerPort: 5672
          name: amqp
        - containerPort: 15672
          name: http
        volumeMounts:
        - name: rabbitmq-config-volume
          mountPath: /etc/rabbitmq/
</code></pre><p>这里创建了一个带有自动伸缩功能的 Deployment，并将其绑定到刚才创建的 Service 上。Deployment 中指定了 Pod 的标签，通过 ConfigMap 挂载了 RabbitMQ 的配置文件，确保所有的 Pod 都可以访问到 RabbitMQ 服务。</p><ol><li>验证 RabbitMQ 是否可用的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: Pod
metadata:
  name: rabbitmq-client-pod
spec:
  containers:
</code></pre><p>4/24/2023, 5:36:17 PM</p><p>继续</p><p>4/24/2023, 5:37:21 PM</p><p>以下是创建共享的 RabbitMQ 服务所需的示例 YAML 文件内容：</p><ol><li>RabbitMQ 镜像的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: Pod
metadata:
  name: rabbitmq-pod
spec:
  containers:
  - name: rabbitmq
    image: rabbitmq
    ports:
    - containerPort: 5672
      name: amqp
    - containerPort: 15672
      name: http
</code></pre><p>注意，这里使用的是 Docker Hub 上的默认 RabbitMQ 镜像，也可以根据需要自定义 Dockerfile 来构建。</p><ol><li>RabbitMQ 配置文件的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: ConfigMap
metadata:
  name: rabbitmq-config
data:
  rabbitmq.conf: |
    loopback_users.guest = false
    listeners.tcp.default = 5672
    management.listener.port = 15672
  enabled_plugins: |
    [rabbitmq_management].
</code></pre><p>这里使用 ConfigMap 来存储 RabbitMQ 的配置信息。配置文件中禁用了默认用户 guest，开启了 TCP 监听端口和管理界面端口，并且启用了 RabbitMQ 管理插件。</p><ol><li>RabbitMQ Service 的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: Service
metadata:
  name: rabbitmq-service
spec:
  selector:
    app: rabbitmq
  ports:
  - name: amqp
    port: 5672
    targetPort: amqp
  - name: http
    port: 15672
    targetPort: http
  type: ClusterIP
</code></pre><p>这里创建的是 ClusterIP 类型的 Service，它会为 RabbitMQ 提供一个稳定的 IP 地址和端口。</p><ol><li>RabbitMQ Deployment 的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rabbitmq-deployment
spec:
  selector:
    matchLabels:
      app: rabbitmq
  replicas: 1
  template:
    metadata:
      labels:
        app: rabbitmq
    spec:
      volumes:
      - name: rabbitmq-config-volume
        configMap:
          name: rabbitmq-config
      containers:
      - name: rabbitmq
        image: rabbitmq
        ports:
        - containerPort: 5672
          name: amqp
        - containerPort: 15672
          name: http
        volumeMounts:
        - name: rabbitmq-config-volume
          mountPath: /etc/rabbitmq/
</code></pre><p>这里创建了一个带有自动伸缩功能的 Deployment，并将其绑定到刚才创建的 Service 上。Deployment 中指定了 Pod 的标签，通过 ConfigMap 挂载了 RabbitMQ 的配置文件，确保所有的 Pod 都可以访问到 RabbitMQ 服务。</p><ol><li>验证 RabbitMQ 是否可用的 YAML 文件内容如下：</li></ol><pre tabindex=0><code>复制代码
apiVersion: v1
kind: Pod
metadata:
  name: rabbitmq-client-pod
spec:
  containers:
  - name: rabbitmq-client
    image: rabbitmq
    command: [&#34;rabbitmqctl&#34;, &#34;list_users&#34;]
</code></pre><p>这里创建了一个 Pod 来验证 RabbitMQ 是否可用，使用 rabbitmqctl 命令列出用户列表来检查服务是否正常工作。</p><h2 id=ingress>ingress
<a class=anchor href=#ingress>#</a></h2><h3 id=配置>配置
<a class=anchor href=#%e9%85%8d%e7%bd%ae>#</a></h3><ul><li>k8s kind ingress 是什么，有什么用途？</li></ul><p><a href=https://blog.csdn.net/weixin_36755535/article/details/128385135>K8s Ingress 是 Kubernetes 集群中的一个资源对象，定义了一系列路由转发规则（或反向代理规则），规定了外部进来的 HTTP/HTTPS 请求应该被转发到哪个 Service 上。Ingress Controller 相当于是一个反向代理程序，负责解析 Ingress 的反向代理规则，并实时感知 Ingress 转发规则的变化。一旦 Ingress 规则有变化，Ingress Controller 会及时更新自己相应的转发规则，并根据这些规则，将接收到的请求转发到对应的 Service。</a><a href="https://bing.com/search?q=k8s+kind+ingress+%E6%98%AF%E4%BB%80%E4%B9%88">1</a><a href=https://blog.csdn.net/weixin_36755535/article/details/128385135>2</a></p><p><a href=https://kubernetes.io/zh/docs/concepts/services-networking/ingress/>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管等功能。</a></p><ul><li>举例说明。假设k8s中有一个服务A需要访问k8s中另一个服务B应该如何通过ingress 来实现</li></ul><p>假设你的 Kubernetes 集群中有一个服务 A，需要访问另一个服务 B，可以通过 Ingress 来实现。首先，你需要创建一个 Ingress 资源对象，定义外部对集群内服务的访问路由。例如：</p><pre tabindex=0><code>apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: minimal-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - path: /testpath
        pathType: Prefix
        backend:
          service:
            name: test
            port:
              number: 80
</code></pre><p>这个 Ingress 对象将会把 <code>/testpath</code> 的请求转发到名为 <code>test</code> 的 Service 上。这个 Service 可以是服务 B。<a href="https://bing.com/search?q=k8s+ingress+%E4%B8%BE%E4%BE%8B">1</a></p><p>希望这些信息能够帮助你理解如何通过 Ingress 实现服务 A 访问服务 B。如果你还有其他问题，请随时问我。</p><h2 id=环境变量在k8s>环境变量在k8s
<a class=anchor href=#%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%9c%a8k8s>#</a></h2><ul><li><p>k8s设定环境变量</p><p><a href=https://kubernetes.io/zh/docs/tasks/inject-data-application/define-environment-variable-container/>根据搜索结果，k8s设定环境变量的方法有以下几种1</a><a href=https://www.cnblogs.com/qsing/p/15773745.html>2</a>：</p><ul><li>在Pod的yaml文件中，使用env字段为容器指定环境变量，例如：</li></ul><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: envar-demo
spec:
  containers:
  - name: envar-demo-container
    image: nginx
    env:
    - name: DEMO_GREETING
      value: &#34;Hello from the environment&#34;
    - name: DEMO_FAREWELL
      value: &#34;Such a sweet sorrow&#34;
</code></pre><ul><li>使用ConfigMap或Secret对象来存储环境变量的值，然后在Pod的yaml文件中，使用envFrom字段或valueFrom字段来引用这些对象，例如：</li></ul><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: dapi-test-pod
spec:
  containers:
    - name: test-container
      image: k8s.gcr.io/busybox
      command: [ &#34;/bin/sh&#34;, &#34;-c&#34;, &#34;env&#34; ]
      env:
        # Define the environment variable
        - name: SPECIAL_LEVEL_KEY
          valueFrom:
            configMapKeyRef:
              # The ConfigMap containing the value you want to assign to SPECIAL_LEVEL_KEY
              name: special-config
              # Specify the key associated with the value
              key: special.how
</code></pre></li><li><p>使用env字段为容器指定环境变量 和 使用ConfigMap或Secret对象来存储环境变量 有什么区别？</p><p><a href=https://www.cnblogs.com/qsing/p/15773745.html>根据搜索结果，使用env字段为容器指定环境变量和使用ConfigMap或Secret对象来存储环境变量的区别主要有以下几点1</a><a href=https://cloud.tencent.com/developer/article/1931098>2</a><a href=https://kubernetes.io/zh/docs/tasks/inject-data-application/define-environment-variable-container/>3</a>：</p><ul><li>使用env字段时，需要为每个容器指定每个环境变量的值，而使用ConfigMap或Secret对象时，可以一次性引用所有的键值对作为环境变量</li><li>使用env字段时，环境变量的值是直接写在Pod的yaml文件中的，而使用ConfigMap或Secret对象时，环境变量的值是存储在Etcd中的，这样可以更好地管理和保护配置信息</li><li>使用env字段时，如果需要修改环境变量的值，需要重新创建Pod，而使用ConfigMap或Secret对象时，可以动态更新环境变量的值，不需要重启Pod</li></ul></li></ul><h2 id=configmap>ConfigMap
<a class=anchor href=#configmap>#</a></h2><ul><li><p>ConfigMap对象是一个存储配置数据的API对象</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#a6e22e>volumes</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>-</span> <span style=color:#a6e22e>configMap</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>defaultMode</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>420</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>items</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>-</span> <span style=color:#a6e22e>key</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>json</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>path</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>json</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>env</span><span style=color:#f92672>-</span><span style=color:#a6e22e>config</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>env</span><span style=color:#f92672>-</span><span style=color:#a6e22e>config</span>
</span></span></code></pre></div><p>在这个配置中，k8s挂载的不是物理机的env.json文件，而是ConfigMap对象的env.json键的值。ConfigMap对象是一个存储配置数据的API对象，它可以被Pod或其他对象引用 。你可以使用kubectl命令来创建或查看ConfigMap对象。例如：</p><pre tabindex=0><code>kubectl create configmap env-config --from-file=env.json
kubectl get configmap env-config -o yaml
</code></pre><p>这些命令会创建一个名为env-config的ConfigMap对象，它包含了一个键为env.json，值为文件内容的键值对。然后你可以在volume中引用这个ConfigMap对象，就像你的配置那样。</p></li></ul><h1 id=升级单个服务流程node-namespace-label>升级单个服务流程(node namespace label)
<a class=anchor href=#%e5%8d%87%e7%ba%a7%e5%8d%95%e4%b8%aa%e6%9c%8d%e5%8a%a1%e6%b5%81%e7%a8%8bnode-namespace-label>#</a></h1><ol><li>打包build docker image</li><li>保存服务docker镜像: docker save -o fizz_worker-2123.tar <a href=http://repos-xa.inone.nsfocus.com/websafe-docker/fizz_worker:2123>repos-xa.inone.nsfocus.com/websafe-docker/fizz_worker:2123</a></li><li>查看当前集群中node: <code>kubectl get node -o wide --show-labels</code><ol><li>并找出控制节点 如含有: <code>run-package-node,worker</code></li><li><code>k8s-worker1</code> 是控制节点名称</li><li>通过node名查看其上所部署的pod是否是目标服务: <code>kubectl get pod -A -o wide | grep k8s-worker1</code></li></ol></li><li>查看当前服务运行所处node: <code>kubectl get pod -n websafe -o wide</code></li><li>查看服务node 择选器: <code>kubectl get deploy master-fizz-daemon -n websafe -o yaml | grep nodeSelector -9</code> 一个 kv</li><li>给目标节点创建label<ol><li><code>kubectl label nodes k8s-worker1 app-select=websafe-rcmlog</code></li><li>查看是否成功 <code>kubectl get node -n websafe -o wide --show-labels | grep "k8s-worker1\\|rcmlog”</code></li></ol></li><li>上传镜像到harbor</li><li>修改deploy yaml文件(镜像版本、挂载目录、nodeSelector 其他(若有))，保存退出生效<ol><li><p>hostPath 挂载</p><pre tabindex=0><code>  volumeMounts:
  - mountPath: /mnt/NPAI
    name: rcmlog-claim
volumes:
- hostPath:
    path: /opt/nsfocus/NPAI/data/sftp/bsa/rcm_log
    type: &#34;&#34;
  name: rcmlog-claim
</code></pre></li><li><p>nodeSelector</p><pre tabindex=0><code>spec:
  nodeSelector:
    app-select: websafe-rcmlog
</code></pre></li><li><p>修改版本号为目标版本：2123（<code>image: [repos-xa.inone.nsfocus.com/websafe-docker/fizz_daemon:](&lt;http://repos-xa.inone.nsfocus.com/websafe-docker/fizz_daemon:1979>)2123</code>)</p></li></ol></li></ol><h1 id=docker-network>Docker Network
<a class=anchor href=#docker-network>#</a></h1><ul><li><p>创建网络 <code>websafe-network</code> 使用 <code>IPv4Address</code> 进行连接</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>init_mysql</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	docker run -p 3306:3306 <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-e MYSQL_ROOT_PASSWORD<span style=color:#f92672>=</span><span style=color:#ae81ff>123456</span> <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-e character-set-server<span style=color:#f92672>=</span>utf8mb4 <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-e collation-server<span style=color:#f92672>=</span>utf8mb4_unicode_ci <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	--network websafe-network
</span></span><span style=display:flex><span>	-v /x/Code/websafe_online_svn/mysql/conf:/etc/mysql/conf.d <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-v /x/Code/websafe_online_svn/mysql/logs:/logs <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-v /x/Code/websafe_online_svn/mysql/db:/var/lib/mysql <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-v /c/Windows/System32/drivers/etc/HOSTS:/etc/hosts <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	--name mysql56 mysql:5.6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>init_redis</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	docker run -p 6379:6379 <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	--network websafe-network <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	--name redislatest redis:latest --requirepass 3b21d032a7fd8eb51fa7bd8a2e812b78b7b3a36f 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>join_network</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	docker network connect websafe-network mysql56
</span></span><span style=display:flex><span>	docker network connect websafe-network daemon-xxx
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>init_network</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	docker network create websafe-network
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>check_network</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	docker network inspect websafe-network
</span></span><span style=display:flex><span>	docker network inspect websafe-network | findStr IPv4Address
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>run</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	docker run --name <span style=color:#66d9ef>$(</span>CONTAINER_NAME<span style=color:#66d9ef>)</span> -p 8888:80 <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-e POD_OWN_NAME<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;master-xxxxxx&#34;</span> <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	--network websafe-network <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	-v /x/Code/websafe_online_svn/env.json:/etc/env.json <span style=color:#ae81ff>\\</span>
</span></span><span style=display:flex><span>	registry.nscloud:5000/kunkka/websafe/scancenter:latest
</span></span></code></pre></div></li></ul><h2 id=docker-限制内存cpu占用>Docker 限制内存/CPU占用
<a class=anchor href=#docker-%e9%99%90%e5%88%b6%e5%86%85%e5%ad%98cpu%e5%8d%a0%e7%94%a8>#</a></h2><ul><li><p>运行docker时如何限制其内存占用？</p><p><a href=https://docs.docker.com/config/containers/resource_constraints/>运行docker时可以使用**–memory<strong>或</strong>-m**选项来限制其内存占用1</a><a href=https://www.baeldung.com/ops/docker-memory-limit>2</a><a href=https://phoenixnap.com/kb/docker-memory-and-cpu-limit>3</a>。例如：</p><pre tabindex=0><code>docker run -m 512m nginx
</code></pre><p><a href=https://www.baeldung.com/ops/docker-memory-limit>这个命令会限制nginx容器使用不超过512MB的内存。你还可以使用**–memory-reservation**选项来设置一个软限制，当主机内存不足时，docker会尽量保证容器的内存需求2</a>。例如：</p><pre tabindex=0><code>docker run -m 512m --memory-reservation=256m nginx
</code></pre><p>这个命令会保证nginx容器至少有256MB的内存，但最多不超过512MB。</p></li><li><p>如何限制cpu占用呢？</p><p><a href=https://blog.csdn.net/yucaifu1989/article/details/106688554>运行docker时可以使用**–cpus<strong>或</strong>–cpu-quota**选项来限制其CPU占用1</a><a href=https://xobo.org/docker-limit-cpu-and-memory/>2</a><a href=https://stackoverflow.com/questions/42345235/how-to-specify-memory-cpu-limit-in-docker-compose-version-3>3</a><a href=https://docs.docker.com/config/containers/resource_constraints/>4</a><a href=https://www.baeldung.com/ops/docker-memory-limit>5</a><a href=https://phoenixnap.com/kb/docker-memory-and-cpu-limit>6</a>。例如：</p><pre tabindex=0><code>docker run --cpus=2 nginx
</code></pre><p><a href=https://docs.docker.com/config/containers/resource_constraints/>这个命令会限制nginx容器使用不超过2个CPU的资源。你还可以使用**–cpu-shares**选项来设置容器的CPU优先级4</a><a href=https://www.baeldung.com/ops/docker-memory-limit>5</a>。例如：</p><pre tabindex=0><code>docker run --cpus=2 --cpu-shares=2000 nginx
</code></pre><p>这个命令会给nginx容器分配更高的CPU优先级，相对于默认值1024。</p></li></ul><h1 id=docker-在-k8s>Docker 在 k8s
<a class=anchor href=#docker-%e5%9c%a8-k8s>#</a></h1><ul><li><p>使用k8s 加载 docker镜像时，dockerfile中的CMD为什么没有执行？</p><p>根据搜索结果<a href=https://blog.csdn.net/u013641234/article/details/108237295>1</a><a href=https://kubernetes.io/zh/docs/tasks/inject-data-application/define-command-argument-container/>2</a>，k8s中的command和args会覆盖dockerfile中的entrypoint和cmd，所以如果您在k8s配置文件中设置了command或args，那么dockerfile中的cmd可能就不会执行。请检查您的k8s配置文件是否有这样的设置。</p><p><a href=https://juejin.cn/post/6987957373595811871>另外，dockerfile中的cmd也可能被容器启动时附加的指令忽略3</a>，请检查您是否在启动容器时指定了其他命令。</p></li></ul><h2 id=docker-cmd-和-k8s-command>Docker CMD 和 K8s Command
<a class=anchor href=#docker-cmd-%e5%92%8c-k8s-command>#</a></h2><ul><li>如果在k8s配置中没有指定command，那么容器启动时会执行dockerfile中指定的CMD命令作为默认命令。如果dockerfile中也没有指定CMD命令，则容器启动时不会执行任何命令，只是启动一个空的容器。因此，如果想要在k8s中保留dockerfile中指定的CMD命令，可以不指定command，或者在指定command时将CMD命令包含在内。</li><li>启动命令应该写在k8s配置中的command中，因为这样可以灵活地控制容器启动时执行的命令，而不受dockerfile中的CMD命令的限制。此外，将启动命令写在k8s配置中也可以方便地进行配置管理和版本控制，便于维护和更新。当然，如果dockerfile中的CMD命令已经满足需求，也可以直接使用默认命令，不需要在k8s配置中指定command。</li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#常用命令>常用命令</a></li><li><a href=#configmap--secret-存储文件内容>configmap / secret 存储文件内容</a><ul><li><a href=#新建>新建</a></li><li><a href=#删除>删除</a></li></ul></li><li><a href=#常用字段>常用字段</a></li><li><a href=#其他>其他</a><ul><li><a href=#annotations>annotations</a></li><li><a href=#ownerreferences-字段>ownerReferences 字段</a></li><li><a href=#ownerreferences-中的name和该pod-name相同有什么作用>ownerReferences 中的name和该pod name相同有什么作用？</a></li><li><a href=#env-环境变量>env 环境变量</a></li><li><a href=#initcontainers>initContainers</a></li><li><a href=#一些杂项>一些杂项</a></li></ul></li><li><a href=#a-name持久卷持久卷---persistentvolumea>持久卷 - PersistentVolume</a></li><li><a href=#知识问答>知识问答</a><ul><li><a href=#1-nodeselector-和-nodeselectorterms-有什么区别>1. nodeSelector 和 nodeSelectorTerms 有什么区别？</a></li></ul></li><li><a href=#常用命令-1>常用命令</a></li><li><a href=#常用字段-1>常用字段</a></li><li><a href=#其他-1>其他</a><ul><li><a href=#annotations-1>annotations</a></li><li><a href=#ownerreferences-字段-1>ownerReferences 字段</a></li><li><a href=#ownerreferences-中的name和该pod-name相同有什么作用-1>ownerReferences 中的name和该pod name相同有什么作用？</a></li><li><a href=#env-环境变量-1>env 环境变量</a></li><li><a href=#initcontainers-1>initContainers</a></li><li><a href=#一些杂项-1>一些杂项</a></li></ul></li><li><a href=#持久卷---persistentvolume>持久卷 - PersistentVolume</a></li></ul><ul><li><ul><li><a href=#k8s-路由解析>k8s 路由解析</a></li><li><a href=#配置一个rabbitmq给大家用>配置一个rabbitmq给大家用</a></li></ul></li><li><a href=#ingress>ingress</a><ul><li><a href=#配置>配置</a></li></ul></li><li><a href=#环境变量在k8s>环境变量在k8s</a></li><li><a href=#configmap>ConfigMap</a></li></ul><ul><li><a href=#docker-限制内存cpu占用>Docker 限制内存/CPU占用</a></li></ul><ul><li><a href=#docker-cmd-和-k8s-command>Docker CMD 和 K8s Command</a></li></ul></nav></div></aside></main></body></html>