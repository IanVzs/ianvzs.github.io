<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="author: Ian
Vn.Py笔记 ✏📔 # # 一个开源Python交易软件，主使用CTP协议。当然，还有其他协议了其源项目在http://www.vnpy.org/ 初期笔记 # 报单交易过程中， CTP使用BrokerID 从业务层面完全隔离不同经纪公司的交易、风控及结算用户的接入。 BrokerID具体取值咨询开户的经纪公司。 CTP中 UserID为操作员代码，InversterID为投资者代码； 投资者自己下单两者同为投资者代码
CTP-API中，OrderRef和OrderAction 前者为CTP后台提供给客户端标识一笔报 单的字段，从客户端可通过（FrontID、SessionID、OrderRef）唯一确定一笔报 单；；；后者与OrderRef功能相似，提供给客户端来标识一笔撤单。 前者的数据类型为字符数组，必须为阿拉伯数字字符。 OrderRef（OrderActionRef）取值必须保证在同一会话内发送的报单 OrderRef（OrderActionRef）值大于之前的最大值，开发多线程客户端尤为需要 注意。 CTP-API库：
error.dtd\error.xml 错误定义文件 ---- ThostFrfcMdApi.h 交易接口类定义文件 ——— ThostFtfcUserApiDataType.h 类型定义文件 ------ thostmduserapi.lib,thostmduserpi.dll 行情接口库文件 ----- thosttraderapi.lib,thosttraderapi.dll交易接口库文件 ----- 交易和行情接口类定义文件都包含API 和 SPI类定义，客户端使用API向CTP后台 发送请求，CTP后台则使用SPI向客户端回传响应及回报 行情Demo开发： 1.将API文件复制到工程目录；并将所有的头文件和静态、动态库连链接库 并将文件导入到项目工程中。 先继承行情接口类CThostFtdcMdspi，并实现需要实现的虚函数。 OnFrontConnectde、OnFrontDisconnected、OnPspUserLogin、 OnRspSubMarketDAta /API工作流程***/
API压缩包——API含常量对应字符、类型定义、操作系统编译定义、回调函数（MdSpi）（柜台向用户端发送信息后被系统自动调用的函数）、主动函数（MdApi）（向柜台发送各种请求和指令）
API工作流程： 创建MdSpi对象（回掉函数），调用MdApi类，以Create开头的静态方法，创建MdApi对象（主动函数），注册MdSpi对象指针，行情柜台前置机地址，调用MdApi对象Init方法初始化连接前置机，连接成功会通过OnFrontConnected回调通知用户，用户获得连接成功通知后，调MdApi的ReqUserLogin登陆，登陆后MdSpi的OnRsqUserLogin通知用户 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-到此登陆完成&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
MdApi：（行情相关） 使用MdApi对象的SubscribeMarketData方法，传入参数为想要订阅的“合约 代码”，订阅成功当合约有新行情通过MdApi的OnRtnDepthMarketData回调通知 用户 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-至此订阅完成&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 当用户的某次请求发生错误时，会通过OnRspError通知用户 MdApi也含有退订合约、登出功能。 而一般退出程序则直接杀进程（不太安全便是）
TraderApi：（交易相关） 不同于以上的有 注册TraderSpi对象的指针后需要调用TraderApi对象的 SubscribePrivateTopic和SubscribePublicTopic方法去选择公开和私有数据流的重 传方法 对于期货柜台，每一日第一次登陆需要先查询前一日的结算单，等待查询 结果返回，确认，才可进行后续操作（CTP、恒生UFT），证券（LTS）无此要求 上一步完成后，用户可以调用ReqQryInstrument的方法查询柜台上所有可 以交易的合约信息（包括代码、中文名、涨跌停、最小价位变动、合约乘数等大 量细节），一般是在这里获得合约信息列表后，再去MdApi中订阅合约；经常有 人问为什么在MdApi中找不到查询可供订阅的合约代码的函数，这里尤其要注 意，必须通过TraderApi来获取 当用户报单、成交状态发生变化时，TraderApi会自动通过OnRtnOrder、 OnRtnTrade通知，无需额外订阅 /封装API****/ 封装后API的动作： 主动函数： 调用封装API主动函数，传入Python变量作为参数—&gt;封装API将Python变量转换成C&#43;&#43;变量—&gt;API调用原生API主动函数传入C&#43;&#43;变量作为参数 回掉函数： 交易柜台通过原生API传入参数为C&#43;&#43;变量-&gt;封装API将C&#43;&#43;变量转换为Python变量-&gt;封装API调用封装后的回调函数想Python程序中推送数">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="Vn.Py学习笔记（Python交易平台框架）" />
<meta property="og:description" content="author: Ian
Vn.Py笔记 ✏📔 # # 一个开源Python交易软件，主使用CTP协议。当然，还有其他协议了其源项目在http://www.vnpy.org/ 初期笔记 # 报单交易过程中， CTP使用BrokerID 从业务层面完全隔离不同经纪公司的交易、风控及结算用户的接入。 BrokerID具体取值咨询开户的经纪公司。 CTP中 UserID为操作员代码，InversterID为投资者代码； 投资者自己下单两者同为投资者代码
CTP-API中，OrderRef和OrderAction 前者为CTP后台提供给客户端标识一笔报 单的字段，从客户端可通过（FrontID、SessionID、OrderRef）唯一确定一笔报 单；；；后者与OrderRef功能相似，提供给客户端来标识一笔撤单。 前者的数据类型为字符数组，必须为阿拉伯数字字符。 OrderRef（OrderActionRef）取值必须保证在同一会话内发送的报单 OrderRef（OrderActionRef）值大于之前的最大值，开发多线程客户端尤为需要 注意。 CTP-API库：
error.dtd\error.xml 错误定义文件 ---- ThostFrfcMdApi.h 交易接口类定义文件 ——— ThostFtfcUserApiDataType.h 类型定义文件 ------ thostmduserapi.lib,thostmduserpi.dll 行情接口库文件 ----- thosttraderapi.lib,thosttraderapi.dll交易接口库文件 ----- 交易和行情接口类定义文件都包含API 和 SPI类定义，客户端使用API向CTP后台 发送请求，CTP后台则使用SPI向客户端回传响应及回报 行情Demo开发： 1.将API文件复制到工程目录；并将所有的头文件和静态、动态库连链接库 并将文件导入到项目工程中。 先继承行情接口类CThostFtdcMdspi，并实现需要实现的虚函数。 OnFrontConnectde、OnFrontDisconnected、OnPspUserLogin、 OnRspSubMarketDAta /API工作流程***/
API压缩包——API含常量对应字符、类型定义、操作系统编译定义、回调函数（MdSpi）（柜台向用户端发送信息后被系统自动调用的函数）、主动函数（MdApi）（向柜台发送各种请求和指令）
API工作流程： 创建MdSpi对象（回掉函数），调用MdApi类，以Create开头的静态方法，创建MdApi对象（主动函数），注册MdSpi对象指针，行情柜台前置机地址，调用MdApi对象Init方法初始化连接前置机，连接成功会通过OnFrontConnected回调通知用户，用户获得连接成功通知后，调MdApi的ReqUserLogin登陆，登陆后MdSpi的OnRsqUserLogin通知用户 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-到此登陆完成&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
MdApi：（行情相关） 使用MdApi对象的SubscribeMarketData方法，传入参数为想要订阅的“合约 代码”，订阅成功当合约有新行情通过MdApi的OnRtnDepthMarketData回调通知 用户 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-至此订阅完成&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 当用户的某次请求发生错误时，会通过OnRspError通知用户 MdApi也含有退订合约、登出功能。 而一般退出程序则直接杀进程（不太安全便是）
TraderApi：（交易相关） 不同于以上的有 注册TraderSpi对象的指针后需要调用TraderApi对象的 SubscribePrivateTopic和SubscribePublicTopic方法去选择公开和私有数据流的重 传方法 对于期货柜台，每一日第一次登陆需要先查询前一日的结算单，等待查询 结果返回，确认，才可进行后续操作（CTP、恒生UFT），证券（LTS）无此要求 上一步完成后，用户可以调用ReqQryInstrument的方法查询柜台上所有可 以交易的合约信息（包括代码、中文名、涨跌停、最小价位变动、合约乘数等大 量细节），一般是在这里获得合约信息列表后，再去MdApi中订阅合约；经常有 人问为什么在MdApi中找不到查询可供订阅的合约代码的函数，这里尤其要注 意，必须通过TraderApi来获取 当用户报单、成交状态发生变化时，TraderApi会自动通过OnRtnOrder、 OnRtnTrade通知，无需额外订阅 /封装API****/ 封装后API的动作： 主动函数： 调用封装API主动函数，传入Python变量作为参数—&gt;封装API将Python变量转换成C&#43;&#43;变量—&gt;API调用原生API主动函数传入C&#43;&#43;变量作为参数 回掉函数： 交易柜台通过原生API传入参数为C&#43;&#43;变量-&gt;封装API将C&#43;&#43;变量转换为Python变量-&gt;封装API调用封装后的回调函数想Python程序中推送数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/docs/programmer/gui/noteofvn_py/" /><meta property="article:section" content="docs" />
<meta property="article:published_time" content="2018-05-15T10:13:48+00:00" />
<meta property="article:modified_time" content="2018-05-15T10:13:48+00:00" />
<title>Vn.Py学习笔记（Python交易平台框架） | Ian&#39;s Blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css" integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.21c7d5ec1a58dbd7dfb3bb14808b0caf48331f6576df77ab09d0db9f6def8b7a.js" integrity="sha256-IcfV7BpY29ffs7sUgIsMr0gzH2V233erCdDbn23vi3o=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>Ian&#39;s Blog</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/programmer/" class="">程序员笔记</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-52f633cba5cf47818d8ec01e928396f2" class="toggle"  />
    <label for="section-52f633cba5cf47818d8ec01e928396f2" class="flex justify-between">
      <a role="button" class="">Base</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/k8s/" class="">k8s</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/pypi/" class="">PyPi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/tipsofweb/" class="">Nginx高可用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/for_china/" class="">各个软件换源</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/tipsofdebugers/" class="">tips Of Debuggers</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/notesdjango/" class="">Django的建站的(｡･･)ﾉﾞ</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/tipsofvim/" class="">tip Of vim</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/editer/" class="">编辑器使用</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/noteoflinux/" class="">Linux</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/tip_dgraph/" class="">Dgraph</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/base/noteoffmtdata/" class="">数据格式笔记</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-bf4e0d6f0b81f7b3ec08ed1fc66b874d" class="toggle"  />
    <label for="section-bf4e0d6f0b81f7b3ec08ed1fc66b874d" class="flex justify-between">
      <a role="button" class="">Langs</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/langs/cmake/" class="">CMake 使用Tips</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/langs/noteofgoexp/" class="">Golang进阶笔记</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/langs/noteofgolang/" class="">Golang笔记</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/langs/tipsofmarkdown/" class="">tips Of markdown</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/langs/notespython/" class="">Python笔记(notes of Python)</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/langs/notesjava/" class="">愉快的Java(happy to learn the fuck java)</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-cd029da01a5cf373a5379dc078a74f2c" class="toggle"  />
    <label for="section-cd029da01a5cf373a5379dc078a74f2c" class="flex justify-between">
      <a role="button" class="">Game and Simulation</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/game_and_simulation/blender/" class="">Blender</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/game_and_simulation/noteofue4/" class="">UE4 笔记</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-883e27361d38e16afb68faff3435ac0b" class="toggle"  />
    <label for="section-883e27361d38e16afb68faff3435ac0b" class="flex justify-between">
      <a role="button" class="">Ml</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/ml/tensorflow/" class="">Tensorflow</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/ml/opencv/" class="">OpenCV</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/ml/paddle/" class="">Paddle</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/ml/noteofmachinelearning/" class="">机器学习库</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-7e5360c5e7954906b897ed79085884b6" class="toggle" checked />
    <label for="section-7e5360c5e7954906b897ed79085884b6" class="flex justify-between">
      <a href="/docs/programmer/gui/" class="">Gui</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/gui/pyinstaller/" class="">python打包</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/gui/qt/" class="">Qt/PySide</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/gui/noteofvn_py/" class="active">Vn.Py学习笔记（Python交易平台框架）</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/gui/notespython/" class="">图形化界面 （Python Gui）</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-4446dd07527142b855f26d7cc8f0e617" class="toggle"  />
    <label for="section-4446dd07527142b855f26d7cc8f0e617" class="flex justify-between">
      <a role="button" class="">Database</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/database/dgraph/" class="">Dgraph使用小记</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/database/noteofdocker/" class="">notes Of docker</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/database/noteofdbdata/" class="">db数据库</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-de7bfad1d124522974cdf8addfbb23f2" class="toggle"  />
    <label for="section-de7bfad1d124522974cdf8addfbb23f2" class="flex justify-between">
      <a role="button" class="">Net</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/net/tipsofgrpc/" class="">gRpc使用小记</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/net/net/" class="">网络(Computer Network)</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d325c59fc6513e1b1e05a60b192d4973" class="toggle"  />
    <label for="section-d325c59fc6513e1b1e05a60b192d4973" class="flex justify-between">
      <a href="/docs/programmer/hardware/" class="">Hardware</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/hardware/android/" class="">Android</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/hardware/raspberrypi/" class="">Raspberry Pi</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/hardware/readme/" class="">Readme</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/hardware/screen/" class="">Screen</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-40d35e91afa620ff2e7bf6291cfb3e1d" class="toggle"  />
    <label for="section-40d35e91afa620ff2e7bf6291cfb3e1d" class="flex justify-between">
      <a href="/docs/programmer/software/" class="">Software</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/software/bash/" class="">Bash</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/software/freebsd/" class="">Freebsd</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/software/gitbook/" class="">Gitbook</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/software/markdown/" class="">Markdown</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/software/npm/" class="">Npm</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/software/readme/" class="">Readme</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/software/vim/" class="">Vim</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/install_some/" class="">安装问题</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/demo_test_some/" class="">Demo Test项目中的一些东西</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/programmer/tipsofproblems/" class="">解决问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <a href="/docs/example/" class="">Example Site</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/" class="">Table of Contents</a>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/with-toc/" class="">With ToC</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/example/table-of-contents/without-toc/" class="">Without ToC</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>Shortcodes</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/buttons/" class="">Buttons</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/columns/" class="">Columns</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/details/" class="">Details</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/expand/" class="">Expand</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/hints/" class="">Hints</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <input type="checkbox" id="section-d3fc1bf6d66cd84b896a0af9f40cb1d5" class="toggle"  />
    <label for="section-d3fc1bf6d66cd84b896a0af9f40cb1d5" class="flex justify-between">
      <a href="/docs/shortcodes/section/" class="">Section</a>
    </label>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/section/first-page/" class="">First Page</a>
  

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/section/second-page/" class="">Second Page</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/shortcodes/tabs/" class="">Tabs</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/" >
        Blog
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>Vn.Py学习笔记（Python交易平台框架）</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#vnpyhttpsstaticvnpycomstaticimgindex2019-5-27mainwindowpng"><img src="https://static.vnpy.com/static/img/index/2019-5-27/mainwindow.PNG" alt="vn.py"></a></li>
    <li><a href="#初期笔记">初期笔记</a></li>
    <li><a href="#引擎之间执行过程">引擎之间执行过程</a>
      <ul>
        <li><a href="#发单为例">发单为例：</a></li>
        <li><a href="#调用关系">调用关系</a></li>
      </ul>
    </li>
    <li><a href="#ctpgateway-接入方法">ctpGateway 接入方法</a></li>
    <li><a href="#数据记录器">数据记录器</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#风控模块">风控模块</a></li>
    <li><a href="#cta策略">CTA策略</a></li>
    <li><a href="#ctp交易托管api">CTP交易托管API</a>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#体系结构">体系结构</a></li>
        <li><a href="#接口模式">接口模式</a></li>
        <li><a href="#运行模式">运行模式</a></li>
        <li><a href="#撤单-发单">撤单 发单</a></li>
        <li><a href="#traderapi所有方法功能">TraderApi所有方法功能</a></li>
      </ul>
    </li>
    <li><a href="#cta-策略引擎">CTA 策略引擎</a>
      <ul>
        <li></li>
        <li><a href="#记录">记录</a></li>
        <li><a href="#cta回测">CTA回测</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#事件引擎">事件引擎</a></li>
  </ul>

  <ul>
    <li><a href="#界面设计文档">界面设计文档</a>
      <ul>
        <li><a href="#功能要求">功能要求</a></li>
        <li><a href="#文档编写步骤">文档编写步骤</a></li>
        <li><a href="#模块">模块</a></li>
        <li><a href="#界面切换">界面切换</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#定位布局">定位布局</a></li>
      </ul>
    </li>
    <li><a href="#信号槽传输额外参数">信号槽（传输额外参数）</a>
      <ul>
        <li><a href="#一-使用lambda表达式">一： 使用lambda表达式</a></li>
        <li><a href="#二-使用functools里的partial函数">二： 使用functools里的partial函数</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#引擎">引擎</a></li>
    <li><a href="#报单管理">报单管理</a>
      <ul>
        <li><a href="#成交推送处理">成交推送处理</a></li>
        <li><a href="#报单者类">报单者类</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><p>author: Ian</p>
<h1 id="vnpy笔记-">
  Vn.Py笔记 ✏📔
  <a class="anchor" href="#vnpy%e7%ac%94%e8%ae%b0-">#</a>
</h1>
<h2 id="vnpyhttpsstaticvnpycomstaticimgindex2019-5-27mainwindowpng">
  <img src="https://static.vnpy.com/static/img/index/2019-5-27/mainwindow.PNG" alt="vn.py" />
  <a class="anchor" href="#vnpyhttpsstaticvnpycomstaticimgindex2019-5-27mainwindowpng">#</a>
</h2>
<p><!-- raw HTML omitted -->一个开源Python交易软件，主使用CTP协议。当然，还有其他协议了其源项目在<a href="http://www.vnpy.org/">http://www.vnpy.org/</a> <!-- raw HTML omitted --></p>
<hr>
<hr>
<hr>
<h2 id="初期笔记">
  初期笔记
  <a class="anchor" href="#%e5%88%9d%e6%9c%9f%e7%ac%94%e8%ae%b0">#</a>
</h2>
<pre><code>报单交易过程中，

CTP使用BrokerID 从业务层面完全隔离不同经纪公司的交易、风控及结算用户的接入。
BrokerID具体取值咨询开户的经纪公司。
</code></pre>
<p>CTP中 UserID为操作员代码，InversterID为投资者代码； 投资者自己下单两者同为投资者代码</p>
<pre><code>CTP-API中，OrderRef和OrderAction    前者为CTP后台提供给客户端标识一笔报
单的字段，从客户端可通过（FrontID、SessionID、OrderRef）唯一确定一笔报
单；；；后者与OrderRef功能相似，提供给客户端来标识一笔撤单。
前者的数据类型为字符数组，必须为阿拉伯数字字符。
OrderRef（OrderActionRef）取值必须保证在同一会话内发送的报单
OrderRef（OrderActionRef）值大于之前的最大值，开发多线程客户端尤为需要  
注意。
</code></pre>
<p>CTP-API库：</p>
<pre><code>error.dtd\error.xml 错误定义文件    ----   ThostFrfcMdApi.h 
交易接口类定义文件  
———   ThostFtfcUserApiDataType.h 类型定义文件  ------    
thostmduserapi.lib,thostmduserpi.dll 行情接口库文件     -----   
thosttraderapi.lib,thosttraderapi.dll交易接口库文件   ----- 

交易和行情接口类定义文件都包含API 和 SPI类定义，客户端使用API向CTP后台
发送请求，CTP后台则使用SPI向客户端回传响应及回报

行情Demo开发：
    1.将API文件复制到工程目录；并将所有的头文件和静态、动态库连链接库
并将文件导入到项目工程中。
    先继承行情接口类CThostFtdcMdspi，并实现需要实现的虚函数。  
OnFrontConnectde、OnFrontDisconnected、OnPspUserLogin、
OnRspSubMarketDAta
</code></pre>
<p>/<strong><strong><strong><strong><strong>API工作流程</strong></strong></strong></strong></strong>***/</p>
<p>API压缩包——API含常量对应字符、类型定义、操作系统编译定义、回调函数（MdSpi）（柜台向用户端发送信息后被系统自动调用的函数）、主动函数（MdApi）（向柜台发送各种请求和指令）</p>
<p>API工作流程：
创建MdSpi对象（回掉函数），调用MdApi类，以Create开头的静态方法，创建MdApi对象（主动函数），注册MdSpi对象指针，行情柜台前置机地址，调用MdApi对象Init方法初始化连接前置机，连接成功会通过OnFrontConnected回调通知用户，用户获得连接成功通知后，调MdApi的ReqUserLogin登陆，登陆后MdSpi的OnRsqUserLogin通知用户
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-到此登陆完成&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>
<pre><code>MdApi：（行情相关）
    使用MdApi对象的SubscribeMarketData方法，传入参数为想要订阅的“合约
代码”，订阅成功当合约有新行情通过MdApi的OnRtnDepthMarketData回调通知   
用户
</code></pre>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-至此订阅完成&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
当用户的某次请求发生错误时，会通过OnRspError通知用户        MdApi也含有退订合约、登出功能。      而一般退出程序则直接杀进程（不太安全便是）</p>
<pre><code>TraderApi：（交易相关）
    不同于以上的有 注册TraderSpi对象的指针后需要调用TraderApi对象的
SubscribePrivateTopic和SubscribePublicTopic方法去选择公开和私有数据流的重
传方法
    对于期货柜台，每一日第一次登陆需要先查询前一日的结算单，等待查询
结果返回，确认，才可进行后续操作（CTP、恒生UFT），证券（LTS）无此要求
    上一步完成后，用户可以调用ReqQryInstrument的方法查询柜台上所有可
以交易的合约信息（包括代码、中文名、涨跌停、最小价位变动、合约乘数等大
量细节），一般是在这里获得合约信息列表后，再去MdApi中订阅合约；经常有
人问为什么在MdApi中找不到查询可供订阅的合约代码的函数，这里尤其要注
意，必须通过TraderApi来获取
    当用户报单、成交状态发生变化时，TraderApi会自动通过OnRtnOrder、
OnRtnTrade通知，无需额外订阅
</code></pre>
<p>/<strong><strong><strong><strong><strong><strong>封装API</strong></strong></strong></strong></strong></strong>****/
封装后API的动作：
主动函数：  调用封装API主动函数，传入Python变量作为参数—&gt;封装API将Python变量转换成C++变量—&gt;API调用原生API主动函数传入C++变量作为参数
回掉函数：  交易柜台通过原生API传入参数为C++变量-&gt;封装API将C++变量转换为Python变量-&gt;封装API调用封装后的回调函数想Python程序中推送数</p>
<pre><code>封装处理：
    将回调函数Spi类和主动函数Api类封装为一个类，使用中更加方便
    在API中包含一个缓冲队列，当回调函数收到新的数据信息时只是简单存入
并立即返回，而数据信息的处理和向Python中的推送则由另一个工作线程执行
    鉴于Python中dict字典内的键和值的类型可以不同，所以利用此来代替
C++的结构体


处理示例：
    getChar()： d(Python字典对象) key(d中想要提取的数据键名) 
if(d.has_key(key)) 判断是否存在这个键；
    object o = d[key]; 提取对应值   
    extract&lt;string&gt; x(o); 生成提取
std::string类的提取器
    if (x.check())  检测能否提取出数据  string s = x();  执行解包器，提取
string对象
    const char *buffer = s.c_str();  从s中获取字符串指针bufffer     
strcpy_s(value, strlen(buffer) + 1, buffer);  
将字符串指针指向的字符串数组复制到结构体成员的指针上    对字符串指针赋值
必须使用strcpy_s, vs2013使用strcpy
编译通不过+1应该是因为C++字符串的结尾符号？不是特别确定，不加这个
1会出错
</code></pre>
<p>/<strong><strong><strong><strong><strong><strong><strong>事件驱动</strong></strong></strong></strong></strong></strong></strong>***/</p>
<p>时间驱动： 定时调用
事件驱动： 新事件被推送时（如新行情、成交）则调用
初始化：    事件队列、引擎开关（标志）、事件线程、定时器、一个事件和处理函数对应字典（__handlers）
引擎运行：  循环检查引擎开关 若开则一直尝试获取事件（阻塞开，时间1s），处理事件； 若出错则pass
处理事件：  检测是否有对当前事件监听的处理函数，若有则循环调用相应处理函数对事件进行处理
计时器事件：    创建计时器事件，推入计时器事件
引擎启动：  打开引擎开关、启动事件处理线程、启动定时器（事件默认间隔1s）
停止引擎：  关闭。。。。、停止计时器、等待事件处理线程退出
注册事件处理：  尝试获取对应处理此类型函数列表（对应字典），若无则创建。
注销函数监听：  。。。。。。。。。。。。。。。。。。。。。，若无则pass，若函数存在于列表则将之移除，若函数列表为空，则引擎中移除该事件类型
put：       向事件队列中存入事件</p>
<p>底层接口对接：
交易程序架构分：底层接口、中层引擎、顶层GUI，
为将某API对接到程序中需：1.将API的回调函数收到的数据—&gt;中层引擎 等待处理 2.将API的主动函数进行一定的简化封装，便于中层引擎调用</p>
<p>中层引擎设计：
进一步封装底层接口所暴露出的API函数，使得其更容易被上层的GUI和策略组件调用。
构造函数：
以主引擎成员变量形式创建事件驱动引擎ee，行情接口md和交易接口td的对象。
随后立即启动，当用户调用接口连接、登陆等功能、收到事件推送，ee可以立即推送到监听这些事件的组件进行处理。
LTS和CTP接口的持仓情况和账户情况不通过推送，需手动查询。Demo选择循环查询模式，不断更新。可选择不进行查询，降低占用网络带宽。
登陆成功后，查询柜台所有可交易信息，保存到dictInstrument字典中，方便后续查询
优化了一些函数方法的调用方式，将经纪商一起提供的接口登陆封装在一个函数中，减少了重复书写的次数。</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="引擎之间执行过程">
  引擎之间执行过程
  <a class="anchor" href="#%e5%bc%95%e6%93%8e%e4%b9%8b%e9%97%b4%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b">#</a>
</h2>
<h3 id="发单为例">
  发单为例：
  <a class="anchor" href="#%e5%8f%91%e5%8d%95%e4%b8%ba%e4%be%8b">#</a>
</h3>
<p>设置发单按钮 -&gt; 将点按动作关联sendOrder发单实现函数（从输入框获取合约代码-&gt;获取合约信息对象（见下） -&gt; <em>如果成功获取</em> -&gt; 再获取方向价格等信息 -&gt; 调用主引擎下发单实现 -&gt; 主引擎转到TdApi下发单函数执行（请求编号（API管理） -&gt; 将传入信息数据存入字典（合约代码、方向价格等） -&gt; 报单编号（API管理） -&gt; 用户id、单子属性（投机、立即发单、今日有效）等信息存入字典） -&gt; self.reqOrderInsert(req（信息字典）, self.__reqid（请求编号）) -&gt; 返回订单号（报单编号））</p>
<hr>
<h4 id="主引擎负责对api的调度">
  主引擎：（负责对API的调度）
  <a class="anchor" href="#%e4%b8%bb%e5%bc%95%e6%93%8e%e8%b4%9f%e8%b4%a3%e5%af%b9api%e7%9a%84%e8%b0%83%e5%ba%a6">#</a>
</h4>
<p><strong>init</strong>()初始化中的动作：
创建事件驱动引擎、创建API接口、启动事件驱动引擎、循环查询持仓和账户相关（之后学习）、创建合约存储空字典，注册插入合约对象执行函数事件类型和其处理函数。
其中包含几乎所有的功能函数，包含了每个功能函数的实现方法</p>
<h4 id="事件驱动引擎">
  事件驱动引擎：
  <a class="anchor" href="#%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e5%bc%95%e6%93%8e">#</a>
</h4>
<p><strong>init</strong>()初始化中的动作：
创建事件队列、创建设置事件引擎开关（关）、创建事件处理线程(目标为引擎运行)、创建计时器（将超时动作连接到__onTimer函数）、创建__handlers空字典（存储对应事件调用关系）
统筹管理事件的执行，在其中建立起事件执行队列管理向队列中插入事件，分配事件对象类型（据此注册其执行函数）和具体事件数据（时间及日志），拥有注册事件处理监听及注销监听。最终使得整个程序有序的进行。</p>
<hr>
<h3 id="调用关系">
  调用关系
  <a class="anchor" href="#%e8%b0%83%e7%94%a8%e5%85%b3%e7%b3%bb">#</a>
</h3>
<p>主引擎在初始化时即启动事件驱动引擎（调用启动函数start()（将引擎开关设为启动、启动事件处理线程、启动计时器）） -&gt; 事件处理线程运行目标__run()（若开关开则将从<strong>事件队列</strong>中get()到事件，放到处理函数__process()中执行） -&gt; __process()处理事件函数（检查事件类型，在__handlers字典中是否有对此监听处理函数，若存在则调用字典中处理函数）</p>
<pre><code>事件启动引擎start()中启动定时器 -&gt; 创建计时器事件 -&gt; 向队列存入计时器事件
</code></pre>
<hr>
<h4 id="获取合约信息对象">
  获取合约信息对象：
  <a class="anchor" href="#%e8%8e%b7%e5%8f%96%e5%90%88%e7%ba%a6%e4%bf%a1%e6%81%af%e5%af%b9%e8%b1%a1">#</a>
</h4>
<p>从合约字典中读取合约信息对象有则继续执行原本程序操作（获取名称、发单撤单），无则None</p>
<h5 id="以初始化查询为例">
  以初始化查询为例：
  <a class="anchor" href="#%e4%bb%a5%e5%88%9d%e5%a7%8b%e5%8c%96%e6%9f%a5%e8%af%a2%e4%b8%ba%e4%be%8b">#</a>
</h5>
<p>主引擎初始化中注册<code>self.ee.register(EVENT_TDLOGIN, self.initGet)</code>,<code>EVENT_TDLOGIN</code>为交易服务器登陆成功事件。即此事件为登录成功后开始初始化查询。
步骤：打开设定文件<code>setting.vn</code>，尝试读取设定字典。载入后，设定事件类型、将事件推入事件队列、查询投资者、循环查询账户和持仓。（若不存在or合约数据非今天，则发出获取合约请求。）-&gt; 获取合约 -&gt; 定义事件类型 -&gt; 推入事件队列 -&gt; API查询合约</p>
<hr>
<hr>
<h2 id="ctpgateway-接入方法">
  ctpGateway 接入方法
  <a class="anchor" href="#ctpgateway-%e6%8e%a5%e5%85%a5%e6%96%b9%e6%b3%95">#</a>
</h2>
<p><!-- raw HTML omitted -->考虑到现阶段大部分CTP中的ExchangeID字段返回的都是空值
vtSymbol直接使用symbol<!-- raw HTML omitted --></p>
<hr>
<p>创建CTP价格方向交易所持仓产品等类型映射，方便调用  <strong>然后</strong>  <code>class CtpGateway(VtGateway):</code>CTP接口中初始化动作（继承VtGateway实例化事件引擎、设定网关名称为’CTP‘、实例化ctpMdApi，ctpTdApi、初始化行情交易连接状态，循环查询允许）</p>
<p><strong>连接过程</strong>
初始化账号密码等、连接服务器、注册服务器地址、登陆 <br>
订阅合约里有个设计为：尚未登陆就调用了订阅则保存订阅信号，则在成功登陆之后的登陆回报函数中重新订阅</p>
<hr>
<h2 id="数据记录器">
  数据记录器
  <a class="anchor" href="#%e6%95%b0%e6%8d%ae%e8%ae%b0%e5%bd%95%e5%99%a8">#</a>
</h2>
<h4 id="drbasepy中定义数据类型font-colororange数据记录器和cta两模块共同使用font">
  drBase.py中（定义数据类型）：（<!-- raw HTML omitted -->数据记录器和CTA两模块共同使用<!-- raw HTML omitted -->）
  <a class="anchor" href="#drbasepy%e4%b8%ad%e5%ae%9a%e4%b9%89%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8bfont-colororange%e6%95%b0%e6%8d%ae%e8%ae%b0%e5%bd%95%e5%99%a8%e5%92%8ccta%e4%b8%a4%e6%a8%a1%e5%9d%97%e5%85%b1%e5%90%8c%e4%bd%bf%e7%94%a8font">#</a>
</h4>
<pre><code>K线数据
    构造函数（定义数据类型）：vt系统代码、合约代码、交易所代码、开高低
关、bar开始时间、时间、成交量持仓量
Tick数据
    构造函数（定义数据类型）：vt系统代码、合约代码、交易所代码、成交数
据、tick时间、五档行情
</code></pre>
<hr>
<h4 id="font-colorreddrengine数据记录引擎font">
  <!-- raw HTML omitted -->DrEngine数据记录引擎<!-- raw HTML omitted -->
  <a class="anchor" href="#font-colorreddrengine%e6%95%b0%e6%8d%ae%e8%ae%b0%e5%bd%95%e5%bc%95%e6%93%8efont">#</a>
</h4>
<p>获取当前文件绝对路径</p>
<pre><code>settingFileName = 'DR_setting.json'
path = os.path.abspath(os.path.dirname(__file__))       
settingFileName = os.path.join(path, settingFileName)
</code></pre>
<p>初始化中动作：实例化设置主引擎、事件引擎、获取当前日期、创建主力合约代码映射字典、Tick对象字典、K线对象字典、初始化数据库插入单独线程、载入设置，订阅行情</p>
<h5 id="载入设置订阅行情">
  载入设置、订阅行情
  <a class="anchor" href="#%e8%bd%bd%e5%85%a5%e8%ae%be%e7%bd%ae%e8%ae%a2%e9%98%85%e8%a1%8c%e6%83%85">#</a>
</h5>
<p>打开<code>DR_setting.json</code>文件，以json载入，其中<code>’working‘</code>决定是否启动行情记录功能。随后从json文件中循环获取合约代码订阅tick和bar</p>
<p>启动数据插入线程（<code>run</code>函数（向MongoDB中插入数据））、注册事件监听（<code>procecssTickEvent</code>处理行情推送（<!-- raw HTML omitted -->下详<!-- raw HTML omitted -->））</p>
<h5 id="处理行情推送">
  处理行情推送
  <a class="anchor" href="#%e5%a4%84%e7%90%86%e8%a1%8c%e6%83%85%e6%8e%a8%e9%80%81">#</a>
</h5>
<p>从事件字典中取出保存的具体事件数据、<code>vtSymbol</code>为tick识别信号（合约代码）、转化Tick格式、更新TIck数据（并发出日志）、更新分钟线数据</p>
<hr>
<h2 id="风控模块">
  风控模块
  <a class="anchor" href="#%e9%a3%8e%e6%8e%a7%e6%a8%a1%e5%9d%97">#</a>
</h2>
<p>从配置json文件中读取设定信息  操作运作：1.检测风控设定值变化 2.每笔交易发单时使用风控模块决定该次发单是否允许   （其中流控计数在每次调用风控检测时计数、成交合约量在更新成交数据中加交易数值）</p>
<hr>
<hr>
<hr>
<h2 id="cta策略">
  CTA策略
  <a class="anchor" href="#cta%e7%ad%96%e7%95%a5">#</a>
</h2>
<p>直接来到改版之后：</p>
<hr>
<hr>
<hr>
<h2 id="ctp交易托管api">
  CTP交易托管API
  <a class="anchor" href="#ctp%e4%ba%a4%e6%98%93%e6%89%98%e7%ae%a1api">#</a>
</h2>
<h3 id="介绍">
  介绍
  <a class="anchor" href="#%e4%bb%8b%e7%bb%8d">#</a>
</h3>
<p>基于C++的类库，通过使用提供接口实现相关交易功能，含：报单与报价录入、的撤销、的挂起、的激活、的修改、的查询、成交单查询、投资者查询、 投资者持仓查询、合约查询、交易日获取等</p>
<p>含文件：交易接口、API所需数据类型、业务相关数据结构i、的头文件、动态链接库、导入库</p>
<h3 id="体系结构">
  体系结构
  <a class="anchor" href="#%e4%bd%93%e7%b3%bb%e7%bb%93%e6%9e%84">#</a>
</h3>
<p>建立在TCP协议之上FTD协议与交易托管系统进行通讯
<strong>FTD通讯模式：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">对话通讯模式</td>
<td style="text-align:right">- 会员端请求、接收处理、响应</td>
</tr>
<tr>
<td style="text-align:left">私有通讯模式</td>
<td style="text-align:right">- 交易所主动向特定会员发出</td>
</tr>
<tr>
<td style="text-align:left">广播通讯模式</td>
<td style="text-align:right">- 交易所主动、全员发送</td>
</tr>
</tbody>
</table>
<h3 id="接口模式">
  接口模式
  <a class="anchor" href="#%e6%8e%a5%e5%8f%a3%e6%a8%a1%e5%bc%8f">#</a>
</h3>
<p><code>CThostFtdeTraderApi</code>和<code>CThostFtdeTraderSpi</code>，前者发送请求，后者回调响应。旗下函数方法前者以Req开头后者以OnRsp开头。请求接口第一个参数为请求的内容，不能为空。第二个参数为请求号。</p>
<p>如果接收到的响应数据不止一个，则回调函数会被多次调用。第一个参数为响应的具体数据，第二个参数为处理结果，第三个参数为请求号，第四个参数为响应结束标志，表明是否是本次响应的最后一次回调。</p>
<h3 id="运行模式">
  运行模式
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e6%a8%a1%e5%bc%8f">#</a>
</h3>
<p>至少两个线程，一个为应用程序主线程，一个为交易员API工作线程，其间通讯由API工作线程驱动。</p>
<h3 id="撤单-发单">
  撤单 发单
  <a class="anchor" href="#%e6%92%a4%e5%8d%95-%e5%8f%91%e5%8d%95">#</a>
</h3>
<h4 id="发单为例-1">
  发单为例：
  <a class="anchor" href="#%e5%8f%91%e5%8d%95%e4%b8%ba%e4%be%8b-1">#</a>
</h4>
<p>在用户点击发单之后，程序从“交易”栏的<code>text()</code>获取合约代码，随后从详细合约保存字典中读取其他信息，将之保存到一个字典中之后，调用主引擎对特定接口发单。</p>
<p>发单完成之后，马上会收到报单响应 OnRspOrderInsert，说明交易系统已经收到报单。报单进入交易系统后，如果报单的交易状态发生变化，就会收到报单回报 OnRtnOrder。如果报单被撮(部分)成交，就会收到成交回报 OnRtnTrade。通过更新</p>
<h4 id="撤单时">
  撤单时：
  <a class="anchor" href="#%e6%92%a4%e5%8d%95%e6%97%b6">#</a>
</h4>
<p>程序从单元格中获取exchange、frontID、orderID、sessionID、symbol、gatewayName等信息，调用主引擎对特定接口撤单。撤单时调用Api函数为reqOrderAction其内容包括撤销、挂起、激活、修改，故还需一个Flag参数</p>
<p>ps：如果报单还停留在 Thost，Thost 可以用 Front 、SessionID、OrderRef 来定位
如果报单停留在交易所，Thost 可以用 ExchangID、OrderSysID 来定位，然后向交易
所转发撤单指令。</p>
<h3 id="traderapi所有方法功能">
  TraderApi所有方法功能
  <a class="anchor" href="#traderapi%e6%89%80%e6%9c%89%e6%96%b9%e6%b3%95%e5%8a%9f%e8%83%bd">#</a>
</h3>
<pre><code>OnFrontConnected/Disconnected       
# 客户端与交易托管系统建立起通信连接时
OnHeartBeatWarning      
# 当长时间未收到报文时
OnRspUserLogin/Logout       
# 登陆注销响应
OnRspUserPasswordUpdate     
# 改密响应
OnRspTradingAccountPasswordUpdate       
# 当客户端发出资金账户口令更新指令后，交易托管系统返回响应时
OnRspError      
# 请求出错时
OnRspOrderInsert        
# 报单录入
OnRspOrderAction        
# 报单操作包括报单的撤销、报单的挂起、报单的激活、报单的修改。当客户端
    发出过报单操作指令后，交易托管系统返回响应时
OnRspQueryMaxOrderVolume        
# 查询最大报单
OnRspSettlementInfoConfirm      
# 当客户端发出投资者结算结果确认指令后，交易托管系统返回响应时

等……  lol 统计无力
</code></pre>
<p>？</p>
<hr>
<hr>
<hr>
<h2 id="cta-策略引擎">
  CTA 策略引擎
  <a class="anchor" href="#cta-%e7%ad%96%e7%95%a5%e5%bc%95%e6%93%8e">#</a>
</h2>
<h5 id="__init__的工作">
  _<em>init</em>_()的工作：
  <a class="anchor" href="#__init__%e7%9a%84%e5%b7%a5%e4%bd%9c">#</a>
</h5>
<ul>
<li>加载主引擎、事件引擎；获取当前日期</li>
<li>设定是否在回测</li>
<li>保存策略实例的字典strategyDict(key为策略名称，value为策略实例)、</li>
<li>保存vtSymbol和策略实例映射的字典(用于推送tick数据，可能多个策略交易同一个vtSymbol因此key为vtSymbol.value为包含所有相关策略对象的list)、</li>
<li>保存vtOrderID和strategy对象映射的字典(用于推送order和trade数据key为vtOrderID，value为strategy对象）、</li>
<li>本地停止单编号计数、本地停止单字典(key为stopOrderID，value为stopOrder对象)、</li>
<li>持仓缓存字典(key为vtSymbol，value为PositionBuffer对象)、</li>
<li>成交号集合、</li>
<li>设置引擎类型为实盘、</li>
<li>注册事件监听</li>
</ul>
<h4 id="初始化策略">
  初始化策略
  <a class="anchor" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%ad%96%e7%95%a5">#</a>
</h4>
<p>从数据库中读取3天的历史TICK数据、行情更新。。。。。有的话待续</p>
<h4 id="启动策略">
  启动策略
  <a class="anchor" href="#%e5%90%af%e5%8a%a8%e7%ad%96%e7%95%a5">#</a>
</h4>
<p>从策略实例字典中取出策略实例，调用策略函数（已经初始化，没有在进行策略交易），开启进行交易标志位。</p>
<h4 id="停止策略">
  停止策略
  <a class="anchor" href="#%e5%81%9c%e6%ad%a2%e7%ad%96%e7%95%a5">#</a>
</h4>
<p>从策略实例字典中取出策略实例，调用策略函数（            在进行策略交易），关闭策略交易标志位 -&gt; 对该策略发出的所有限价单进行撤单 -&gt; 发出的所有本地停止单撤单 -&gt;</p>
<h4 id="保存读取策略配置">
  保存、读取策略配置
  <a class="anchor" href="#%e4%bf%9d%e5%ad%98%e8%af%bb%e5%8f%96%e7%ad%96%e7%95%a5%e9%85%8d%e7%bd%ae">#</a>
</h4>
<p>触发策略状态变化事件（通常用于通知GUI更新）
获取策略的参数字典
获取策略当前的变量字典</p>
<h3 id="记录">
  记录
  <a class="anchor" href="#%e8%ae%b0%e5%bd%95">#</a>
</h3>
<p>报单更新、成交更新都是先检测是否有对此监听的策略
限价单成交处理：成交回报、报单回报、记录成交到列表、删除该限价单</p>
<h4 id="基础功能的策略调用">
  基础功能的策略调用
  <a class="anchor" href="#%e5%9f%ba%e7%a1%80%e5%8a%9f%e8%83%bd%e7%9a%84%e7%ad%96%e7%95%a5%e8%b0%83%e7%94%a8">#</a>
</h4>
<p>策略中发单时，需要在设置参数时考虑设置。    另获取持仓缓存数据，做平昨平今的选择。
策略中发单时，检查报单是否有效，赋参，撤单。
发停止单，编号，赋参，保存至字典
撤停止单，从工作停止单字典中移除</p>
<hr>
<h4 id="ta-lib">
  Ta-Lib
  <a class="anchor" href="#ta-lib">#</a>
</h4>
<p>趋势策略分为以下部分：</p>
<ul>
<li>趋势信号（通常是基于某几个参数计算出来的指标值超过某个阈值）、</li>
<li>信号过滤（和趋势信号类似）、</li>
<li>出场方案（固定点数/百分比的止盈和止损，移动止损）。
所以，Ta-lib是策略实现工具罢了。</li>
</ul>
<p>此库中提供了多种技术分析的函数，有多种指标：ADX、MACD、RSI、布林轨道等
；K线形态识别，如“黄昏之星”、“锤形线”等。</p>
<p>依靠此库对数据的分析，来下达发单撤单的动作即为策略。</p>
<h6 id="策略示例">
  策略示例：
  <a class="anchor" href="#%e7%ad%96%e7%95%a5%e7%a4%ba%e4%be%8b">#</a>
</h6>
<pre><code>基于Talib模块的双指数均线策略`class TalibDoubleSmaDemo(CtaTemplate):`
</code></pre>
<p><!-- raw HTML omitted -->就是两个指标的数据来判断当前局势罢了<!-- raw HTML omitted --></p>
<ol>
<li>设定策略参数</li>
<li>策略变量</li>
<li>参数列表（保存参数名称）</li>
<li>变量列表（保存变量名称）</li>
</ol>
<h6 id="步骤">
  步骤
  <a class="anchor" href="#%e6%ad%a5%e9%aa%a4">#</a>
</h6>
<p>初始化策略（加载Bar数据）、启动策略、停止策略、收到行情Tick推送（计算K线）、收到Bar推送（缓存最新收盘价到列表 -&gt; 数量足够后转化为Numpy数组后传入talib函数SMA中计算 -&gt; 读取当前K线和上一根K线数值，用于判断均线交叉 -&gt; 检测持仓状态，做出相应交易动作）</p>
<hr>
<h3 id="cta回测">
  CTA回测
  <a class="anchor" href="#cta%e5%9b%9e%e6%b5%8b">#</a>
</h3>
<h5 id="__init__的工作-1">
  _<em>init</em>_()的工作
  <a class="anchor" href="#__init__%e7%9a%84%e5%b7%a5%e4%bd%9c-1">#</a>
</h5>
<ul>
<li>本地停止单编号计数    <code>self.stopOrderCount</code></li>
<li>本地停止单字典    <code>self.stopOrderDict</code> And <code>self.workingStopOrderDict</code></li>
<li>设引擎类型为回测</li>
<li>回测相关变量定义</li>
<li>当前最新数据，用于模拟成交使用</li>
</ul>
<h4 id="运行回测">
  运行回测
  <a class="anchor" href="#%e8%bf%90%e8%a1%8c%e5%9b%9e%e6%b5%8b">#</a>
</h4>
<ol>
<li>
<p>载入历史数据</p>
</li>
<li>
<p>根据回测模式确定要使用数据类</p>
</li>
<li>
<p>初始化策略</p>
</li>
<li>
<p>启动策略</p>
</li>
<li>
<p>回放数据（从数据库中取得推到newBar或者newTick）</p>
</li>
<li>
<p>策略获得新数据，执行相应操作</p>
</li>
</ol>
<h5 id="基于最新数据撮合限价单">
  基于最新数据撮合限价单
  <a class="anchor" href="#%e5%9f%ba%e4%ba%8e%e6%9c%80%e6%96%b0%e6%95%b0%e6%8d%ae%e6%92%ae%e5%90%88%e9%99%90%e4%bb%b7%e5%8d%95">#</a>
</h5>
<p>先确定会撮合成交的价格 -&gt; 遍历限价单字典中所有限价单 -&gt; 判断是否会成交 -&gt; 发生成交推送成交数据（买入 -&gt; 增加持仓 推送委托数据、从字典中删除该限价单）</p>
<h4 id="计算原理">
  计算原理
  <a class="anchor" href="#%e8%ae%a1%e7%ae%97%e5%8e%9f%e7%90%86">#</a>
</h4>
<hr>
<hr>
<hr>
<h1 id="改版之后程序架构">
  改版之后程序架构
  <a class="anchor" href="#%e6%94%b9%e7%89%88%e4%b9%8b%e5%90%8e%e7%a8%8b%e5%ba%8f%e6%9e%b6%e6%9e%84">#</a>
</h1>
<p>|   |   |       |   |       |       |   |       |       |       |   |   |
|:&mdash;-  |&mdash;    |   &mdash; |   |&mdash;        |&mdash;        |&mdash;-   |   &mdash; |   &mdash; |   &mdash; |&mdash;    |&mdash;:   |
|   |APIs   |       |***    |       |   |   |       |   Trader  |       |   |   |
|<code>CTP</code>      |   |<code>KSGold</code>   |***    |<code>Common</code>   |<code>Condig</code>   |<code>Core</code>|<code>Gateway</code>   |<code>Setting</code>  |<code>Strategy</code> |<code>UI</code>   |<code>main</code>|
|CtpMdApi、CtpTdApi | ………… | ………… |Md、Td| ……………… | ……………… |CTA、HTA、引擎、事件管理| ……………… |配置文件| ……………… | ……………… | ……………… |</p>
<h2 id="事件引擎">
  事件引擎
  <a class="anchor" href="#%e4%ba%8b%e4%bb%b6%e5%bc%95%e6%93%8e">#</a>
</h2>
<p>两版都一样，作为一个程序运行最外层的生成的实例，来进行各个实例之间的数据传输。因为每个实例都将数据在事件引擎中保存，调用事件引擎中的事件队列来对进行事件运行安排。</p>
<p>Like This：</p>
<pre><code>class A(object):
&quot;&quot;&quot;docstring for A&quot;&quot;&quot;
    def __init__(self, name):
        super(A, self).__init__()
        self.name = name
        self.a = 0
    def da(self):
        print self.name
        print self.a    
a = A('I am A')
a.da()




class B(object):
&quot;&quot;&quot;docstring for B&quot;&quot;&quot;
    def __init__(self, aclass):
        super(B, self).__init__()
        self.aclass = aclass
        self.aclass.a += 1
    def dada(self):
        self.aclass.da()
b = B(a)
b.dada()

class C(object):
&quot;&quot;&quot;docstring for B&quot;&quot;&quot;
    def __init__(self, aclass):
        super(C, self).__init__()
        self.aclass = aclass
        self.aclass.a += 1
    def dada(self):
        self.aclass.da()
c = C(a)
c.dada()
</code></pre>
<blockquote>
<p>I am A</p>
</blockquote>
<blockquote>
<p>0</p>
</blockquote>
<blockquote>
<p>I am A</p>
</blockquote>
<blockquote>
<p>1</p>
</blockquote>
<blockquote>
<p>I am A</p>
</blockquote>
<blockquote>
<p>2</p>
</blockquote>
<p>B与C分别在去改变读取在A中定义的数值。  嗯，没错，这么看的画确实时Python基础……所以没有这个基础的我看起来前期还挺费劲。当然，理解很好理解，就是在实现方法上不知原理的话就很难过。最主要的是，知道了原理在自己编写的时候可以的心用手，信手拈来。嗯~ o(<em>￣▽￣</em>)o就是这么写意和惬意。<!-- raw HTML omitted -->Indigo<!-- raw HTML omitted -->色在纯黑背景下不好辨识哈哈，还是换少女粉吧</p>
<hr>
<hr>
<hr>
<h1 id="vnpy-界面">
  Vn.Py 界面
  <a class="anchor" href="#vnpy-%e7%95%8c%e9%9d%a2">#</a>
</h1>
<p>Icon 图标下载网:    <a href="http://www.easyicon.net/">http://www.easyicon.net/</a></p>
<h2 id="界面设计文档">
  界面设计文档
  <a class="anchor" href="#%e7%95%8c%e9%9d%a2%e8%ae%be%e8%ae%a1%e6%96%87%e6%a1%a3">#</a>
</h2>
<h3 id="功能要求">
  功能要求
  <a class="anchor" href="#%e5%8a%9f%e8%83%bd%e8%a6%81%e6%b1%82">#</a>
</h3>
<p>连接、登陆，订阅，发撤单，持仓、账户信息、成交（下单时间、成交时间、备注（下单动作者））、保留交易模块、跟随鼠标点击更新交易模块中单子内容</p>
<h3 id="文档编写步骤">
  文档编写步骤
  <a class="anchor" href="#%e6%96%87%e6%a1%a3%e7%bc%96%e5%86%99%e6%ad%a5%e9%aa%a4">#</a>
</h3>
<p>由需求确定功能，划分模块，模块关系，下分框架，框架实现</p>
<hr>
<hr>
<h3 id="模块">
  模块
  <a class="anchor" href="#%e6%a8%a1%e5%9d%97">#</a>
</h3>
<p>工具栏、行情显示、策略池、账户持仓、消息栏</p>
<h4 id="工具栏">
  工具栏
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7%e6%a0%8f">#</a>
</h4>
<p>连接（含各个端口） 风控、帮助、登陆状态显示</p>
<h5 id="工具功能">
  工具功能
  <a class="anchor" href="#%e5%b7%a5%e5%85%b7%e5%8a%9f%e8%83%bd">#</a>
</h5>
<table>
<thead>
<tr>
<th style="text-align:left">工具名称</th>
<th style="text-align:center">说明</th>
<th style="text-align:right">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">连接</td>
<td style="text-align:center">弹出端口列表</td>
<td style="text-align:right">通过复选框选中对应端口</td>
</tr>
<tr>
<td style="text-align:left">风控</td>
<td style="text-align:center">弹出设定列表</td>
<td style="text-align:right">通过文本框输入设定数值</td>
</tr>
<tr>
<td style="text-align:left">帮助</td>
<td style="text-align:center">弹出帮助窗口</td>
<td style="text-align:right"></td>
</tr>
</tbody>
</table>
<h4 id="策略池">
  策略池
  <a class="anchor" href="#%e7%ad%96%e7%95%a5%e6%b1%a0">#</a>
</h4>
<table>
<thead>
<tr>
<th style="text-align:left">操作位置</th>
<th style="text-align:center">热点操作</th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">策略名称单元格</td>
<td style="text-align:center">鼠标指针悬停</td>
<td style="text-align:right">展开操作界面</td>
</tr>
<tr>
<td style="text-align:left">动作按钮</td>
<td style="text-align:center">鼠标单击</td>
<td style="text-align:right">执行选中</td>
</tr>
<tr>
<td style="text-align:left">动作按钮</td>
<td style="text-align:center">鼠标右击</td>
<td style="text-align:right">展开操作界面</td>
</tr>
</tbody>
</table>
<h4 id="消息栏">
  消息栏
  <a class="anchor" href="#%e6%b6%88%e6%81%af%e6%a0%8f">#</a>
</h4>
<p>分“成交”、“错误”、“日志”三个模块，选择相应模块显示对应内容</p>
<table>
<thead>
<tr>
<th style="text-align:left">日志</th>
<th style="text-align:center">错误</th>
<th style="text-align:center">成交</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">时间、内容、接口</td>
<td style="text-align:center">时间、错误代码、错误信息、接口</td>
<td style="text-align:center">成交编号、委托编号、合约代码、名称、方向、开平、价格、成交量、成交时间、接口</td>
</tr>
<tr>
<td style="text-align:left">显示操作日志</td>
<td style="text-align:center">显示当前操作错误信息</td>
<td style="text-align:center">显示成交单信息</td>
</tr>
</tbody>
</table>
<h4 id="账户持仓信息">
  账户持仓信息
  <a class="anchor" href="#%e8%b4%a6%e6%88%b7%e6%8c%81%e4%bb%93%e4%bf%a1%e6%81%af">#</a>
</h4>
<p>账户显示账户信息，并具备切换账户功能
当前选中账户 显示在旁label中。</p>
<h3 id="界面切换">
  界面切换
  <a class="anchor" href="#%e7%95%8c%e9%9d%a2%e5%88%87%e6%8d%a2">#</a>
</h3>
<h1 id="记录笔记">
  记录笔记
  <a class="anchor" href="#%e8%ae%b0%e5%bd%95%e7%ac%94%e8%ae%b0">#</a>
</h1>
<p>照例，先贴网址： <a href="http://www.qaulau.com/books/PyQt4_Tutorial/index.html">http://www.qaulau.com/books/PyQt4_Tutorial/index.html</a></p>
<h4 id="窗口设置">
  窗口设置
  <a class="anchor" href="#%e7%aa%97%e5%8f%a3%e8%ae%be%e7%bd%ae">#</a>
</h4>
<pre><code>resize(8, 8)
setWindowTitle(u'标题')
</code></pre>
<h4 id="获取图标">
  获取图标
  <a class="anchor" href="#%e8%8e%b7%e5%8f%96%e5%9b%be%e6%a0%87">#</a>
</h4>
<pre><code>def getIcon(filename):
&quot;&quot;&quot; 获取图标 &quot;&quot;&quot;
    fileInfo = Qt.QFileInfo(filename) 
    fileIcon = Qt.QFileIconProvider() 
    icon = QtGui.QIcon(fileIcon.icon(fileInfo)) 
    return icon  
使用时：
self.setWindowIcon(getIcon('../hi/app.ico'))
</code></pre>
<hr>
<h5 id="dock">
  Dock
  <a class="anchor" href="#dock">#</a>
</h5>
<pre><code>widgetTestM, dockTestM = self.createDock(AllMarketMonitor, vtText.“dock
标题”, QtCore.Qt.RightDockWidgetArea)
# 方向有：  
RightDockWidgetArea,BottomDockWidgetArea,LeftDockWidgetArea
# 创建dock窗口
# 可利用
self.tabifyDockWidget(dockMarketM, dockAllDataM)
来合并同一个方向上的dock

# 此下还没看… 
dockTradeM.raise_()
dockPositionM.raise_()

# 连接组件之间的信号
widgetPositionM.itemDoubleClicked.connect(widgetTradingW.closePosition)
    
# 保存默认设置
self.saveWindowSettings('default')
</code></pre>
<p>其实现函数为：
&ldquo;&ldquo;&ldquo;创建停靠组件&rdquo;&rdquo;&rdquo;</p>
<pre><code>def createDock(self, widgetClass, widgetName, widgetArea):
    widget = widgetClass(self.mainEngine, self.eventEngine) 
    dock = QtGui.QDockWidget(widgetName)
    dock.setWidget(widget)
    dock.setObjectName(widgetName)
    dock.setFeatures(dock.DockWidgetFloatable|dock.DockWidgetMovable)
    self.addDockWidget(widgetArea, dock)
    return widget, dock
</code></pre>
<blockquote>
<p>再本质一点的东西为：</p>
</blockquote>
<pre><code>widget1 = Ha(self)
dock = QtGui.QDockWidget('haha')
dock.setObjectName('ha1')
dock.setWidget(widget1)
dock.setFeatures(dock.DockWidgetFloatable | dock.DockWidgetMovable)
self.addDockWidget(QtCore.Qt.BottomDockWidgetArea, dock)
</code></pre>
<h4 id="动作">
  动作
  <a class="anchor" href="#%e5%8a%a8%e4%bd%9c">#</a>
</h4>
<pre><code>exit = QtGui.QAction(QtGui.QIcon('hello.ico'), 'exit', self)
exit.setShortcut('Ctrl+Q')
exit.setStatusTip('Exit application')
# 图标、文字、快捷键、提示信息

menubar = self.menuBar()
file = menubar.addMenu('&amp;File')
file.addAction(exit)
# 创建目录和工具栏，将动作添加进去。工具栏同理
</code></pre>
<h3 id="定位布局">
  定位布局
  <a class="anchor" href="#%e5%ae%9a%e4%bd%8d%e5%b8%83%e5%b1%80">#</a>
</h3>
<h4 id="绝对定位">
  绝对定位
  <a class="anchor" href="#%e7%bb%9d%e5%af%b9%e5%ae%9a%e4%bd%8d">#</a>
</h4>
<pre><code>label1 = QtGui.QLabel(u'绝对定位', self)
label1.move(15, 60)
# 创建、移动到显示位置
</code></pre>
<h4 id="框布局-及-布局元素平均分布">
  框布局 及 布局元素平均分布
  <a class="anchor" href="#%e6%a1%86%e5%b8%83%e5%b1%80-%e5%8f%8a-%e5%b8%83%e5%b1%80%e5%85%83%e7%b4%a0%e5%b9%b3%e5%9d%87%e5%88%86%e5%b8%83">#</a>
</h4>
<pre><code>okButton = QtGui.QPushButton(&quot;OK&quot;)
cancelButton = QtGui.QPushButton(&quot;Cancel&quot;)
# 创建按钮

hbox = QtGui.QHBoxLayout()
hbox.addStretch(1)
hbox.addWidget(okButton)        # 增加组件
hbox.addWidget(cancelButton)
# 创建水平栏
hbox.addStretch()   # 平均分布

vbox = QtGui.QVBoxLayout()
vbox.addStretch(1)
# 创建竖列

vbox.addLayout(hbox)
# 将水平栏插入竖列
self.setLayout(vbox)     
# 显示最终竖列
</code></pre>
<p>注意一下add时选择对类型就好了。</p>
<h4 id="组件之间连接信号">
  组件之间连接信号
  <a class="anchor" href="#%e7%bb%84%e4%bb%b6%e4%b9%8b%e9%97%b4%e8%bf%9e%e6%8e%a5%e4%bf%a1%e5%8f%b7">#</a>
</h4>
<pre><code># classA(QtGui.QTableWidget):
#   pass
classA.itemDoubleClicked.connect(classB.actionFunction)
# 这样单纯调用还是可以的，但是数据传输… 就得继续研究一下了。
</code></pre>
<h4 id="调用windows程序">
  调用Windows程序
  <a class="anchor" href="#%e8%b0%83%e7%94%a8windows%e7%a8%8b%e5%ba%8f">#</a>
</h4>
<pre><code>import win32api
    path = 'D:/vnpy-    \
    master/docker/dockerTrader/gateway/ctpGateway/CTP_connect.json'
    win32api.ShellExecute(0, 'open', 'notepad.exe', path, '', 1)
# 使用记事本打开此文件
</code></pre>
<h4 id="json">
  Json
  <a class="anchor" href="#json">#</a>
</h4>
<pre><code>with open('D:/vnpy- \
    master/docker/dockerTrader/gateway/ctpGateway/CTP_connect.json',
'r') as f:
setting = json.load(f)
self.userID = str(setting['userID'])
self.password = str(setting['password'])
</code></pre>
<h5 id="关闭事件退出提示">
  关闭事件退出提示
  <a class="anchor" href="#%e5%85%b3%e9%97%ad%e4%ba%8b%e4%bb%b6%e9%80%80%e5%87%ba%e6%8f%90%e7%a4%ba">#</a>
</h5>
<pre><code>def closeEvent(self, event):
    reply = QtGui.QMessageBox.question(self, 'Message',&quot;Are you 
sure to quit?&quot;, QtGui.QMessageBox.Yes, QtGui.QMessageBox.No)
if reply == QtGui.QMessageBox.Yes:
    event.accept()
else:
    event.ignore()
</code></pre>
<p>函数放置位置就是主窗口类下就好。</p>
<h5 id="vs2015-快捷键">
  VS2015 快捷键
  <a class="anchor" href="#vs2015-%e5%bf%ab%e6%8d%b7%e9%94%ae">#</a>
</h5>
<pre><code>Ctrl + k    Ctrl + c        # 多行注释
Ctrl + k    Ctrl + u        # 多行取消注释
</code></pre>
<h5 id="鼠标事件">
  鼠标事件
  <a class="anchor" href="#%e9%bc%a0%e6%a0%87%e4%ba%8b%e4%bb%b6">#</a>
</h5>
<p>press
move
release
doubleClick
clicked()
enterEvent 鼠标移入
leaveEvent 鼠标移出
回去看看具体函数</p>
<h2 id="信号槽传输额外参数">
  信号槽（传输额外参数）
  <a class="anchor" href="#%e4%bf%a1%e5%8f%b7%e6%a7%bd%e4%bc%a0%e8%be%93%e9%a2%9d%e5%a4%96%e5%8f%82%e6%95%b0">#</a>
</h2>
<p>一般来说，比如一个按钮吧。 在链接点击信号与槽时<code>buttonInit[i].clicked.connect(partial(self.init, i))</code>就完事了。然而，当循环创建按钮，对应同样的槽函数，只是需要执行的变量有区别时，就需要传输额外的参数。
这时，方法有二：</p>
<p>环境：</p>
<p>python2.7.8</p>
<p>pyqt 4.11.1</p>
<h3 id="一-使用lambda表达式">
  一： 使用lambda表达式
  <a class="anchor" href="#%e4%b8%80-%e4%bd%bf%e7%94%a8lambda%e8%a1%a8%e8%be%be%e5%bc%8f">#</a>
</h3>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="二-使用functools里的partial函数">
  二： 使用functools里的partial函数
  <a class="anchor" href="#%e4%ba%8c-%e4%bd%bf%e7%94%a8functools%e9%87%8c%e7%9a%84partial%e5%87%bd%e6%95%b0">#</a>
</h3>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>三：感谢<a href="http://blog.csdn.net/fengyu09/article/details/39498777">来源</a></p>
<hr>
<hr>
<hr>
<h1 id="策略管理">
  策略管理
  <a class="anchor" href="#%e7%ad%96%e7%95%a5%e7%ae%a1%e7%90%86">#</a>
</h1>
<p>策略类，引擎，报单管理&amp;&amp;仓位管理</p>
<h2 id="引擎">
  引擎
  <a class="anchor" href="#%e5%bc%95%e6%93%8e">#</a>
</h2>
<p>引擎中将策略事件有序添加到事件引擎和主引擎中。 读取setting.json 文件对策略参数以及是否启用进行配置。设定日期。
使用策略实例字典保存策略名与实例关系——
并将此字典在推送字典中与tick数据ID对应（ID对多实例。）
再有orderID与策略对应字典，用以推送order和trade数据
计数本地停止单 、 持仓缓存字典</p>
<h2 id="报单管理">
  报单管理
  <a class="anchor" href="#%e6%8a%a5%e5%8d%95%e7%ae%a1%e7%90%86">#</a>
</h2>
<h3 id="成交推送处理">
  成交推送处理
  <a class="anchor" href="#%e6%88%90%e4%ba%a4%e6%8e%a8%e9%80%81%e5%a4%84%e7%90%86">#</a>
</h3>
<p>成交回调 - &gt; 订单ID和策略对应字典 -&gt; 计算策略持仓（根据策略方向，持仓增加交易笔数）-&gt; 更新持仓缓存数据</p>
<h3 id="报单者类">
  报单者类
  <a class="anchor" href="#%e6%8a%a5%e5%8d%95%e8%80%85%e7%b1%bb">#</a>
</h3>
<p>单一合约订单缓存类——初始化buffer 存储字典_log策略日志存储</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#vnpyhttpsstaticvnpycomstaticimgindex2019-5-27mainwindowpng"><img src="https://static.vnpy.com/static/img/index/2019-5-27/mainwindow.PNG" alt="vn.py"></a></li>
    <li><a href="#初期笔记">初期笔记</a></li>
    <li><a href="#引擎之间执行过程">引擎之间执行过程</a>
      <ul>
        <li><a href="#发单为例">发单为例：</a></li>
        <li><a href="#调用关系">调用关系</a></li>
      </ul>
    </li>
    <li><a href="#ctpgateway-接入方法">ctpGateway 接入方法</a></li>
    <li><a href="#数据记录器">数据记录器</a>
      <ul>
        <li></li>
      </ul>
    </li>
    <li><a href="#风控模块">风控模块</a></li>
    <li><a href="#cta策略">CTA策略</a></li>
    <li><a href="#ctp交易托管api">CTP交易托管API</a>
      <ul>
        <li><a href="#介绍">介绍</a></li>
        <li><a href="#体系结构">体系结构</a></li>
        <li><a href="#接口模式">接口模式</a></li>
        <li><a href="#运行模式">运行模式</a></li>
        <li><a href="#撤单-发单">撤单 发单</a></li>
        <li><a href="#traderapi所有方法功能">TraderApi所有方法功能</a></li>
      </ul>
    </li>
    <li><a href="#cta-策略引擎">CTA 策略引擎</a>
      <ul>
        <li></li>
        <li><a href="#记录">记录</a></li>
        <li><a href="#cta回测">CTA回测</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#事件引擎">事件引擎</a></li>
  </ul>

  <ul>
    <li><a href="#界面设计文档">界面设计文档</a>
      <ul>
        <li><a href="#功能要求">功能要求</a></li>
        <li><a href="#文档编写步骤">文档编写步骤</a></li>
        <li><a href="#模块">模块</a></li>
        <li><a href="#界面切换">界面切换</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li></li>
        <li><a href="#定位布局">定位布局</a></li>
      </ul>
    </li>
    <li><a href="#信号槽传输额外参数">信号槽（传输额外参数）</a>
      <ul>
        <li><a href="#一-使用lambda表达式">一： 使用lambda表达式</a></li>
        <li><a href="#二-使用functools里的partial函数">二： 使用functools里的partial函数</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#引擎">引擎</a></li>
    <li><a href="#报单管理">报单管理</a>
      <ul>
        <li><a href="#成交推送处理">成交推送处理</a></li>
        <li><a href="#报单者类">报单者类</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












