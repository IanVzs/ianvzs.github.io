<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>learning on Ian's Blog</title><link>http://example.org/categories/learning/</link><description>Recent content in learning on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Dec 2021 16:00:00 +0000</lastBuildDate><atom:link href="http://example.org/categories/learning/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker</title><link>http://example.org/docs/programmer/cloudnative/note-of-docker/</link><pubDate>Thu, 16 Dec 2021 16:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/note-of-docker/</guid><description>Docker # 教程手册 # 好用的使用教程
Install # 略过~ 😁
打镜像和跑 # docker build -t server:v0 . -f server.dockerfile 跑 # docker run -p 9080:80 --name server server:v0 指定启动命令 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;echo hello&amp;#34; 加入自定义网络 # --network {{network name}} 详见：[[#Network]]
跑出问题-进入容器排查 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;bash&amp;#34; 使用-it进入容器手动执行命令进行调试
启动全部容器 # docker ps -a | grep &amp;#34;Exited&amp;#34; | awk &amp;#39;{print $1}&amp;#39; | xargs docker start Network # docker run时容器加入方法-redis为例 后期加入方式 创建一个新网 检测 init_redis: docker run -p 6379:6379 \\ --network websafe-network \\ --name redislatest redis:latest --requirepass 3b21d032a7fd8eb51fa7bd8a2e812b78b7b3a36f join_network: docker network connect websafe-network mysql56 docker network connect websafe-network daemon-xxx init_network: docker network create websafe-network check_network: docker network inspect websafe-network docker network inspect websafe-network | findStr IPv4Address 删除 # 可视化 # go install github.</description></item><item><title>Docker</title><link>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-docker/</link><pubDate>Thu, 16 Dec 2021 16:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-docker/</guid><description>Docker # 教程手册 # 好用的使用教程
Install # 略过~ 😁
基础命令 # 打镜像和跑 # 打 # docker build -t server:v0 . -f server.dockerfile dockerignore # 如果您想在 Dockerfile 中将当前目录中的所有文件都复制到 Docker 镜像中，可以使用 Dockerfile 中的 COPY 指令。具体的语法如下：
COPY . /目标路径/ 其中. 表示当前目录，/目标路径/ 表示目标路径，这里可以是绝对路径或相对路径。 这将会将当前目录中的所有文件复制到镜像中的 /app/ 目录下。请注意，在这种情况下，所有文件和文件夹都会被复制到镜像中，包括隐藏文件和文件夹。如果您不想复制某些文件或文件夹，可以在运行 COPY 指令之前通过 .dockerignore 文件来指定忽略的文件和文件夹。
跑 # docker run -p 9080:80 --name server server:v0 指定启动命令 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;echo hello&amp;#34; 加入自定义网络 # --network {{network name}} 详见：[[#Network]]</description></item><item><title>UE4 笔记</title><link>http://example.org/docs/3dgame/noteofue4/</link><pubDate>Mon, 10 May 2021 12:13:26 +0000</pubDate><guid>http://example.org/docs/3dgame/noteofue4/</guid><description> UE4 笔记 # 手机 # 路径必须不能用汉字, 一律全英文(神奇&amp;hellip;以前习惯就是全英,以为这问题是上世纪的了,测试时不知怎么就把顺手的英文换成中文了,结果就莫名中枪了) java8 (ue4.26.2, 之前4.25也是, 反正就找个稳定版java一直使吧, 这语言太amazing了.) 虽然对java版本有一定要求, 不过按照我这次的测试和使用, 觉得折腾那么久完全是汉字项目名不支持&amp;hellip;所以java版本要求应该不是很严重 动画 # 事件图表&amp;amp;动画图表 # 事件图表: 收集动画-&amp;gt;存储在变量中 动画图表: 驱动所有动作 事件图表 # isValid # 蓝图不知道被哪个实例持有(通用)
朝向 # 主角本地坐标X轴正方向表正前方
GetVelocity
RotationFromXVector
GetControlRotaion
2,3求Delta.
输出 # 速度 方向 总步骤 # 向量长度获取Speed 向量方向-控制器方向获取Direction 以上2保存为变量, 交由动画图表 动画图表 # Params-Blend-Result:
获取速度,方向(看情况可多可少) 将1输入动画混合空间 输出姿势 State Machine # 在以上一组动作中加入状态细分
State Machine - State1-(rule)-State2&amp;hellip;StateN State - (Params-Blend-Result) 生效 # 角色 网格体(骨骼网格体) 动画-动画类-动画蓝图</description></item><item><title>Nginx高可用</title><link>http://example.org/docs/programmer/cloudnative/nginx-%E9%AB%98%E5%8F%AF%E7%94%A8/</link><pubDate>Sun, 09 May 2021 09:56:41 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/nginx-%E9%AB%98%E5%8F%AF%E7%94%A8/</guid><description>Keepalived+Nginx实现高可用 # Nginx 关键字 # IO多路复用epoll(IO复用) 轻量,插件: Nginx仅保留了HTTP CPU亲和: 每个worker进程固定在一个CPU Nginx配置 # 代理 # 动静分离 # 动态页面和静态页面交给不同的服务器来解析
负载均衡 # upstream balanceServer { server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345; } server { server_name fe.server.com; listen 80; location /api { proxy_pass http://balanceServer; } } 机制 # 默认: 轮询, 单机卡顿, 影响分配在这台服务器下的用户 默认: 权重轮询, 宕机Nginx会自动剔除出队列, ip_hash-来源IP分配分配给同个服务器 fair: 根据相应时间均衡分配, 默认不支持. 需安装upstream_fair, url_hash类ip_hash同样需要安装Nginx的hash软件包. Keepalived 配置 # 粘贴自: 这里
概览 # VIP IP 主机名 Nginx端口 默认主从 192.</description></item><item><title>Tips of debuggers</title><link>http://example.org/docs/programmer/langs/tips-of-debugers/</link><pubDate>Thu, 10 Jan 2019 12:21:12 +0000</pubDate><guid>http://example.org/docs/programmer/langs/tips-of-debugers/</guid><description>Clang &amp;amp;&amp;amp; lldb # 听说clang+lldb &amp;gt;= gcc + gdb, 所以一试:
lldb基本命令 # 与GDB相同
break (b) - 设置断点，也就是程序暂停的地方 run (r) - 启动目标程序，如果遇到断点则暂停 step (s) - 进入下一条指令中的函数内部 backtrace (bt) - 显示当前的有效函数 frame (f) - 默认显示当前栈的内容，可以通过 frame arg 进入特定的 frame（用作输出本地变量） next (n) - 运行当前箭头指向行 continue (c) - 继续运行程序直到遇到断点。 clang hello.c -g -o hello lldb hello # lldb b main run n p str 还有颜色 😂 可视效果确实提高了不少 而且这四个工具可以混用,也蛮好.
GDB # First and foremost, you will need to compile your program with the flag &amp;ldquo;-g&amp;rdquo; (for debug) to run it via GDB.</description></item><item><title>Golang笔记</title><link>http://example.org/docs/programmer/langs/golang/note-of-golang/</link><pubDate>Tue, 15 May 2018 10:18:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/note-of-golang/</guid><description>Golang笔记 # 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html
垃圾回收 # 常见的回收算法 # 引用计数 优点：对象可以被很快回收 缺点：不太好处理循环引用 标记-清除 优点：解决了引用计数的缺点 缺点：需要 STW(Stop The World),暂时停止程序运行 分代收集(按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，段的放入新生代，不同代有不同的回收算法和回收频率) 优点：回收性能好 缺点：算法复杂 三色标记法(初始状态：白色、从根节点开始遍历，遍历到的变成灰色，遍历灰色，将灰色引用的标记灰色，遍历过的灰色对象变为黑色。循环遍历灰色对象。通过写屏障检测对象的变化，重复。收集所有白色对象(垃圾)) GPM调度和CSP模型 # CSP 模型？ # CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通 过共享内存来通信。用于描述两个独立的并发实体通过共享的通 讯 channel (管道)进行通信的并发模型。
GPM 分别是什么、分别有多少数量？ # • G（Goroutine）： 即Go协程，每个go关键字都会创建一个协 程。 • M（Machine）：工作线程，在Go中称为Machine，数量对应真 实的CPU数（真正干活的对象）。 • P（Processor）： 处理器（Go中定义的一个摡念，非CPU）， 包含运行Go代码的必要资源，用来调度 G 和 M 之间的关联关 系，其数量可通过 GOMAXPROCS() 来设置，默认为核心数。 M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队 列，P可以调度G交由M执行。
Goroutine调度策略 # • 队列轮转：P 会周期性的将G调度到M中执行，执行一段时间 后，保存上下文，将G放到队列尾部，然后从队列中再取出一个 G进行调度。除此之外，P还会周期性的查看全局队列是否有G等 待调度到M中执行。 • 系统调用：当G0即将进入系统调用时，M0将释放P，进而某个空 闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是 M的缓存池，也可能是新建的。 当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执 行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。 然后M0将进入缓存池睡眠。 !</description></item><item><title>Vn.Py学习笔记（Python交易平台框架）</title><link>http://example.org/docs/programmer/gui/vn.py%E7%AC%94%E8%AE%B0-%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Tue, 15 May 2018 10:13:48 +0000</pubDate><guid>http://example.org/docs/programmer/gui/vn.py%E7%AC%94%E8%AE%B0-%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>author: Ian
Vn.Py笔记 ✏📔 # # 一个开源Python交易软件，主使用CTP协议。当然，还有其他协议了其源项目在http://www.vnpy.org/ 初期笔记 # 报单交易过程中， CTP使用BrokerID 从业务层面完全隔离不同经纪公司的交易、风控及结算用户的接入。 BrokerID具体取值咨询开户的经纪公司。 CTP中 UserID为操作员代码，InversterID为投资者代码； 投资者自己下单两者同为投资者代码
CTP-API中，OrderRef和OrderAction 前者为CTP后台提供给客户端标识一笔报 单的字段，从客户端可通过（FrontID、SessionID、OrderRef）唯一确定一笔报 单；；；后者与OrderRef功能相似，提供给客户端来标识一笔撤单。 前者的数据类型为字符数组，必须为阿拉伯数字字符。 OrderRef（OrderActionRef）取值必须保证在同一会话内发送的报单 OrderRef（OrderActionRef）值大于之前的最大值，开发多线程客户端尤为需要 注意。 CTP-API库：
error.dtd\error.xml 错误定义文件 ---- ThostFrfcMdApi.h 交易接口类定义文件 ——— ThostFtfcUserApiDataType.h 类型定义文件 ------ thostmduserapi.lib,thostmduserpi.dll 行情接口库文件 ----- thosttraderapi.lib,thosttraderapi.dll交易接口库文件 ----- 交易和行情接口类定义文件都包含API 和 SPI类定义，客户端使用API向CTP后台 发送请求，CTP后台则使用SPI向客户端回传响应及回报 行情Demo开发： 1.将API文件复制到工程目录；并将所有的头文件和静态、动态库连链接库 并将文件导入到项目工程中。 先继承行情接口类CThostFtdcMdspi，并实现需要实现的虚函数。 OnFrontConnectde、OnFrontDisconnected、OnPspUserLogin、 OnRspSubMarketDAta /API工作流程***/
API压缩包——API含常量对应字符、类型定义、操作系统编译定义、回调函数（MdSpi）（柜台向用户端发送信息后被系统自动调用的函数）、主动函数（MdApi）（向柜台发送各种请求和指令）
API工作流程： 创建MdSpi对象（回掉函数），调用MdApi类，以Create开头的静态方法，创建MdApi对象（主动函数），注册MdSpi对象指针，行情柜台前置机地址，调用MdApi对象Init方法初始化连接前置机，连接成功会通过OnFrontConnected回调通知用户，用户获得连接成功通知后，调MdApi的ReqUserLogin登陆，登陆后MdSpi的OnRsqUserLogin通知用户 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-到此登陆完成&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
MdApi：（行情相关） 使用MdApi对象的SubscribeMarketData方法，传入参数为想要订阅的“合约 代码”，订阅成功当合约有新行情通过MdApi的OnRtnDepthMarketData回调通知 用户 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-至此订阅完成&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 当用户的某次请求发生错误时，会通过OnRspError通知用户 MdApi也含有退订合约、登出功能。 而一般退出程序则直接杀进程（不太安全便是）
TraderApi：（交易相关） 不同于以上的有 注册TraderSpi对象的指针后需要调用TraderApi对象的 SubscribePrivateTopic和SubscribePublicTopic方法去选择公开和私有数据流的重 传方法 对于期货柜台，每一日第一次登陆需要先查询前一日的结算单，等待查询 结果返回，确认，才可进行后续操作（CTP、恒生UFT），证券（LTS）无此要求 上一步完成后，用户可以调用ReqQryInstrument的方法查询柜台上所有可 以交易的合约信息（包括代码、中文名、涨跌停、最小价位变动、合约乘数等大 量细节），一般是在这里获得合约信息列表后，再去MdApi中订阅合约；经常有 人问为什么在MdApi中找不到查询可供订阅的合约代码的函数，这里尤其要注 意，必须通过TraderApi来获取 当用户报单、成交状态发生变化时，TraderApi会自动通过OnRtnOrder、 OnRtnTrade通知，无需额外订阅 /封装API****/ 封装后API的动作： 主动函数： 调用封装API主动函数，传入Python变量作为参数—&amp;gt;封装API将Python变量转换成C++变量—&amp;gt;API调用原生API主动函数传入C++变量作为参数 回掉函数： 交易柜台通过原生API传入参数为C++变量-&amp;gt;封装API将C++变量转换为Python变量-&amp;gt;封装API调用封装后的回调函数想Python程序中推送数</description></item><item><title>tip Of vim</title><link>http://example.org/docs/programmer/basetc/tipsofvim/</link><pubDate>Tue, 15 May 2018 09:56:41 +0000</pubDate><guid>http://example.org/docs/programmer/basetc/tipsofvim/</guid><description>Vim 使用 # 除去“简便生活”里的几条配置，在纠结是否添加到别的地方，果然还是单独给vim一个使用手册比较好……
注释 # # 注释 1， 12s/^/#/g --- # 取消注释 1， 12s/^#//g 其实 是vim中的 :s替换命令… 下方解释
或者，使用列编辑的模式:
v、选择区域、ctrl q置行首、I插入#、Esc应用到全列 ctrl v、I、#、Esc 因为有的ctrl q或者ctrl v 不能用…… 取消，即使用上述方法选中行首，删除第一个字节即可了 替换 # :s/oldWords/newWords/g g : 代表当前光标所在行。
由此可知: # ^表行首标识符。 /^/表示行首的空字符。 而取消注释中的/^#/即表示行首的#，被//空字符所替换。
删除:g/出现计算意外/d # :g/出现计算意外/d 查找高亮 # set hlsearch set nohlsearch 分屏 # 实现 # 在外部使用-o or -O参数 内部split or vsplit 操作 # 移动光标 Ctrl + w hjkl 移动分区Ctrl + w HJKL 统一高度Ctrl + w = 改变高度Ctrl + w +- more and less # 阅读器~~~ 因为经常读大文件发现了这两个的无敌好处——快。</description></item><item><title>数据库-MySQL篇</title><link>http://example.org/docs/programmer/database/note-of-db-data-mysql/</link><pubDate>Tue, 15 May 2018 09:51:09 +0000</pubDate><guid>http://example.org/docs/programmer/database/note-of-db-data-mysql/</guid><description>MySQL数据库 🖥 📊🖥 # 安装 # docker # podman run -d --name mysql-container -e MYSQL_ROOT_PASSWORD={my-secret-pw} -e MYSQL_TIME_ZONE=UTC -e MYSQL_CHARSET=utf8 -p 3306:3306 mysql:5.7 使用 # 常用命令 # CREATE DATABASE {database_name} DEFAULT CHARACTER SET utf8mb4 DEFAULT COLLATE utf8mb4_unicode_ci; 按天统计 # SELECT DATE(created_at) AS date, COUNT(*) AS count FROM `TABLE_NAME` WHERE created_at &amp;gt;= &amp;#34;2025-01-01&amp;#34; AND created_at &amp;lt; &amp;#34;2025-02-01&amp;#34; GROUP BY DATE(created_at) ORDER BY date LIMIT 100 连接 # 使用MySQL命令行工具连接MySQL时，你可以使用以下命令来：
启用压缩传输 # mysql --compress -u username -p 完整命令如：</description></item><item><title>Git</title><link>http://example.org/docs/programmer/platforms/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/platforms/git/</guid><description>Git # 1. 同步远端放弃本地 # git fetch --all git reset --hard origin/master git pull Windows下问题 # [[Problem of Windows#Windows下Git问题]]
2. git 项目由 Ext4 -&amp;gt; NTFS 复制后 # 文件权限发生变化, Git追踪文件权限的话会标记所有文件都需要修改 因为在Linux 下文件权限为 -rw-r--r--（所有者可读写，其他用户只读）,但是Linux下挂载NTFS文件权限为 -rwxr-xr-x（所有者可读、写、执行，其他用户可读、执行）就很难受
git config core.filemode false # 关闭github监控文件权限 # git config core.filemode false --global 自己的小仓库 - Gogs 简介 # Gogs (Go Git Service) 是一个用 Go 语言编写的自托管 Git 服务，类似于 GitHub Gitlab Gitee。它轻量、快速且易于安装，适合个人或小团队使用。Gogs 提供了基本的 Git 仓库管理功能，包括代码托管、问题跟踪、Pull Request 等。
源码安装 # 安装依赖：</description></item><item><title>愉快的Java(happy to learn the fuck java)</title><link>http://example.org/docs/programmer/langs/java/notesjava/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/java/notesjava/</guid><description>author: Ian
happy to learn the fuck java 😅 # &amp;lt;微人事&amp;gt; 笔记 -&amp;gt; ψ(._. )&amp;gt; # 先贴官方文档 哦 还有官方项目地址
Java语法 # 爪哇方法定义: # 修饰符 返回值类型 方法名(参数类型 参数名){ 方法体; return 返回值; } # 示个例 public boolean NiHou(int num){ int a = num; return turn; } // `boolean` 处 可为 public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities(){ List&amp;lt;GrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;(); return authorities; } // 表泛型中可以是的`GrantedAuthority`所有子类 爪哇抽象方法(即Python父类中直接pass的函数…) # abstract
包含抽象方法必须得是抽象类 任何子类必须重写父类抽象方法，或者声明自身为抽象类 public abstract class Employee { private String name; private int number; public abstract double computePay(); //其余 } 爪哇接口 # interface, implements</description></item></channel></rss>