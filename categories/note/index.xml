<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>note on Ian's Blog</title><link>http://example.org/categories/note/</link><description>Recent content in note on Ian's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 16 Dec 2021 16:00:00 +0000</lastBuildDate><atom:link href="http://example.org/categories/note/index.xml" rel="self" type="application/rss+xml"/><item><title>Docker</title><link>http://example.org/docs/programmer/cloudnative/note-of-docker/</link><pubDate>Thu, 16 Dec 2021 16:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/note-of-docker/</guid><description>Docker # 教程手册 # 好用的使用教程
Install # 略过~ 😁
打镜像和跑 # docker build -t server:v0 . -f server.dockerfile 跑 # docker run -p 9080:80 --name server server:v0 指定启动命令 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;echo hello&amp;#34; 加入自定义网络 # --network {{network name}} 详见：[[#Network]]
跑出问题-进入容器排查 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;bash&amp;#34; 使用-it进入容器手动执行命令进行调试
启动全部容器 # docker ps -a | grep &amp;#34;Exited&amp;#34; | awk &amp;#39;{print $1}&amp;#39; | xargs docker start Network # docker run时容器加入方法-redis为例 后期加入方式 创建一个新网 检测 init_redis: docker run -p 6379:6379 \\ --network websafe-network \\ --name redislatest redis:latest --requirepass 3b21d032a7fd8eb51fa7bd8a2e812b78b7b3a36f join_network: docker network connect websafe-network mysql56 docker network connect websafe-network daemon-xxx init_network: docker network create websafe-network check_network: docker network inspect websafe-network docker network inspect websafe-network | findStr IPv4Address 删除 # 可视化 # go install github.</description></item><item><title>Docker</title><link>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-docker/</link><pubDate>Thu, 16 Dec 2021 16:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/cloudnative/%E5%AE%B9%E5%99%A8/note-of-docker/</guid><description>Docker # 教程手册 # 好用的使用教程
Install # 略过~ 😁
基础命令 # 打镜像和跑 # 打 # docker build -t server:v0 . -f server.dockerfile dockerignore # 如果您想在 Dockerfile 中将当前目录中的所有文件都复制到 Docker 镜像中，可以使用 Dockerfile 中的 COPY 指令。具体的语法如下：
COPY . /目标路径/ 其中. 表示当前目录，/目标路径/ 表示目标路径，这里可以是绝对路径或相对路径。 这将会将当前目录中的所有文件复制到镜像中的 /app/ 目录下。请注意，在这种情况下，所有文件和文件夹都会被复制到镜像中，包括隐藏文件和文件夹。如果您不想复制某些文件或文件夹，可以在运行 COPY 指令之前通过 .dockerignore 文件来指定忽略的文件和文件夹。
跑 # docker run -p 9080:80 --name server server:v0 指定启动命令 # sudo docker run -it -p 9080:80 --name nova_server nova_server:v0 sh -c &amp;#34;echo hello&amp;#34; 加入自定义网络 # --network {{network name}} 详见：[[#Network]]</description></item><item><title>Golang进阶笔记</title><link>http://example.org/docs/programmer/langs/golang/advanced-knowledge-of-golang/</link><pubDate>Wed, 19 May 2021 19:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/advanced-knowledge-of-golang/</guid><description>Golang进阶笔记 # 路径问题 # test_test.go # package main import &amp;#34;testing&amp;#34; func TestHelloWorld(t *testing.T) { // t.Fatal(&amp;#34;not implemented&amp;#34;) path := getCurrentPath() t.Log(&amp;#34;getCurrentPath: &amp;#34;, path) } test.go # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;strings&amp;#34; ) func main() { fmt.Println(&amp;#34;getTmpDir（当前系统临时目录） = &amp;#34;, getTmpDir()) fmt.Println(&amp;#34;getCurrentAbPathByExecutable（仅支持go build） = &amp;#34;, getCurrentAbPathByExecutable()) fmt.Println(&amp;#34;getCurrentAbPathByCaller（仅支持go run） = &amp;#34;, getCurrentAbPathByCaller()) fmt.Println(&amp;#34;getCurrentAbPath（最终方案-全兼容） = &amp;#34;, getCurrentAbPath()) fmt.Println(&amp;#34;getCurrentPath（runtime.Caller1） = &amp;#34;, getCurrentPath()) } // 最终方案-全兼容 func getCurrentAbPath() string { dir := getCurrentAbPathByExecutable() if strings.</description></item><item><title>Golang进阶笔记</title><link>http://example.org/docs/programmer/langs/golang/noteofgoexp/</link><pubDate>Wed, 19 May 2021 19:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/noteofgoexp/</guid><description>Golang进阶笔记 # 路径问题 # test_test.go # package main import &amp;#34;testing&amp;#34; func TestHelloWorld(t *testing.T) { // t.Fatal(&amp;#34;not implemented&amp;#34;) path := getCurrentPath() t.Log(&amp;#34;getCurrentPath: &amp;#34;, path) } test.go # package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;path&amp;#34; &amp;#34;path/filepath&amp;#34; &amp;#34;runtime&amp;#34; &amp;#34;strings&amp;#34; ) func main() { fmt.Println(&amp;#34;getTmpDir（当前系统临时目录） = &amp;#34;, getTmpDir()) fmt.Println(&amp;#34;getCurrentAbPathByExecutable（仅支持go build） = &amp;#34;, getCurrentAbPathByExecutable()) fmt.Println(&amp;#34;getCurrentAbPathByCaller（仅支持go run） = &amp;#34;, getCurrentAbPathByCaller()) fmt.Println(&amp;#34;getCurrentAbPath（最终方案-全兼容） = &amp;#34;, getCurrentAbPath()) fmt.Println(&amp;#34;getCurrentPath（runtime.Caller1） = &amp;#34;, getCurrentPath()) } // 最终方案-全兼容 func getCurrentAbPath() string { dir := getCurrentAbPathByExecutable() if strings.</description></item><item><title>UE4 笔记</title><link>http://example.org/docs/3dgame/noteofue4/</link><pubDate>Mon, 10 May 2021 12:13:26 +0000</pubDate><guid>http://example.org/docs/3dgame/noteofue4/</guid><description> UE4 笔记 # 手机 # 路径必须不能用汉字, 一律全英文(神奇&amp;hellip;以前习惯就是全英,以为这问题是上世纪的了,测试时不知怎么就把顺手的英文换成中文了,结果就莫名中枪了) java8 (ue4.26.2, 之前4.25也是, 反正就找个稳定版java一直使吧, 这语言太amazing了.) 虽然对java版本有一定要求, 不过按照我这次的测试和使用, 觉得折腾那么久完全是汉字项目名不支持&amp;hellip;所以java版本要求应该不是很严重 动画 # 事件图表&amp;amp;动画图表 # 事件图表: 收集动画-&amp;gt;存储在变量中 动画图表: 驱动所有动作 事件图表 # isValid # 蓝图不知道被哪个实例持有(通用)
朝向 # 主角本地坐标X轴正方向表正前方
GetVelocity
RotationFromXVector
GetControlRotaion
2,3求Delta.
输出 # 速度 方向 总步骤 # 向量长度获取Speed 向量方向-控制器方向获取Direction 以上2保存为变量, 交由动画图表 动画图表 # Params-Blend-Result:
获取速度,方向(看情况可多可少) 将1输入动画混合空间 输出姿势 State Machine # 在以上一组动作中加入状态细分
State Machine - State1-(rule)-State2&amp;hellip;StateN State - (Params-Blend-Result) 生效 # 角色 网格体(骨骼网格体) 动画-动画类-动画蓝图</description></item><item><title>Golang笔记</title><link>http://example.org/docs/programmer/langs/golang/note-of-golang/</link><pubDate>Tue, 15 May 2018 10:18:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/note-of-golang/</guid><description>Golang笔记 # 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html
垃圾回收 # 常见的回收算法 # 引用计数 优点：对象可以被很快回收 缺点：不太好处理循环引用 标记-清除 优点：解决了引用计数的缺点 缺点：需要 STW(Stop The World),暂时停止程序运行 分代收集(按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，段的放入新生代，不同代有不同的回收算法和回收频率) 优点：回收性能好 缺点：算法复杂 三色标记法(初始状态：白色、从根节点开始遍历，遍历到的变成灰色，遍历灰色，将灰色引用的标记灰色，遍历过的灰色对象变为黑色。循环遍历灰色对象。通过写屏障检测对象的变化，重复。收集所有白色对象(垃圾)) GPM调度和CSP模型 # CSP 模型？ # CSP 模型是“以通信的方式来共享内存”，不同于传统的多线程通 过共享内存来通信。用于描述两个独立的并发实体通过共享的通 讯 channel (管道)进行通信的并发模型。
GPM 分别是什么、分别有多少数量？ # • G（Goroutine）： 即Go协程，每个go关键字都会创建一个协 程。 • M（Machine）：工作线程，在Go中称为Machine，数量对应真 实的CPU数（真正干活的对象）。 • P（Processor）： 处理器（Go中定义的一个摡念，非CPU）， 包含运行Go代码的必要资源，用来调度 G 和 M 之间的关联关 系，其数量可通过 GOMAXPROCS() 来设置，默认为核心数。 M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队 列，P可以调度G交由M执行。
Goroutine调度策略 # • 队列轮转：P 会周期性的将G调度到M中执行，执行一段时间 后，保存上下文，将G放到队列尾部，然后从队列中再取出一个 G进行调度。除此之外，P还会周期性的查看全局队列是否有G等 待调度到M中执行。 • 系统调用：当G0即将进入系统调用时，M0将释放P，进而某个空 闲的M1获取P，继续执行P队列中剩下的G。M1的来源有可能是 M的缓存池，也可能是新建的。 当G0系统调用结束后，如果有空闲的P，则获取一个P，继续执 行G0。如果没有，则将G0放入全局队列，等待被其他的P调度。 然后M0将进入缓存池睡眠。 !</description></item><item><title>Golang笔记</title><link>http://example.org/docs/programmer/langs/golang/noteofgolang/</link><pubDate>Tue, 15 May 2018 10:18:26 +0000</pubDate><guid>http://example.org/docs/programmer/langs/golang/noteofgolang/</guid><description>Golang笔记 # 先贴一个客观的教程文档网站http://www.runoob.com/go/go-slice.html
并发 Channel # 使用关键字go开启goroutine 轻量级线程
go fun_name(paras_list) # eg: go f(x, y, z) 代码
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func say(s string) { for i := 0; i &amp;lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;#34;world&amp;#34;) say(&amp;#34;hello&amp;#34;) } Channel # 用于传递数据的数据结构 可用于两个goroutine之间传递指定类型值，同步和通讯 &amp;lt;- 指定通道方向(发送or接受)，未指定则双向通道
声明通道 # 使用chan关键字, 在使用之前，需先创建.
ch := make(chan int) 示例
package main import &amp;#34;fmt&amp;#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c &amp;lt;- sum // 把 sum 发送到通道 c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := &amp;lt;-c, &amp;lt;-c // 从通道 c 中接收 fmt.</description></item><item><title>Vn.Py学习笔记（Python交易平台框架）</title><link>http://example.org/docs/programmer/gui/vn.py%E7%AC%94%E8%AE%B0-%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</link><pubDate>Tue, 15 May 2018 10:13:48 +0000</pubDate><guid>http://example.org/docs/programmer/gui/vn.py%E7%AC%94%E8%AE%B0-%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF/</guid><description>author: Ian
Vn.Py笔记 ✏📔 # # 一个开源Python交易软件，主使用CTP协议。当然，还有其他协议了其源项目在http://www.vnpy.org/ 初期笔记 # 报单交易过程中， CTP使用BrokerID 从业务层面完全隔离不同经纪公司的交易、风控及结算用户的接入。 BrokerID具体取值咨询开户的经纪公司。 CTP中 UserID为操作员代码，InversterID为投资者代码； 投资者自己下单两者同为投资者代码
CTP-API中，OrderRef和OrderAction 前者为CTP后台提供给客户端标识一笔报 单的字段，从客户端可通过（FrontID、SessionID、OrderRef）唯一确定一笔报 单；；；后者与OrderRef功能相似，提供给客户端来标识一笔撤单。 前者的数据类型为字符数组，必须为阿拉伯数字字符。 OrderRef（OrderActionRef）取值必须保证在同一会话内发送的报单 OrderRef（OrderActionRef）值大于之前的最大值，开发多线程客户端尤为需要 注意。 CTP-API库：
error.dtd\error.xml 错误定义文件 ---- ThostFrfcMdApi.h 交易接口类定义文件 ——— ThostFtfcUserApiDataType.h 类型定义文件 ------ thostmduserapi.lib,thostmduserpi.dll 行情接口库文件 ----- thosttraderapi.lib,thosttraderapi.dll交易接口库文件 ----- 交易和行情接口类定义文件都包含API 和 SPI类定义，客户端使用API向CTP后台 发送请求，CTP后台则使用SPI向客户端回传响应及回报 行情Demo开发： 1.将API文件复制到工程目录；并将所有的头文件和静态、动态库连链接库 并将文件导入到项目工程中。 先继承行情接口类CThostFtdcMdspi，并实现需要实现的虚函数。 OnFrontConnectde、OnFrontDisconnected、OnPspUserLogin、 OnRspSubMarketDAta /API工作流程***/
API压缩包——API含常量对应字符、类型定义、操作系统编译定义、回调函数（MdSpi）（柜台向用户端发送信息后被系统自动调用的函数）、主动函数（MdApi）（向柜台发送各种请求和指令）
API工作流程： 创建MdSpi对象（回掉函数），调用MdApi类，以Create开头的静态方法，创建MdApi对象（主动函数），注册MdSpi对象指针，行情柜台前置机地址，调用MdApi对象Init方法初始化连接前置机，连接成功会通过OnFrontConnected回调通知用户，用户获得连接成功通知后，调MdApi的ReqUserLogin登陆，登陆后MdSpi的OnRsqUserLogin通知用户 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-到此登陆完成&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
MdApi：（行情相关） 使用MdApi对象的SubscribeMarketData方法，传入参数为想要订阅的“合约 代码”，订阅成功当合约有新行情通过MdApi的OnRtnDepthMarketData回调通知 用户 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-至此订阅完成&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 当用户的某次请求发生错误时，会通过OnRspError通知用户 MdApi也含有退订合约、登出功能。 而一般退出程序则直接杀进程（不太安全便是）
TraderApi：（交易相关） 不同于以上的有 注册TraderSpi对象的指针后需要调用TraderApi对象的 SubscribePrivateTopic和SubscribePublicTopic方法去选择公开和私有数据流的重 传方法 对于期货柜台，每一日第一次登陆需要先查询前一日的结算单，等待查询 结果返回，确认，才可进行后续操作（CTP、恒生UFT），证券（LTS）无此要求 上一步完成后，用户可以调用ReqQryInstrument的方法查询柜台上所有可 以交易的合约信息（包括代码、中文名、涨跌停、最小价位变动、合约乘数等大 量细节），一般是在这里获得合约信息列表后，再去MdApi中订阅合约；经常有 人问为什么在MdApi中找不到查询可供订阅的合约代码的函数，这里尤其要注 意，必须通过TraderApi来获取 当用户报单、成交状态发生变化时，TraderApi会自动通过OnRtnOrder、 OnRtnTrade通知，无需额外订阅 /封装API****/ 封装后API的动作： 主动函数： 调用封装API主动函数，传入Python变量作为参数—&amp;gt;封装API将Python变量转换成C++变量—&amp;gt;API调用原生API主动函数传入C++变量作为参数 回掉函数： 交易柜台通过原生API传入参数为C++变量-&amp;gt;封装API将C++变量转换为Python变量-&amp;gt;封装API调用封装后的回调函数想Python程序中推送数</description></item><item><title>数据库-MongoDB篇</title><link>http://example.org/docs/programmer/database/note-of-db-data-mongodb/</link><pubDate>Tue, 15 May 2018 09:51:09 +0000</pubDate><guid>http://example.org/docs/programmer/database/note-of-db-data-mongodb/</guid><description>DB数据库 🖥 📊🖥 # MongoDB笔记 # 学习网站：http://www.runoob.com/mongodb/mongodb-tutorial.html (其学习教程还挺可观，很多，不过还不清楚好不好)
安装 # Docker 安装 4.4.12版本 # pull: docker pull mongo:4.4.13 run: docker run -itd --name mongo --restart=always \ -v /mongodb/datadb:/data/db \ -p 27017:27017 \ --network websafe-network \ --privileged=true mongo:4.4.12 进入容器docker exec -it mongo bash后:
mongo use admin # db.createUser({user: &amp;#34;admin&amp;#34;, pwd: &amp;#34;admin&amp;#34;, roles: [{role: &amp;#34;root&amp;#34;, db: &amp;#34;admin&amp;#34;}]}) # db.createUser({user: &amp;#34;admin&amp;#34;, pwd: &amp;#34;admin&amp;#34;, roles: [{role: &amp;#34;userAdminAnyDatabase&amp;#34;, db: &amp;#34;admin&amp;#34;}]}) # 如果能auth就不用createUser了 db.auth(&amp;#34;admin&amp;#34;, &amp;#34;admin&amp;#34;) 网上传的将 MONGO_INITDB_ROOT_PASSWORD 和 MONGO_INITDB_ROOT_USERNAME传入环境变量的方式，在mongo4.</description></item><item><title>数据库-MySQL篇</title><link>http://example.org/docs/programmer/database/note-of-db-data-mysql/</link><pubDate>Tue, 15 May 2018 09:51:09 +0000</pubDate><guid>http://example.org/docs/programmer/database/note-of-db-data-mysql/</guid><description>MySQL数据库 🖥 📊🖥 # 连接 # 使用MySQL命令行工具连接MySQL时，你可以使用以下命令来：
启用压缩传输 # mysql --compress -u username -p 完整命令如：
mysql --compress -u{username} -p{passwd} --host {host} {db name} 2024-05-27: 但是很可惜，很多第三方连接库都不支持这个参数。
MySQL 8.0 # 因为在更新8.0 之后更改了用户密码加密形式所以在使用客户端连接的时候会出现错误，所以需要
ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; #修改加密规则 ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password'; #更新用户的密码 FLUSH PRIVILEGES; #刷新权限 经此步骤，就可以将密码加密形式改为图形化客户端支持的加密形式，也或者更待客户端跟着服务端同步更新。
另外，配置之初，windows 中配置步骤如下：
添加系统环境变量path 为MySQL/bin 初始化 mysqld --initialize --user=mysql --console 根据初始化随机生成密码登陆 修改密码 emm 这里说的是在外部，当然也可以在修改加密形式的时候一并修改 😄 mysqladmin -u root -p password 添加系统服务 mysqld -install 启动服务 net start mysql 另外在图像化里面注意密码格式呦，还有使用navicat的话需要最新版本，否则无法设置加密格式，还得用命令行去修改……果然还是命令行永远最好用</description></item><item><title>愉快的Java(happy to learn the fuck java)</title><link>http://example.org/docs/programmer/langs/java/notesjava/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>http://example.org/docs/programmer/langs/java/notesjava/</guid><description>author: Ian
happy to learn the fuck java 😅 # &amp;lt;微人事&amp;gt; 笔记 -&amp;gt; ψ(._. )&amp;gt; # 先贴官方文档 哦 还有官方项目地址
Java语法 # 爪哇方法定义: # 修饰符 返回值类型 方法名(参数类型 参数名){ 方法体; return 返回值; } # 示个例 public boolean NiHou(int num){ int a = num; return turn; } // `boolean` 处 可为 public Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities(){ List&amp;lt;GrantedAuthority&amp;gt; authorities = new ArrayList&amp;lt;&amp;gt;(); return authorities; } // 表泛型中可以是的`GrantedAuthority`所有子类 爪哇抽象方法(即Python父类中直接pass的函数…) # abstract
包含抽象方法必须得是抽象类 任何子类必须重写父类抽象方法，或者声明自身为抽象类 public abstract class Employee { private String name; private int number; public abstract double computePay(); //其余 } 爪哇接口 # interface, implements</description></item></channel></rss>